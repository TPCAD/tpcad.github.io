<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Algorithm_avltree | Eulamber</title>
<meta name="keywords" content="Algorithm, Tree, Data Structure">
<meta name="description" content="平衡二叉树是一种平衡的二叉搜索树。

空树是平衡二叉树
左右子树的高度差的绝对值不超过 1
左右子树也是平衡二叉树

AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即
$$
平衡因子 = 左子树的高度 - 右子树的高度
$$
节点定义
AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。
struct avl_tree {
  private:
    struct avl_node {
      public:
        T key;
        unsigned size;
        unsigned count;
        unsigned height;
        avl_node *left;
        avl_node *right;

        avl_node(const T &amp;value)
            : key(value), size(1), count(1), height(1), left(nullptr),
              right(nullptr) {}
    };

    avl_node *root;

  public:
    avl_tree() : root(nullptr) {}
    avl_tree(const T &amp;value) : root(nullptr) { root = new avl_node(value); }

    avl_tree(std::initializer_list&lt;T&gt; list) : root(nullptr) {
        root = new avl_node(*list.begin());
        std::for_each(list.begin() &#43; 1, list.end(),
                      [this](auto &amp;&amp;x) { this-&gt;insert(x); });
    }
}
平衡
旋转
旋转 是一种将节点变成它的子节点的节点的操作，可以分为 左旋 和 右旋。关于旋转方向的定义有很多，甚至有些相互矛盾。这里规定，">
<meta name="author" content="TPCAD">
<link rel="canonical" href="https://tpcad.github.io/posts/algorithm_avltree/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2e30b57bafed6e94d54f7201ae109ae389750633c8a6e2a525687239cdbf85db.css" integrity="sha256-LjC1e6/tbpTVT3IBrhCa44l1BjPIpuKlJWhyOc2/hds=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tpcad.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tpcad.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tpcad.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tpcad.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tpcad.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://tpcad.github.io/posts/algorithm_avltree/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://tpcad.github.io/posts/algorithm_avltree/">
  <meta property="og:site_name" content="Eulamber">
  <meta property="og:title" content="Algorithm_avltree">
  <meta property="og:description" content="平衡二叉树是一种平衡的二叉搜索树。
空树是平衡二叉树 左右子树的高度差的绝对值不超过 1 左右子树也是平衡二叉树 AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即
$$ 平衡因子 = 左子树的高度 - 右子树的高度 $$
节点定义 AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。
struct avl_tree { private: struct avl_node { public: T key; unsigned size; unsigned count; unsigned height; avl_node *left; avl_node *right; avl_node(const T &amp;value) : key(value), size(1), count(1), height(1), left(nullptr), right(nullptr) {} }; avl_node *root; public: avl_tree() : root(nullptr) {} avl_tree(const T &amp;value) : root(nullptr) { root = new avl_node(value); } avl_tree(std::initializer_list&lt;T&gt; list) : root(nullptr) { root = new avl_node(*list.begin()); std::for_each(list.begin() &#43; 1, list.end(), [this](auto &amp;&amp;x) { this-&gt;insert(x); }); } } 平衡 旋转 旋转 是一种将节点变成它的子节点的节点的操作，可以分为 左旋 和 右旋。关于旋转方向的定义有很多，甚至有些相互矛盾。这里规定，">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-22T08:24:44+08:00">
    <meta property="article:modified_time" content="2024-11-22T08:24:44+08:00">
    <meta property="article:tag" content="Algorithm">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Data Structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algorithm_avltree">
<meta name="twitter:description" content="平衡二叉树是一种平衡的二叉搜索树。

空树是平衡二叉树
左右子树的高度差的绝对值不超过 1
左右子树也是平衡二叉树

AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即
$$
平衡因子 = 左子树的高度 - 右子树的高度
$$
节点定义
AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。
struct avl_tree {
  private:
    struct avl_node {
      public:
        T key;
        unsigned size;
        unsigned count;
        unsigned height;
        avl_node *left;
        avl_node *right;

        avl_node(const T &amp;value)
            : key(value), size(1), count(1), height(1), left(nullptr),
              right(nullptr) {}
    };

    avl_node *root;

  public:
    avl_tree() : root(nullptr) {}
    avl_tree(const T &amp;value) : root(nullptr) { root = new avl_node(value); }

    avl_tree(std::initializer_list&lt;T&gt; list) : root(nullptr) {
        root = new avl_node(*list.begin());
        std::for_each(list.begin() &#43; 1, list.end(),
                      [this](auto &amp;&amp;x) { this-&gt;insert(x); });
    }
}
平衡
旋转
旋转 是一种将节点变成它的子节点的节点的操作，可以分为 左旋 和 右旋。关于旋转方向的定义有很多，甚至有些相互矛盾。这里规定，">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tpcad.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Algorithm_avltree",
      "item": "https://tpcad.github.io/posts/algorithm_avltree/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Algorithm_avltree",
  "name": "Algorithm_avltree",
  "description": "平衡二叉树是一种平衡的二叉搜索树。\n空树是平衡二叉树 左右子树的高度差的绝对值不超过 1 左右子树也是平衡二叉树 AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即\n$$ 平衡因子 = 左子树的高度 - 右子树的高度 $$\n节点定义 AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。\nstruct avl_tree { private: struct avl_node { public: T key; unsigned size; unsigned count; unsigned height; avl_node *left; avl_node *right; avl_node(const T \u0026amp;value) : key(value), size(1), count(1), height(1), left(nullptr), right(nullptr) {} }; avl_node *root; public: avl_tree() : root(nullptr) {} avl_tree(const T \u0026amp;value) : root(nullptr) { root = new avl_node(value); } avl_tree(std::initializer_list\u0026lt;T\u0026gt; list) : root(nullptr) { root = new avl_node(*list.begin()); std::for_each(list.begin() + 1, list.end(), [this](auto \u0026amp;\u0026amp;x) { this-\u0026gt;insert(x); }); } } 平衡 旋转 旋转 是一种将节点变成它的子节点的节点的操作，可以分为 左旋 和 右旋。关于旋转方向的定义有很多，甚至有些相互矛盾。这里规定，\n",
  "keywords": [
    "Algorithm", "Tree", "Data Structure"
  ],
  "articleBody": "平衡二叉树是一种平衡的二叉搜索树。\n空树是平衡二叉树 左右子树的高度差的绝对值不超过 1 左右子树也是平衡二叉树 AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即\n$$ 平衡因子 = 左子树的高度 - 右子树的高度 $$\n节点定义 AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。\nstruct avl_tree { private: struct avl_node { public: T key; unsigned size; unsigned count; unsigned height; avl_node *left; avl_node *right; avl_node(const T \u0026value) : key(value), size(1), count(1), height(1), left(nullptr), right(nullptr) {} }; avl_node *root; public: avl_tree() : root(nullptr) {} avl_tree(const T \u0026value) : root(nullptr) { root = new avl_node(value); } avl_tree(std::initializer_list\u003cT\u003e list) : root(nullptr) { root = new avl_node(*list.begin()); std::for_each(list.begin() + 1, list.end(), [this](auto \u0026\u0026x) { this-\u003einsert(x); }); } } 平衡 旋转 旋转 是一种将节点变成它的子节点的节点的操作，可以分为 左旋 和 右旋。关于旋转方向的定义有很多，甚至有些相互矛盾。这里规定，\n左旋 指的是将一个节点变成它的右子节点的左子节点的操作，即该节点向左下方旋转，其子节点向左上方旋转，整体呈逆时针旋转。\n右旋 指的是将一个节点变成它的左子节点的右子节点的操作，即该节点向右下方旋转，其子节点向右上方旋转，整体呈顺时针旋转。\n下图是一个右旋操作，节点 6 和其左子节点 4 顺时针旋转，旋转后节点 4 的右子节点会变成节点 6 的左子节点。\n6 4 / \\ / \\ 4 7 Right Rotate 3 6 / \\ ------------\u003e / / \\ 3 5 2 5 7 / 2 下图是一个左旋操作，节点 6 和其右子节点 9 逆时针旋转，旋转后节点 9 的左子节点会变成节点 6 的右子节点。\n6 9 / \\ / \\ 4 9 Left Rotate 6 10 / \\ ------------\u003e / \\ \\ 8 10 4 8 11 \\ 11 在插入或删除节点时可能会导致 AVL 树不平衡，即平衡因子的绝对值大于 1，此时便需要通过 旋转 操作使二叉树再次平衡。\n失衡状态可以分为四种情况：\nLL 型 6 \u003c-- h(l) - h(r) = 2 4 / \\ / \\ h(l) - h(r) = 1 --\u003e 4 7 ---------\u003e 3 6 / \\ / / \\ 3 5 2 5 7 / 2 以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 1，这种失衡状态称为 LL 型。对于 LL 型失衡，将其失衡根节点进行一次 右旋 即可重新平衡。\n/** * @brief 处理 LL 型失衡 * @param root 失衡节点 * @return 旋转后的根节点，即原失衡节点的左子节点 */ avl_node *left_left_rotation(avl_node *root) { avl_node *new_rt = root-\u003eleft; // 失衡节点的左子节点 // 失衡节点的新左子节点等于其旧左子节点的右子节点 root-\u003eleft = new_rt-\u003eright; // 左子节点的右子节点等于失衡节点 new_rt-\u003eright = root; // 更新高度 root-\u003eheight = std::max(height(root-\u003eleft), height(root-\u003eright)) + 1; new_rt-\u003eheight = std::max(height(new_rt-\u003eleft), height(new_rt-\u003eright)) + 1; // 返回新的根节点 return new_rt; } RR 型 6 --\u003e h(l) - h(r) = -2 9 / \\ / \\ 4 9 --\u003e h(l) - h(r) = -1 6 10 / \\ ------\u003e / \\ \\ 8 10 4 8 11 \\ 11 以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 -1，这种失衡状态称为 RR 型。对于 RR 型失衡，将其失衡根节点进行一次 左旋 即可重新平衡。\n/** * @brief 处理 RR 型失衡 * @param root 失衡节点 * @return 旋转后的根节点，即原失衡节点的右子节点 */ avl_node *right_right_rotation(avl_node *root) { avl_node *new_rt = root-\u003eright; // 失衡节点的右子节点 // 失衡节点的新右子节点等于其旧右子节点的左子节点 root-\u003eright = new_rt-\u003eleft; // 右子节点的左子节点等于失衡节点 new_rt-\u003eleft = root; root-\u003eheight = std::max(height(root-\u003eleft), height(root-\u003eright)) + 1; new_rt-\u003eheight = std::max(height(new_rt-\u003eleft), height(new_rt-\u003eright)) + 1; return new_rt; } LR 型 6 --\u003e h(l) - h(r) = 2 / \\ h(l) - h(r) = -1 \u003c-- 4 7 / \\ 3 5 \\ 2 以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 -1，这种失衡状态称为 LR 型。对于 LR 型失衡，需要一次左旋和一次右旋才能重新平衡。\n6 6 5 / \\ / \\ / \\ 4 7 5 7 4 6 / \\ / \\ / / \\ 3 5 4 2 3 2 7 \\ / 2 3 Original Left Rotate Right Rotate 第一次旋转是对失衡节点的左子节点左旋，旋转之后二叉树的失衡状态变为 LL 型。第二次旋转是对失衡节点的右旋，旋转后二叉树重新平衡。\n/** * @brief 处理 LR 型失衡 * @param root 失衡节点 * @return 旋转后的根节点 */ avl_node *left_right_rotation(avl_node *root) { // 对失衡节点的左节点左旋 root-\u003eleft = right_right_rotation(root-\u003eleft); // 对失衡节点右旋 return left_left_rotation(root); } RL 型 6 --\u003e h(l) - h(r) = 2 / \\ 4 9 --\u003e h(l) - h(r) = 1 / \\ 8 10 / 11 以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 1，这种失衡状态称为 RL 型。对于 RR 型失衡，需要一次左旋和一次右旋才能重新平衡。\n6 6 8 / \\ / \\ / \\ 4 9 4 8 6 9 / \\ / \\ / \\ \\ 8 10 11 9 4 11 10 / \\ 11 10 Original Right Rotate Left Rotate 第一次旋转是对失衡节点的右子节点右旋，旋转之后二叉树的失衡状态变为 RR 型。第二次旋转是对失衡节点的左旋，旋转后二叉树重新平衡。\n/** * @brief 处理 RL 型失衡 * @param root 失衡节点 * @return 旋转后的根节点 */ avl_node *right_left_rotation(avl_node *root) { // 对失衡节点的右节点右旋 root-\u003eright = left_left_rotation(root-\u003eright); // 对失衡节点左旋 return right_right_rotation(root); } 插入 AVL 树的插入操作与二叉搜索树类似，但在每次插入后都要检查当前节点是否失衡，若失衡则要进行调整。\navl_node *insert_aux(avl_node *root, const T \u0026value) { if (root == nullptr) { return new avl_node(value); } if (root-\u003ekey == value) { root-\u003ecount++; } else if (root-\u003ekey \u003e value) { root-\u003eleft = insert_aux(root-\u003eleft, value); // 检查失衡 if (height(root-\u003eleft) - height(root-\u003eright) == 2u) { // 根据插入节点的位置判断 LL 型或 LR 型 root = (root-\u003eleft-\u003ekey \u003e value) ? left_left_rotation(root) : left_right_rotation(root); } } else { root-\u003eright = insert_aux(root-\u003eright, value); // 检查失衡 if (height(root-\u003eleft) - height(root-\u003eright) == -2u) { // 根据插入节点的位置判断 RR 型或 RL 型 root = (root-\u003eright-\u003ekey \u003e value) ? right_left_rotation(root) : right_right_rotation(root); } } root-\u003eheight = std::max(height(root-\u003eleft), height(root-\u003eright)) + 1; root-\u003esize = root-\u003ecount + (root-\u003eleft ? root-\u003eleft-\u003esize : 0) + (root-\u003eright ? root-\u003eright-\u003esize : 0); return root; } 删除 AVL 树的删除操作与二叉搜索树类似，但在每次删除后都要检查当前节点是否失衡，若失衡则要进行调整。\navl_node *remove_aux(avl_node *root, const T \u0026value) { if (root == nullptr) { return root; } if (root-\u003ekey == value) { if (root-\u003ecount \u003e 1) { root-\u003ecount--; } else { if (root-\u003eleft \u0026\u0026 root-\u003eright) { avl_node *successor = min_node(root-\u003eright); root-\u003ekey = successor-\u003ekey; root-\u003ecount = successor-\u003ecount; successor-\u003ecount = 1; root-\u003eright = remove_aux(root-\u003eright, successor-\u003ekey); } else { avl_node *child = root-\u003eleft != nullptr ? root-\u003eleft : root-\u003eright; delete root; return child; } } } else { avl_node *\u0026child = root-\u003ekey \u003e value ? root-\u003eleft : root-\u003eright; child = remove_aux(child, value); } // 检查失衡 if (height(root-\u003eleft) - height(root-\u003eright) == 2u) { root = (height(root-\u003eleft-\u003eleft) - height(root-\u003eleft-\u003eright) == 1u) ? left_left_rotation(root) : left_right_rotation(root); } else if (height(root-\u003eleft) - height(root-\u003eright) == -2u) { root = (height(root-\u003eright-\u003eleft) - height(root-\u003eright-\u003eright) == 1u) ? right_left_rotation(root) : right_right_rotation(root); } root-\u003eheight = std::max(height(root-\u003eleft), height(root-\u003eright)) + 1; root-\u003esize = root-\u003ecount + (root-\u003eleft ? root-\u003eleft-\u003esize : 0) + (root-\u003eright ? root-\u003eright-\u003esize : 0); return root; } 其他操作 AVL 树的其他操作与普通的二叉搜索树相同。\n参考资料 OI Wiki pdai tech ",
  "wordCount" : "857",
  "inLanguage": "en",
  "datePublished": "2024-11-22T08:24:44+08:00",
  "dateModified": "2024-11-22T08:24:44+08:00",
  "author":{
    "@type": "Person",
    "name": "TPCAD"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tpcad.github.io/posts/algorithm_avltree/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Eulamber",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tpcad.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tpcad.github.io/" accesskey="h" title="Eulamber (Alt + H)">Eulamber</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tpcad.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tpcad.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://tpcad.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Algorithm_avltree
    </h1>
    <div class="post-meta"><span title='2024-11-22 08:24:44 +0800 +0800'>November 22, 2024</span>&nbsp;·&nbsp;TPCAD

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details >
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e8%8a%82%e7%82%b9%e5%ae%9a%e4%b9%89" aria-label="节点定义">节点定义</a></li>
                    <li>
                        <a href="#%e5%b9%b3%e8%a1%a1" aria-label="平衡">平衡</a><ul>
                            
                    <li>
                        <a href="#%e6%97%8b%e8%bd%ac" aria-label="旋转">旋转</a></li>
                    <li>
                        <a href="#ll-%e5%9e%8b" aria-label="LL 型">LL 型</a></li>
                    <li>
                        <a href="#rr-%e5%9e%8b" aria-label="RR 型">RR 型</a></li>
                    <li>
                        <a href="#lr-%e5%9e%8b" aria-label="LR 型">LR 型</a></li>
                    <li>
                        <a href="#rl-%e5%9e%8b" aria-label="RL 型">RL 型</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%8f%92%e5%85%a5" aria-label="插入">插入</a></li>
                    <li>
                        <a href="#%e5%88%a0%e9%99%a4" aria-label="删除">删除</a></li>
                    <li>
                        <a href="#%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c" aria-label="其他操作">其他操作</a></li>
                    <li>
                        <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" aria-label="参考资料">参考资料</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>平衡二叉树是一种平衡的二叉搜索树。</p>
<ol>
<li>空树是平衡二叉树</li>
<li>左右子树的高度差的绝对值不超过 1</li>
<li>左右子树也是平衡二叉树</li>
</ol>
<p>AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 <strong>平衡因子</strong>。即</p>
<p>$$
平衡因子 = 左子树的高度 - 右子树的高度
$$</p>
<h2 id="节点定义">节点定义<a hidden class="anchor" aria-hidden="true" href="#节点定义">#</a></h2>
<p>AVL 树的节点与二叉搜索树类似，但多了一个 <code>height</code> 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">avl_tree</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">private</span><span style="color:#99d1db;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">avl_node</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ca9ee6">public</span><span style="color:#99d1db;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        T key;
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">unsigned</span> size;
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">unsigned</span> count;
</span></span><span style="display:flex;"><span>        <span style="color:#e78284">unsigned</span> height;
</span></span><span style="display:flex;"><span>        avl_node <span style="color:#99d1db;font-weight:bold">*</span>left;
</span></span><span style="display:flex;"><span>        avl_node <span style="color:#99d1db;font-weight:bold">*</span>right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        avl_node(<span style="color:#ca9ee6">const</span> T <span style="color:#99d1db;font-weight:bold">&amp;</span>value)
</span></span><span style="display:flex;"><span>            <span style="color:#99d1db;font-weight:bold">:</span> key(value), size(<span style="color:#ef9f76">1</span>), count(<span style="color:#ef9f76">1</span>), height(<span style="color:#ef9f76">1</span>), left(<span style="color:#ca9ee6">nullptr</span>),
</span></span><span style="display:flex;"><span>              right(<span style="color:#ca9ee6">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#99d1db;font-weight:bold">*</span>root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ca9ee6">public</span><span style="color:#99d1db;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    avl_tree() <span style="color:#99d1db;font-weight:bold">:</span> root(<span style="color:#ca9ee6">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    avl_tree(<span style="color:#ca9ee6">const</span> T <span style="color:#99d1db;font-weight:bold">&amp;</span>value) <span style="color:#99d1db;font-weight:bold">:</span> root(<span style="color:#ca9ee6">nullptr</span>) { root <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> avl_node(value); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    avl_tree(std<span style="color:#99d1db;font-weight:bold">::</span>initializer_list<span style="color:#99d1db;font-weight:bold">&lt;</span>T<span style="color:#99d1db;font-weight:bold">&gt;</span> list) <span style="color:#99d1db;font-weight:bold">:</span> root(<span style="color:#ca9ee6">nullptr</span>) {
</span></span><span style="display:flex;"><span>        root <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> avl_node(<span style="color:#99d1db;font-weight:bold">*</span>list.begin());
</span></span><span style="display:flex;"><span>        std<span style="color:#99d1db;font-weight:bold">::</span>for_each(list.begin() <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#ef9f76">1</span>, list.end(),
</span></span><span style="display:flex;"><span>                      [<span style="color:#ca9ee6">this</span>](<span style="color:#ca9ee6">auto</span> <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span>x) { <span style="color:#ca9ee6">this</span><span style="color:#99d1db;font-weight:bold">-&gt;</span>insert(x); });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="平衡">平衡<a hidden class="anchor" aria-hidden="true" href="#平衡">#</a></h2>
<h3 id="旋转">旋转<a hidden class="anchor" aria-hidden="true" href="#旋转">#</a></h3>
<p><strong>旋转</strong> 是一种将节点变成它的子节点的节点的操作，可以分为 <strong>左旋</strong> 和 <strong>右旋</strong>。关于旋转方向的定义有很多，甚至有些相互矛盾。这里规定，</p>
<p><strong>左旋</strong> 指的是将一个节点变成它的右子节点的左子节点的操作，即该节点向左下方旋转，其子节点向左上方旋转，整体呈逆时针旋转。</p>
<p><strong>右旋</strong> 指的是将一个节点变成它的左子节点的右子节点的操作，即该节点向右下方旋转，其子节点向右上方旋转，整体呈顺时针旋转。</p>
<p>下图是一个右旋操作，节点 6 和其左子节点 4 顺时针旋转，旋转后节点 4 的右子节点会变成节点 6 的左子节点。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        6                               4
      /   \                           /   \
     4     7      Right Rotate       3     6
    / \           ------------&gt;     /     / \
   3   5                           2     5   7
  /
 2
</code></pre><p>下图是一个左旋操作，节点 6 和其右子节点 9 逆时针旋转，旋转后节点 9 的左子节点会变成节点 6 的右子节点。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        6                               9
      /   \                           /   \
     4     9       Left Rotate       6     10
          / \     ------------&gt;     / \     \
         8  10                     4   8     11
              \
              11
</code></pre><p>在插入或删除节点时可能会导致 AVL 树不平衡，即平衡因子的绝对值大于 1，此时便需要通过 <strong>旋转</strong> 操作使二叉树再次平衡。</p>
<p>失衡状态可以分为四种情况：</p>
<h3 id="ll-型">LL 型<a hidden class="anchor" aria-hidden="true" href="#ll-型">#</a></h3>
<pre tabindex="0"><code class="language-language" data-lang="language">                       6  &lt;-- h(l) - h(r) = 2                      4
                     /   \                                       /   \
h(l) - h(r) = 1 --&gt; 4     7                    ---------&gt;       3     6
                   / \                                         /     / \
                  3   5                                       2     5   7
                 /
                2
</code></pre><p>以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 1，这种失衡状态称为 <strong>LL 型</strong>。对于 LL 型失衡，将其失衡根节点进行一次 <strong>右旋</strong> 即可重新平衡。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @brief  处理 LL 型失衡
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @param  root  失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @return  旋转后的根节点，即原失衡节点的左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#99d1db;font-weight:bold">*</span><span style="color:#8caaee">left_left_rotation</span>(avl_node <span style="color:#99d1db;font-weight:bold">*</span>root) {
</span></span><span style="display:flex;"><span>        avl_node <span style="color:#99d1db;font-weight:bold">*</span>new_rt <span style="color:#99d1db;font-weight:bold">=</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left; <span style="color:#737994;font-style:italic">// 失衡节点的左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 失衡节点的新左子节点等于其旧左子节点的右子节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left <span style="color:#99d1db;font-weight:bold">=</span> new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>right;
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 左子节点的右子节点等于失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>right <span style="color:#99d1db;font-weight:bold">=</span> root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 更新高度
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>height <span style="color:#99d1db;font-weight:bold">=</span> std<span style="color:#99d1db;font-weight:bold">::</span>max(height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left), height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right)) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#ef9f76">1</span>;
</span></span><span style="display:flex;"><span>        new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>height <span style="color:#99d1db;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>            std<span style="color:#99d1db;font-weight:bold">::</span>max(height(new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>left), height(new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>right)) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#ef9f76">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 返回新的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        <span style="color:#ca9ee6">return</span> new_rt;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="rr-型">RR 型<a hidden class="anchor" aria-hidden="true" href="#rr-型">#</a></h3>
<pre tabindex="0"><code class="language-language" data-lang="language">        6 --&gt; h(l) - h(r) = -2                    9
      /   \                                     /   \
     4     9 --&gt; h(l) - h(r) = -1              6     10
          / \                     ------&gt;     / \     \
         8  10                               4   8     11
              \
              11
</code></pre><p>以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 -1，这种失衡状态称为 <strong>RR 型</strong>。对于 RR 型失衡，将其失衡根节点进行一次 <strong>左旋</strong> 即可重新平衡。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @brief  处理 RR 型失衡
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @param  root  失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @return  旋转后的根节点，即原失衡节点的右子节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#99d1db;font-weight:bold">*</span><span style="color:#8caaee">right_right_rotation</span>(avl_node <span style="color:#99d1db;font-weight:bold">*</span>root) {
</span></span><span style="display:flex;"><span>        avl_node <span style="color:#99d1db;font-weight:bold">*</span>new_rt <span style="color:#99d1db;font-weight:bold">=</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right; <span style="color:#737994;font-style:italic">// 失衡节点的右子节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 失衡节点的新右子节点等于其旧右子节点的左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right <span style="color:#99d1db;font-weight:bold">=</span> new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>left;
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 右子节点的左子节点等于失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>left <span style="color:#99d1db;font-weight:bold">=</span> root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>height <span style="color:#99d1db;font-weight:bold">=</span> std<span style="color:#99d1db;font-weight:bold">::</span>max(height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left), height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right)) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#ef9f76">1</span>;
</span></span><span style="display:flex;"><span>        new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>height <span style="color:#99d1db;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>            std<span style="color:#99d1db;font-weight:bold">::</span>max(height(new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>left), height(new_rt<span style="color:#99d1db;font-weight:bold">-&gt;</span>right)) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#ef9f76">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> new_rt;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="lr-型">LR 型<a hidden class="anchor" aria-hidden="true" href="#lr-型">#</a></h3>
<pre tabindex="0"><code class="language-language" data-lang="language">                        6 --&gt; h(l) - h(r) = 2
                      /   \
h(l) - h(r) = -1 &lt;-- 4     7
                    / \
                   3   5
                        \
                         2
</code></pre><p>以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 -1，这种失衡状态称为 <strong>LR 型</strong>。对于 LR 型失衡，需要一次左旋和一次右旋才能重新平衡。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        6                       6                   5
      /   \                   /   \               /   \
     4     7                 5     7             4     6
    / \                     / \                 /     / \
   3   5                   4   2               3     2   7
        \                 /
         2               3
    Original               Left Rotate          Right Rotate
</code></pre><p>第一次旋转是对失衡节点的左子节点左旋，旋转之后二叉树的失衡状态变为 LL 型。第二次旋转是对失衡节点的右旋，旋转后二叉树重新平衡。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @brief  处理 LR 型失衡
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @param  root  失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @return  旋转后的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#99d1db;font-weight:bold">*</span><span style="color:#8caaee">left_right_rotation</span>(avl_node <span style="color:#99d1db;font-weight:bold">*</span>root) {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 对失衡节点的左节点左旋
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left <span style="color:#99d1db;font-weight:bold">=</span> right_right_rotation(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 对失衡节点右旋
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        <span style="color:#ca9ee6">return</span> left_left_rotation(root);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="rl-型">RL 型<a hidden class="anchor" aria-hidden="true" href="#rl-型">#</a></h3>
<pre tabindex="0"><code class="language-language" data-lang="language">        6 --&gt; h(l) - h(r) = 2
      /   \
     4     9 --&gt; h(l) - h(r) = 1
          / \
         8  10
        /
       11
</code></pre><p>以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 1，这种失衡状态称为 <strong>RL 型</strong>。对于 RR 型失衡，需要一次左旋和一次右旋才能重新平衡。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        6                       6                   8
      /   \                   /   \               /   \
     4     9                 4     8             6     9
          / \                     / \           / \     \
         8  10                  11   9         4  11    10
        /                             \
       11                             10
     Original               Right Rotate        Left Rotate
</code></pre><p>第一次旋转是对失衡节点的右子节点右旋，旋转之后二叉树的失衡状态变为 RR 型。第二次旋转是对失衡节点的左旋，旋转后二叉树重新平衡。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @brief  处理 RL 型失衡
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @param  root  失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     *  @return  旋转后的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#99d1db;font-weight:bold">*</span><span style="color:#8caaee">right_left_rotation</span>(avl_node <span style="color:#99d1db;font-weight:bold">*</span>root) {
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 对失衡节点的右节点右旋
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right <span style="color:#99d1db;font-weight:bold">=</span> left_left_rotation(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 对失衡节点左旋
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        <span style="color:#ca9ee6">return</span> right_right_rotation(root);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="插入">插入<a hidden class="anchor" aria-hidden="true" href="#插入">#</a></h2>
<p>AVL 树的插入操作与二叉搜索树类似，但在每次插入后都要检查当前节点是否失衡，若失衡则要进行调整。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    avl_node <span style="color:#99d1db;font-weight:bold">*</span><span style="color:#8caaee">insert_aux</span>(avl_node <span style="color:#99d1db;font-weight:bold">*</span>root, <span style="color:#ca9ee6">const</span> T <span style="color:#99d1db;font-weight:bold">&amp;</span>value) {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (root <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ca9ee6">nullptr</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> <span style="color:#ca9ee6">new</span> avl_node(value);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>key <span style="color:#99d1db;font-weight:bold">==</span> value) {
</span></span><span style="display:flex;"><span>            root<span style="color:#99d1db;font-weight:bold">-&gt;</span>count<span style="color:#99d1db;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">else</span> <span style="color:#ca9ee6">if</span> (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>key <span style="color:#99d1db;font-weight:bold">&gt;</span> value) {
</span></span><span style="display:flex;"><span>            root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left <span style="color:#99d1db;font-weight:bold">=</span> insert_aux(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left, value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 检查失衡
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>            <span style="color:#ca9ee6">if</span> (height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left) <span style="color:#99d1db;font-weight:bold">-</span> height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right) <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">2u</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#737994;font-style:italic">// 根据插入节点的位置判断 LL 型或 LR 型
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>                root <span style="color:#99d1db;font-weight:bold">=</span> (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left<span style="color:#99d1db;font-weight:bold">-&gt;</span>key <span style="color:#99d1db;font-weight:bold">&gt;</span> value) <span style="color:#99d1db;font-weight:bold">?</span> left_left_rotation(root)
</span></span><span style="display:flex;"><span>                                                 <span style="color:#99d1db;font-weight:bold">:</span> left_right_rotation(root);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>            root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right <span style="color:#99d1db;font-weight:bold">=</span> insert_aux(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right, value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#737994;font-style:italic">// 检查失衡
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>            <span style="color:#ca9ee6">if</span> (height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left) <span style="color:#99d1db;font-weight:bold">-</span> height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right) <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#99d1db;font-weight:bold">-</span><span style="color:#ef9f76">2u</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#737994;font-style:italic">// 根据插入节点的位置判断 RR 型或 RL 型
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>                root <span style="color:#99d1db;font-weight:bold">=</span> (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right<span style="color:#99d1db;font-weight:bold">-&gt;</span>key <span style="color:#99d1db;font-weight:bold">&gt;</span> value) <span style="color:#99d1db;font-weight:bold">?</span> right_left_rotation(root)
</span></span><span style="display:flex;"><span>                                                  <span style="color:#99d1db;font-weight:bold">:</span> right_right_rotation(root);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>height <span style="color:#99d1db;font-weight:bold">=</span> std<span style="color:#99d1db;font-weight:bold">::</span>max(height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left), height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right)) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#ef9f76">1</span>;
</span></span><span style="display:flex;"><span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>size <span style="color:#99d1db;font-weight:bold">=</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>count <span style="color:#99d1db;font-weight:bold">+</span> (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left <span style="color:#99d1db;font-weight:bold">?</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left<span style="color:#99d1db;font-weight:bold">-&gt;</span><span style="color:#99d1db">size</span> : <span style="color:#ef9f76">0</span>) <span style="color:#99d1db;font-weight:bold">+</span>
</span></span><span style="display:flex;"><span>                     (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right <span style="color:#99d1db;font-weight:bold">?</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right<span style="color:#99d1db;font-weight:bold">-&gt;</span><span style="color:#99d1db">size</span> : <span style="color:#ef9f76">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="删除">删除<a hidden class="anchor" aria-hidden="true" href="#删除">#</a></h2>
<p>AVL 树的删除操作与二叉搜索树类似，但在每次删除后都要检查当前节点是否失衡，若失衡则要进行调整。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    avl_node <span style="color:#99d1db;font-weight:bold">*</span><span style="color:#8caaee">remove_aux</span>(avl_node <span style="color:#99d1db;font-weight:bold">*</span>root, <span style="color:#ca9ee6">const</span> T <span style="color:#99d1db;font-weight:bold">&amp;</span>value) {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (root <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ca9ee6">nullptr</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">return</span> root;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">if</span> (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>key <span style="color:#99d1db;font-weight:bold">==</span> value) {
</span></span><span style="display:flex;"><span>            <span style="color:#ca9ee6">if</span> (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>count <span style="color:#99d1db;font-weight:bold">&gt;</span> <span style="color:#ef9f76">1</span>) {
</span></span><span style="display:flex;"><span>                root<span style="color:#99d1db;font-weight:bold">-&gt;</span>count<span style="color:#99d1db;font-weight:bold">--</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ca9ee6">if</span> (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left <span style="color:#99d1db;font-weight:bold">&amp;&amp;</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>                    avl_node <span style="color:#99d1db;font-weight:bold">*</span>successor <span style="color:#99d1db;font-weight:bold">=</span> min_node(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    root<span style="color:#99d1db;font-weight:bold">-&gt;</span>key <span style="color:#99d1db;font-weight:bold">=</span> successor<span style="color:#99d1db;font-weight:bold">-&gt;</span>key;
</span></span><span style="display:flex;"><span>                    root<span style="color:#99d1db;font-weight:bold">-&gt;</span>count <span style="color:#99d1db;font-weight:bold">=</span> successor<span style="color:#99d1db;font-weight:bold">-&gt;</span>count;
</span></span><span style="display:flex;"><span>                    successor<span style="color:#99d1db;font-weight:bold">-&gt;</span>count <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right <span style="color:#99d1db;font-weight:bold">=</span> remove_aux(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right, successor<span style="color:#99d1db;font-weight:bold">-&gt;</span>key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>                    avl_node <span style="color:#99d1db;font-weight:bold">*</span>child <span style="color:#99d1db;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>                        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left <span style="color:#99d1db;font-weight:bold">!=</span> <span style="color:#ca9ee6">nullptr</span> <span style="color:#99d1db;font-weight:bold">?</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span><span style="color:#99d1db">left</span> : root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right;
</span></span><span style="display:flex;"><span>                    <span style="color:#ca9ee6">delete</span> root;
</span></span><span style="display:flex;"><span>                    <span style="color:#ca9ee6">return</span> child;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">else</span> {
</span></span><span style="display:flex;"><span>            avl_node <span style="color:#99d1db;font-weight:bold">*&amp;</span>child <span style="color:#99d1db;font-weight:bold">=</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>key <span style="color:#99d1db;font-weight:bold">&gt;</span> value <span style="color:#99d1db;font-weight:bold">?</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span><span style="color:#99d1db">left</span> : root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            child <span style="color:#99d1db;font-weight:bold">=</span> remove_aux(child, value);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#737994;font-style:italic">// 检查失衡
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        <span style="color:#ca9ee6">if</span> (height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left) <span style="color:#99d1db;font-weight:bold">-</span> height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right) <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">2u</span>) {
</span></span><span style="display:flex;"><span>            root <span style="color:#99d1db;font-weight:bold">=</span> (height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left<span style="color:#99d1db;font-weight:bold">-&gt;</span>left) <span style="color:#99d1db;font-weight:bold">-</span> height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left<span style="color:#99d1db;font-weight:bold">-&gt;</span>right) <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">1u</span>)
</span></span><span style="display:flex;"><span>                       <span style="color:#99d1db;font-weight:bold">?</span> left_left_rotation(root)
</span></span><span style="display:flex;"><span>                       <span style="color:#99d1db;font-weight:bold">:</span> left_right_rotation(root);
</span></span><span style="display:flex;"><span>        } <span style="color:#ca9ee6">else</span> <span style="color:#ca9ee6">if</span> (height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left) <span style="color:#99d1db;font-weight:bold">-</span> height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right) <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#99d1db;font-weight:bold">-</span><span style="color:#ef9f76">2u</span>) {
</span></span><span style="display:flex;"><span>            root <span style="color:#99d1db;font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>                (height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right<span style="color:#99d1db;font-weight:bold">-&gt;</span>left) <span style="color:#99d1db;font-weight:bold">-</span> height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right<span style="color:#99d1db;font-weight:bold">-&gt;</span>right) <span style="color:#99d1db;font-weight:bold">==</span> <span style="color:#ef9f76">1u</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#99d1db;font-weight:bold">?</span> right_left_rotation(root)
</span></span><span style="display:flex;"><span>                    <span style="color:#99d1db;font-weight:bold">:</span> right_right_rotation(root);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>height <span style="color:#99d1db;font-weight:bold">=</span> std<span style="color:#99d1db;font-weight:bold">::</span>max(height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left), height(root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right)) <span style="color:#99d1db;font-weight:bold">+</span> <span style="color:#ef9f76">1</span>;
</span></span><span style="display:flex;"><span>        root<span style="color:#99d1db;font-weight:bold">-&gt;</span>size <span style="color:#99d1db;font-weight:bold">=</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>count <span style="color:#99d1db;font-weight:bold">+</span> (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left <span style="color:#99d1db;font-weight:bold">?</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>left<span style="color:#99d1db;font-weight:bold">-&gt;</span><span style="color:#99d1db">size</span> : <span style="color:#ef9f76">0</span>) <span style="color:#99d1db;font-weight:bold">+</span>
</span></span><span style="display:flex;"><span>                     (root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right <span style="color:#99d1db;font-weight:bold">?</span> root<span style="color:#99d1db;font-weight:bold">-&gt;</span>right<span style="color:#99d1db;font-weight:bold">-&gt;</span><span style="color:#99d1db">size</span> : <span style="color:#ef9f76">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="其他操作">其他操作<a hidden class="anchor" aria-hidden="true" href="#其他操作">#</a></h2>
<p>AVL 树的其他操作与普通的二叉搜索树相同。</p>
<h2 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h2>
<ol>
<li><a href="https://oi-wiki.org/ds/avl/">OI Wiki</a></li>
<li><a href="https://pdai.tech/md/algorithm/alg-basic-tree-balance.html">pdai tech</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tpcad.github.io/tags/algorithm/">Algorithm</a></li>
      <li><a href="https://tpcad.github.io/tags/tree/">Tree</a></li>
      <li><a href="https://tpcad.github.io/tags/data-structure/">Data Structure</a></li>
    </ul>
  </footer>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://tpcad.github.io/">Eulamber</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
