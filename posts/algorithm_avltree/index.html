<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Algorithm_avltree | Eulamber</title>
<meta name="keywords" content="Algorithm, Tree, Data Structure">
<meta name="description" content="平衡二叉树是一种平衡的二叉搜索树。

空树是平衡二叉树
左右子树的高度差的绝对值不超过 1
左右子树也是平衡二叉树

AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即
$$
平衡因子 = 左子树的高度 - 右子树的高度
$$
节点定义
AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。
struct avl_tree {
  private:
    struct avl_node {
      public:
        T key;
        unsigned size;
        unsigned count;
        unsigned height;
        avl_node *left;
        avl_node *right;

        avl_node(const T &amp;value)
            : key(value), size(1), count(1), height(1), left(nullptr),
              right(nullptr) {}
    };

    avl_node *root;

  public:
    avl_tree() : root(nullptr) {}
    avl_tree(const T &amp;value) : root(nullptr) { root = new avl_node(value); }

    avl_tree(std::initializer_list&lt;T&gt; list) : root(nullptr) {
        root = new avl_node(*list.begin());
        std::for_each(list.begin() &#43; 1, list.end(),
                      [this](auto &amp;&amp;x) { this-&gt;insert(x); });
    }
}
平衡
在插入或删除节点时可能会导致 AVL 树不平衡，即平衡因子的绝对值大于 1，此时便需要通过 旋转 操作使二叉树再次平衡。">
<meta name="author" content="TPCAD">
<link rel="canonical" href="https://tpcad.github.io/posts/algorithm_avltree/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tpcad.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tpcad.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tpcad.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tpcad.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tpcad.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://tpcad.github.io/posts/algorithm_avltree/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>

const config = {
    startOnLoad:true,
    theme: 'forest',
    themeVariables: {
        lineColor: "#fafafa"    
    },
    flowchart: {
        useMaxWidth:false,
        htmlLabels:true
        }
};
mermaid.initialize(config);


window.onload = () => {
    window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
}
</script>
<meta property="og:url" content="https://tpcad.github.io/posts/algorithm_avltree/">
  <meta property="og:site_name" content="Eulamber">
  <meta property="og:title" content="Algorithm_avltree">
  <meta property="og:description" content="平衡二叉树是一种平衡的二叉搜索树。
空树是平衡二叉树 左右子树的高度差的绝对值不超过 1 左右子树也是平衡二叉树 AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即
$$ 平衡因子 = 左子树的高度 - 右子树的高度 $$
节点定义 AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。
struct avl_tree { private: struct avl_node { public: T key; unsigned size; unsigned count; unsigned height; avl_node *left; avl_node *right; avl_node(const T &amp;value) : key(value), size(1), count(1), height(1), left(nullptr), right(nullptr) {} }; avl_node *root; public: avl_tree() : root(nullptr) {} avl_tree(const T &amp;value) : root(nullptr) { root = new avl_node(value); } avl_tree(std::initializer_list&lt;T&gt; list) : root(nullptr) { root = new avl_node(*list.begin()); std::for_each(list.begin() &#43; 1, list.end(), [this](auto &amp;&amp;x) { this-&gt;insert(x); }); } } 平衡 在插入或删除节点时可能会导致 AVL 树不平衡，即平衡因子的绝对值大于 1，此时便需要通过 旋转 操作使二叉树再次平衡。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-22T08:24:44+08:00">
    <meta property="article:modified_time" content="2024-11-22T08:24:44+08:00">
    <meta property="article:tag" content="Algorithm">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Data Structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algorithm_avltree">
<meta name="twitter:description" content="平衡二叉树是一种平衡的二叉搜索树。

空树是平衡二叉树
左右子树的高度差的绝对值不超过 1
左右子树也是平衡二叉树

AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即
$$
平衡因子 = 左子树的高度 - 右子树的高度
$$
节点定义
AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。
struct avl_tree {
  private:
    struct avl_node {
      public:
        T key;
        unsigned size;
        unsigned count;
        unsigned height;
        avl_node *left;
        avl_node *right;

        avl_node(const T &amp;value)
            : key(value), size(1), count(1), height(1), left(nullptr),
              right(nullptr) {}
    };

    avl_node *root;

  public:
    avl_tree() : root(nullptr) {}
    avl_tree(const T &amp;value) : root(nullptr) { root = new avl_node(value); }

    avl_tree(std::initializer_list&lt;T&gt; list) : root(nullptr) {
        root = new avl_node(*list.begin());
        std::for_each(list.begin() &#43; 1, list.end(),
                      [this](auto &amp;&amp;x) { this-&gt;insert(x); });
    }
}
平衡
在插入或删除节点时可能会导致 AVL 树不平衡，即平衡因子的绝对值大于 1，此时便需要通过 旋转 操作使二叉树再次平衡。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tpcad.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Algorithm_avltree",
      "item": "https://tpcad.github.io/posts/algorithm_avltree/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Algorithm_avltree",
  "name": "Algorithm_avltree",
  "description": "平衡二叉树是一种平衡的二叉搜索树。\n空树是平衡二叉树 左右子树的高度差的绝对值不超过 1 左右子树也是平衡二叉树 AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即\n$$ 平衡因子 = 左子树的高度 - 右子树的高度 $$\n节点定义 AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。\nstruct avl_tree { private: struct avl_node { public: T key; unsigned size; unsigned count; unsigned height; avl_node *left; avl_node *right; avl_node(const T \u0026amp;value) : key(value), size(1), count(1), height(1), left(nullptr), right(nullptr) {} }; avl_node *root; public: avl_tree() : root(nullptr) {} avl_tree(const T \u0026amp;value) : root(nullptr) { root = new avl_node(value); } avl_tree(std::initializer_list\u0026lt;T\u0026gt; list) : root(nullptr) { root = new avl_node(*list.begin()); std::for_each(list.begin() + 1, list.end(), [this](auto \u0026amp;\u0026amp;x) { this-\u0026gt;insert(x); }); } } 平衡 在插入或删除节点时可能会导致 AVL 树不平衡，即平衡因子的绝对值大于 1，此时便需要通过 旋转 操作使二叉树再次平衡。\n",
  "keywords": [
    "Algorithm", "Tree", "Data Structure"
  ],
  "articleBody": "平衡二叉树是一种平衡的二叉搜索树。\n空树是平衡二叉树 左右子树的高度差的绝对值不超过 1 左右子树也是平衡二叉树 AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即\n$$ 平衡因子 = 左子树的高度 - 右子树的高度 $$\n节点定义 AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。\nstruct avl_tree { private: struct avl_node { public: T key; unsigned size; unsigned count; unsigned height; avl_node *left; avl_node *right; avl_node(const T \u0026value) : key(value), size(1), count(1), height(1), left(nullptr), right(nullptr) {} }; avl_node *root; public: avl_tree() : root(nullptr) {} avl_tree(const T \u0026value) : root(nullptr) { root = new avl_node(value); } avl_tree(std::initializer_list\u003cT\u003e list) : root(nullptr) { root = new avl_node(*list.begin()); std::for_each(list.begin() + 1, list.end(), [this](auto \u0026\u0026x) { this-\u003einsert(x); }); } } 平衡 在插入或删除节点时可能会导致 AVL 树不平衡，即平衡因子的绝对值大于 1，此时便需要通过 旋转 操作使二叉树再次平衡。\n失衡状态可以分为四种情况：\nLL 型 6 \u003c-- h(l) - h(r) = 2 / \\ h(l) - h(r) = 1 --\u003e 4 7 / \\ 3 5 / 2 以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 1，这种失衡状态称为 LL 型。对于 LL 型失衡，将其失衡根节点进行一次 左旋 即可重新平衡。\n4 / \\ 3 6 / / \\ 2 5 7 左旋即将节点变为其左子节点的右子节点，其左子节点的右子节点变为该节点的的左子节点。\n以上图为例，节点 6 是失衡节点，将它变为它的左子节点，也就是节点 4 的右子节点，同时节点 4 的右子节点变为节点 6 的左子结点。\n/** * @brief 处理 LL 型失衡 * @param root 失衡节点 * @return 旋转后的根节点，即原失衡节点的左子节点 */ avl_node *left_left_rotation(avl_node *root) { avl_node *new_rt = root-\u003eleft; // 失衡节点的左子节点 // 失衡节点的新左子节点等于其旧左子节点的右子节点 root-\u003eleft = new_rt-\u003eright; // 左子节点的右子节点等于失衡节点 new_rt-\u003eright = root; // 更新高度 root-\u003eheight = std::max(height(root-\u003eleft), height(root-\u003eright)) + 1; new_rt-\u003eheight = std::max(height(new_rt-\u003eleft), height(new_rt-\u003eright)) + 1; // 返回新的根节点 return new_rt; } RR 型 6 --\u003e h(l) - h(r) = -2 / \\ 4 9 --\u003e h(l) - h(r) = -1 / \\ 8 10 \\ 11 以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 -1，这种失衡状态称为 RR 型。对于 RR 型失衡，将其失衡根节点进行一次 右旋 即可重新平衡。\n9 / \\ 6 10 / \\ \\ 4 8 11 右旋即将节点变为其右子节点的左子节点，其右子节点的左子节点变为该节点的的右子节点。\n以上图为例，节点 6 是失衡节点，将它变为它的左子节点，也就是节点 4 的右子节点，同时节点 4 的右子节点变为节点 6 的左子结点。\n/** * @brief 处理 RR 型失衡 * @param root 失衡节点 * @return 旋转后的根节点，即原失衡节点的右子节点 */ avl_node *right_right_rotation(avl_node *root) { avl_node *new_rt = root-\u003eright; // 失衡节点的右子节点 // 失衡节点的新右子节点等于其旧右子节点的左子节点 root-\u003eright = new_rt-\u003eleft; // 右子节点的左子节点等于失衡节点 new_rt-\u003eleft = root; root-\u003eheight = std::max(height(root-\u003eleft), height(root-\u003eright)) + 1; new_rt-\u003eheight = std::max(height(new_rt-\u003eleft), height(new_rt-\u003eright)) + 1; return new_rt; } LR 型 6 --\u003e h(l) - h(r) = 2 / \\ h(l) - h(r) = -1 \u003c-- 4 7 / \\ 3 5 \\ 2 以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 -1，这种失衡状态称为 LR 型。对于 LR 型失衡，需要一次右旋和一次左旋才能重新平衡。\n6 6 5 / \\ / \\ / \\ 4 7 5 7 4 6 / \\ / \\ / / \\ 3 5 4 2 3 2 7 \\ / 2 3 Original RR Rotate LL Rotate 第一次旋转是对失衡节点的左子节点右旋，旋转之后二叉树的失衡状态变为 LL 型。第二次旋转是对失衡节点的左旋，旋转后二叉树重新平衡。\n/** * @brief 处理 LR 型失衡 * @param root 失衡节点 * @return 旋转后的根节点 */ avl_node *left_right_rotation(avl_node *root) { // 对失衡节点的左节点右旋 root-\u003eleft = right_right_rotation(root-\u003eleft); // 对失衡节点左旋 return left_left_rotation(root); } RL 型 6 --\u003e h(l) - h(r) = 2 / \\ 4 9 --\u003e h(l) - h(r) = 1 / \\ 8 10 / 11 以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 1，这种失衡状态称为 RL 型。对于 RR 型失衡，需要一次左旋和一次右旋才能重新平衡。\n6 6 8 / \\ / \\ / \\ 4 9 4 8 6 9 / \\ / \\ / \\ \\ 8 10 11 9 4 11 10 / \\ 11 10 Original LL Rotate RR Rotate 第一次旋转是对失衡节点的右子节点左旋，旋转之后二叉树的失衡状态变为 RR 型。第二次旋转是对失衡节点的右旋，旋转后二叉树重新平衡。\n/** * @brief 处理 RL 型失衡 * @param root 失衡节点 * @return 旋转后的根节点 */ avl_node *right_left_rotation(avl_node *root) { // 对失衡节点的右节点左旋 root-\u003eright = left_left_rotation(root-\u003eright); // 对失衡节点右旋 return right_right_rotation(root); } 插入 AVL 树的插入操作与二叉搜索树类似，但在每次插入后都要检查当前节点是否失衡，若失衡则要进行调整。\navl_node *insert_aux(avl_node *root, const T \u0026value) { if (root == nullptr) { return new avl_node(value); } if (root-\u003ekey == value) { root-\u003ecount++; } else if (root-\u003ekey \u003e value) { root-\u003eleft = insert_aux(root-\u003eleft, value); // 检查失衡 if (height(root-\u003eleft) - height(root-\u003eright) == 2u) { // 根据插入节点的位置判断 LL 型或 LR 型 root = (root-\u003eleft-\u003ekey \u003e value) ? left_left_rotation(root) : left_right_rotation(root); } } else { root-\u003eright = insert_aux(root-\u003eright, value); // 检查失衡 if (height(root-\u003eleft) - height(root-\u003eright) == -2u) { // 根据插入节点的位置判断 RR 型或 RL 型 root = (root-\u003eright-\u003ekey \u003e value) ? right_left_rotation(root) : right_right_rotation(root); } } root-\u003eheight = std::max(height(root-\u003eleft), height(root-\u003eright)) + 1; root-\u003esize = root-\u003ecount + (root-\u003eleft ? root-\u003eleft-\u003esize : 0) + (root-\u003eright ? root-\u003eright-\u003esize : 0); return root; } 删除 AVL 树的删除操作与二叉搜索树类似，但在每次删除后都要检查当前节点是否失衡，若失衡则要进行调整。\navl_node *remove_aux(avl_node *root, const T \u0026value) { if (root == nullptr) { return root; } if (root-\u003ekey == value) { if (root-\u003ecount \u003e 1) { root-\u003ecount--; } else { if (root-\u003eleft \u0026\u0026 root-\u003eright) { avl_node *successor = min_node(root-\u003eright); root-\u003ekey = successor-\u003ekey; root-\u003ecount = successor-\u003ecount; successor-\u003ecount = 1; root-\u003eright = remove_aux(root-\u003eright, successor-\u003ekey); } else { avl_node *child = root-\u003eleft != nullptr ? root-\u003eleft : root-\u003eright; delete root; return child; } } } else { avl_node *\u0026child = root-\u003ekey \u003e value ? root-\u003eleft : root-\u003eright; child = remove_aux(child, value); } // 检查失衡 if (height(root-\u003eleft) - height(root-\u003eright) == 2u) { root = (height(root-\u003eleft-\u003eleft) - height(root-\u003eleft-\u003eright) == 1u) ? left_left_rotation(root) : left_right_rotation(root); } else if (height(root-\u003eleft) - height(root-\u003eright) == -2u) { root = (height(root-\u003eright-\u003eleft) - height(root-\u003eright-\u003eright) == 1u) ? right_left_rotation(root) : right_right_rotation(root); } root-\u003eheight = std::max(height(root-\u003eleft), height(root-\u003eright)) + 1; root-\u003esize = root-\u003ecount + (root-\u003eleft ? root-\u003eleft-\u003esize : 0) + (root-\u003eright ? root-\u003eright-\u003esize : 0); return root; } 其他操作 AVL 树的其他操作与普通的二叉搜索树相同。\n参考资料 OI Wiki pdai tech ",
  "wordCount" : "797",
  "inLanguage": "en",
  "datePublished": "2024-11-22T08:24:44+08:00",
  "dateModified": "2024-11-22T08:24:44+08:00",
  "author":{
    "@type": "Person",
    "name": "TPCAD"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tpcad.github.io/posts/algorithm_avltree/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Eulamber",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tpcad.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tpcad.github.io/" accesskey="h" title="Eulamber (Alt + H)">Eulamber</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tpcad.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tpcad.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://tpcad.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Algorithm_avltree
    </h1>
    <div class="post-meta"><span title='2024-11-22 08:24:44 +0800 +0800'>November 22, 2024</span>&nbsp;·&nbsp;TPCAD

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#节点定义">节点定义</a></li>
    <li><a href="#平衡">平衡</a>
      <ul>
        <li><a href="#ll-型">LL 型</a></li>
        <li><a href="#rr-型">RR 型</a></li>
        <li><a href="#lr-型">LR 型</a></li>
        <li><a href="#rl-型">RL 型</a></li>
      </ul>
    </li>
    <li><a href="#插入">插入</a></li>
    <li><a href="#删除">删除</a></li>
    <li><a href="#其他操作">其他操作</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>平衡二叉树是一种平衡的二叉搜索树。</p>
<ol>
<li>空树是平衡二叉树</li>
<li>左右子树的高度差的绝对值不超过 1</li>
<li>左右子树也是平衡二叉树</li>
</ol>
<p>AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 <strong>平衡因子</strong>。即</p>
<p>$$
平衡因子 = 左子树的高度 - 右子树的高度
$$</p>
<h2 id="节点定义">节点定义<a hidden class="anchor" aria-hidden="true" href="#节点定义">#</a></h2>
<p>AVL 树的节点与二叉搜索树类似，但多了一个 <code>height</code> 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">avl_tree</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">avl_node</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        T key;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> size;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> count;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> height;
</span></span><span style="display:flex;"><span>        avl_node <span style="color:#f92672">*</span>left;
</span></span><span style="display:flex;"><span>        avl_node <span style="color:#f92672">*</span>right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        avl_node(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>value)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">:</span> key(value), size(<span style="color:#ae81ff">1</span>), count(<span style="color:#ae81ff">1</span>), height(<span style="color:#ae81ff">1</span>), left(<span style="color:#66d9ef">nullptr</span>),
</span></span><span style="display:flex;"><span>              right(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#f92672">*</span>root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    avl_tree() <span style="color:#f92672">:</span> root(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    avl_tree(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>value) <span style="color:#f92672">:</span> root(<span style="color:#66d9ef">nullptr</span>) { root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> avl_node(value); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    avl_tree(std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> list) <span style="color:#f92672">:</span> root(<span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>        root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> avl_node(<span style="color:#f92672">*</span>list.begin());
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>for_each(list.begin() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, list.end(),
</span></span><span style="display:flex;"><span>                      [<span style="color:#66d9ef">this</span>](<span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;&amp;</span>x) { <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>insert(x); });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="平衡">平衡<a hidden class="anchor" aria-hidden="true" href="#平衡">#</a></h2>
<p>在插入或删除节点时可能会导致 AVL 树不平衡，即平衡因子的绝对值大于 1，此时便需要通过 <strong>旋转</strong> 操作使二叉树再次平衡。</p>
<p>失衡状态可以分为四种情况：</p>
<h3 id="ll-型">LL 型<a hidden class="anchor" aria-hidden="true" href="#ll-型">#</a></h3>
<pre tabindex="0"><code class="language-language" data-lang="language">                        6  &lt;-- h(l) - h(r) = 2
                      /   \
 h(l) - h(r) = 1 --&gt; 4     7
                    / \
                   3   5
                  /
                 2
</code></pre><p>以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 1，这种失衡状态称为 <strong>LL 型</strong>。对于 LL 型失衡，将其失衡根节点进行一次 <strong>左旋</strong> 即可重新平衡。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        4
      /   \
     3     6
    /     / \
   2     5   7
</code></pre><p>左旋即将节点变为其左子节点的右子节点，其左子节点的右子节点变为该节点的的左子节点。</p>
<p>以上图为例，节点 6 是失衡节点，将它变为它的左子节点，也就是节点 4 的右子节点，同时节点 4 的右子节点变为节点 6 的左子结点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @brief  处理 LL 型失衡
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  root  失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @return  旋转后的根节点，即原失衡节点的左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#f92672">*</span><span style="color:#a6e22e">left_left_rotation</span>(avl_node <span style="color:#f92672">*</span>root) {
</span></span><span style="display:flex;"><span>        avl_node <span style="color:#f92672">*</span>new_rt <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>left; <span style="color:#75715e">// 失衡节点的左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 失衡节点的新左子节点等于其旧左子节点的右子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> new_rt<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 左子节点的右子节点等于失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        new_rt<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height(root<span style="color:#f92672">-&gt;</span>left), height(root<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        new_rt<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>max(height(new_rt<span style="color:#f92672">-&gt;</span>left), height(new_rt<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 返回新的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> new_rt;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="rr-型">RR 型<a hidden class="anchor" aria-hidden="true" href="#rr-型">#</a></h3>
<pre tabindex="0"><code class="language-language" data-lang="language">        6 --&gt; h(l) - h(r) = -2
      /   \
     4     9 --&gt; h(l) - h(r) = -1
          / \
         8  10
              \
              11
</code></pre><p>以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 -1，这种失衡状态称为 <strong>RR 型</strong>。对于 RR 型失衡，将其失衡根节点进行一次 <strong>右旋</strong> 即可重新平衡。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        9
      /   \
     6     10
    / \     \
   4   8     11
</code></pre><p>右旋即将节点变为其右子节点的左子节点，其右子节点的左子节点变为该节点的的右子节点。</p>
<p>以上图为例，节点 6 是失衡节点，将它变为它的左子节点，也就是节点 4 的右子节点，同时节点 4 的右子节点变为节点 6 的左子结点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @brief  处理 RR 型失衡
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  root  失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @return  旋转后的根节点，即原失衡节点的右子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#f92672">*</span><span style="color:#a6e22e">right_right_rotation</span>(avl_node <span style="color:#f92672">*</span>root) {
</span></span><span style="display:flex;"><span>        avl_node <span style="color:#f92672">*</span>new_rt <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right; <span style="color:#75715e">// 失衡节点的右子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 失衡节点的新右子节点等于其旧右子节点的左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> new_rt<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 右子节点的左子节点等于失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        new_rt<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height(root<span style="color:#f92672">-&gt;</span>left), height(root<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        new_rt<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>max(height(new_rt<span style="color:#f92672">-&gt;</span>left), height(new_rt<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> new_rt;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="lr-型">LR 型<a hidden class="anchor" aria-hidden="true" href="#lr-型">#</a></h3>
<pre tabindex="0"><code class="language-language" data-lang="language">                        6 --&gt; h(l) - h(r) = 2
                      /   \
h(l) - h(r) = -1 &lt;-- 4     7
                    / \
                   3   5
                        \
                         2
</code></pre><p>以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 -1，这种失衡状态称为 <strong>LR 型</strong>。对于 LR 型失衡，需要一次右旋和一次左旋才能重新平衡。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        6                       6                   5
      /   \                   /   \               /   \
     4     7                 5     7             4     6
    / \                     / \                 /     / \
   3   5                   4   2               3     2   7
        \                 /
         2               3
    Original               RR Rotate            LL Rotate
</code></pre><p>第一次旋转是对失衡节点的左子节点右旋，旋转之后二叉树的失衡状态变为 LL 型。第二次旋转是对失衡节点的左旋，旋转后二叉树重新平衡。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @brief  处理 LR 型失衡
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  root  失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @return  旋转后的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#f92672">*</span><span style="color:#a6e22e">left_right_rotation</span>(avl_node <span style="color:#f92672">*</span>root) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 对失衡节点的左节点右旋
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> right_right_rotation(root<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 对失衡节点左旋
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> left_left_rotation(root);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="rl-型">RL 型<a hidden class="anchor" aria-hidden="true" href="#rl-型">#</a></h3>
<pre tabindex="0"><code class="language-language" data-lang="language">        6 --&gt; h(l) - h(r) = 2
      /   \
     4     9 --&gt; h(l) - h(r) = 1
          / \
         8  10
        /
       11
</code></pre><p>以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 1，这种失衡状态称为 <strong>RL 型</strong>。对于 RR 型失衡，需要一次左旋和一次右旋才能重新平衡。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        6                       6                   8
      /   \                   /   \               /   \
     4     9                 4     8             6     9
          / \                     / \           / \     \
         8  10                  11   9         4  11    10
        /                             \
       11                             10
     Original               LL Rotate            RR Rotate
</code></pre><p>第一次旋转是对失衡节点的右子节点左旋，旋转之后二叉树的失衡状态变为 RR 型。第二次旋转是对失衡节点的右旋，旋转后二叉树重新平衡。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @brief  处理 RL 型失衡
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  root  失衡节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @return  旋转后的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    avl_node <span style="color:#f92672">*</span><span style="color:#a6e22e">right_left_rotation</span>(avl_node <span style="color:#f92672">*</span>root) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 对失衡节点的右节点左旋
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> left_left_rotation(root<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 对失衡节点右旋
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> right_right_rotation(root);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="插入">插入<a hidden class="anchor" aria-hidden="true" href="#插入">#</a></h2>
<p>AVL 树的插入操作与二叉搜索树类似，但在每次插入后都要检查当前节点是否失衡，若失衡则要进行调整。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    avl_node <span style="color:#f92672">*</span><span style="color:#a6e22e">insert_aux</span>(avl_node <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> avl_node(value);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> value) {
</span></span><span style="display:flex;"><span>            root<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&gt;</span> value) {
</span></span><span style="display:flex;"><span>            root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> insert_aux(root<span style="color:#f92672">-&gt;</span>left, value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 检查失衡
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (height(root<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">-</span> height(root<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2u</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 根据插入节点的位置判断 LL 型或 LR 型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                root <span style="color:#f92672">=</span> (root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&gt;</span> value) <span style="color:#f92672">?</span> left_left_rotation(root)
</span></span><span style="display:flex;"><span>                                                 <span style="color:#f92672">:</span> left_right_rotation(root);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> insert_aux(root<span style="color:#f92672">-&gt;</span>right, value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 检查失衡
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (height(root<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">-</span> height(root<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2u</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 根据插入节点的位置判断 RR 型或 RL 型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                root <span style="color:#f92672">=</span> (root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&gt;</span> value) <span style="color:#f92672">?</span> right_left_rotation(root)
</span></span><span style="display:flex;"><span>                                                  <span style="color:#f92672">:</span> right_right_rotation(root);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height(root<span style="color:#f92672">-&gt;</span>left), height(root<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">+</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                     (root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="删除">删除<a hidden class="anchor" aria-hidden="true" href="#删除">#</a></h2>
<p>AVL 树的删除操作与二叉搜索树类似，但在每次删除后都要检查当前节点是否失衡，若失衡则要进行调整。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    avl_node <span style="color:#f92672">*</span><span style="color:#a6e22e">remove_aux</span>(avl_node <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> value) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                root<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">&amp;&amp;</span> root<span style="color:#f92672">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>                    avl_node <span style="color:#f92672">*</span>successor <span style="color:#f92672">=</span> min_node(root<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    root<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> successor<span style="color:#f92672">-&gt;</span>key;
</span></span><span style="display:flex;"><span>                    root<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> successor<span style="color:#f92672">-&gt;</span>count;
</span></span><span style="display:flex;"><span>                    successor<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> remove_aux(root<span style="color:#f92672">-&gt;</span>right, successor<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    avl_node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>left : root<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">delete</span> root;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> child;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            avl_node <span style="color:#f92672">*&amp;</span>child <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&gt;</span> value <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>left : root<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            child <span style="color:#f92672">=</span> remove_aux(child, value);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查失衡
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (height(root<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">-</span> height(root<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2u</span>) {
</span></span><span style="display:flex;"><span>            root <span style="color:#f92672">=</span> (height(root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">-</span> height(root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1u</span>)
</span></span><span style="display:flex;"><span>                       <span style="color:#f92672">?</span> left_left_rotation(root)
</span></span><span style="display:flex;"><span>                       <span style="color:#f92672">:</span> left_right_rotation(root);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (height(root<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">-</span> height(root<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2u</span>) {
</span></span><span style="display:flex;"><span>            root <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                (height(root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">-</span> height(root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1u</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">?</span> right_left_rotation(root)
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">:</span> right_right_rotation(root);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height(root<span style="color:#f92672">-&gt;</span>left), height(root<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">+</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                     (root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="其他操作">其他操作<a hidden class="anchor" aria-hidden="true" href="#其他操作">#</a></h2>
<p>AVL 树的其他操作与普通的二叉搜索树相同。</p>
<h2 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h2>
<ol>
<li><a href="https://oi-wiki.org/ds/avl/">OI Wiki</a></li>
<li><a href="https://pdai.tech/md/algorithm/alg-basic-tree-balance.html">pdai tech</a></li>
</ol>


  </div>


  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tpcad.github.io/tags/algorithm/">Algorithm</a></li>
      <li><a href="https://tpcad.github.io/tags/tree/">Tree</a></li>
      <li><a href="https://tpcad.github.io/tags/data-structure/">Data Structure</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://tpcad.github.io/">Eulamber</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
