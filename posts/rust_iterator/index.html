<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Rust Iterator | Eulamber</title>
<meta name="keywords" content="">
<meta name="description" content="Rust Iterator
可迭代对象与迭代器（Iterable and Iterator）
迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：

记录当前的迭代状态
产生可以访问下一个元素的迭代器

可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 Vec&lt;T&gt; 可以通过 iter 方法获得一个迭代器，但 Vec&lt;T&gt; 本省不是一个迭代器。
一个可迭代对象通常有三个方法，分别对应三种迭代类型。

iter()，迭代 &amp;T
iter_mut()，迭代 &amp;mut T
into_iter()，迭代 T

Iterator Trait
Rust 迭代器的核心是 Iterator trait。Iterator trait 的核心代码看起来像下面这样：
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
关联类型 Item 表明迭代器返回的对象，next 方法表明迭代器如何返回该对象。
实现 Iterator Trait 遍历 &amp;T
假设有以下结构体，现在需要为 Todos 实现 Iterator trait。
pub struct Todos {
    pub list: Vec&lt;Todo&gt;,
}

#[derive(Debug)]
pub struct Todo {
    pub message: String,
    pub done: bool,
}
实现 Iterator trait 的关键是记录当前的迭代状态。Todos 使用一个 Vec&lt;T&gt; 来进行存储，非常适合用索引来记录迭代状态。我们可以为 Todos 添加一个 index 字段来记录迭代状态。但很显然，这并不妥当。当你对 Todos 进行迭代时会修改 index 字段的值，如果想要再次进行迭代，就必须重置 index 字段，因为迭代器不会在迭代结束后重置状态。">
<meta name="author" content="TPCAD">
<link rel="canonical" href="https://tpcad.github.io/posts/rust_iterator/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tpcad.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tpcad.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tpcad.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tpcad.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tpcad.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://tpcad.github.io/posts/rust_iterator/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>

const config = {
    startOnLoad:true,
    theme: 'forest',
    themeVariables: {
        lineColor: "#fafafa"    
    },
    flowchart: {
        useMaxWidth:false,
        htmlLabels:true
        }
};
mermaid.initialize(config);


window.onload = () => {
    window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
}
</script>
<meta property="og:title" content="Rust Iterator" />
<meta property="og:description" content="Rust Iterator
可迭代对象与迭代器（Iterable and Iterator）
迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：

记录当前的迭代状态
产生可以访问下一个元素的迭代器

可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 Vec&lt;T&gt; 可以通过 iter 方法获得一个迭代器，但 Vec&lt;T&gt; 本省不是一个迭代器。
一个可迭代对象通常有三个方法，分别对应三种迭代类型。

iter()，迭代 &amp;T
iter_mut()，迭代 &amp;mut T
into_iter()，迭代 T

Iterator Trait
Rust 迭代器的核心是 Iterator trait。Iterator trait 的核心代码看起来像下面这样：
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
关联类型 Item 表明迭代器返回的对象，next 方法表明迭代器如何返回该对象。
实现 Iterator Trait 遍历 &amp;T
假设有以下结构体，现在需要为 Todos 实现 Iterator trait。
pub struct Todos {
    pub list: Vec&lt;Todo&gt;,
}

#[derive(Debug)]
pub struct Todo {
    pub message: String,
    pub done: bool,
}
实现 Iterator trait 的关键是记录当前的迭代状态。Todos 使用一个 Vec&lt;T&gt; 来进行存储，非常适合用索引来记录迭代状态。我们可以为 Todos 添加一个 index 字段来记录迭代状态。但很显然，这并不妥当。当你对 Todos 进行迭代时会修改 index 字段的值，如果想要再次进行迭代，就必须重置 index 字段，因为迭代器不会在迭代结束后重置状态。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tpcad.github.io/posts/rust_iterator/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-10T20:54:19+08:00" />
<meta property="article:modified_time" content="2024-07-10T20:54:19+08:00" /><meta property="og:site_name" content="Eulamber" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust Iterator"/>
<meta name="twitter:description" content="Rust Iterator
可迭代对象与迭代器（Iterable and Iterator）
迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：

记录当前的迭代状态
产生可以访问下一个元素的迭代器

可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 Vec&lt;T&gt; 可以通过 iter 方法获得一个迭代器，但 Vec&lt;T&gt; 本省不是一个迭代器。
一个可迭代对象通常有三个方法，分别对应三种迭代类型。

iter()，迭代 &amp;T
iter_mut()，迭代 &amp;mut T
into_iter()，迭代 T

Iterator Trait
Rust 迭代器的核心是 Iterator trait。Iterator trait 的核心代码看起来像下面这样：
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
关联类型 Item 表明迭代器返回的对象，next 方法表明迭代器如何返回该对象。
实现 Iterator Trait 遍历 &amp;T
假设有以下结构体，现在需要为 Todos 实现 Iterator trait。
pub struct Todos {
    pub list: Vec&lt;Todo&gt;,
}

#[derive(Debug)]
pub struct Todo {
    pub message: String,
    pub done: bool,
}
实现 Iterator trait 的关键是记录当前的迭代状态。Todos 使用一个 Vec&lt;T&gt; 来进行存储，非常适合用索引来记录迭代状态。我们可以为 Todos 添加一个 index 字段来记录迭代状态。但很显然，这并不妥当。当你对 Todos 进行迭代时会修改 index 字段的值，如果想要再次进行迭代，就必须重置 index 字段，因为迭代器不会在迭代结束后重置状态。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tpcad.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Rust Iterator",
      "item": "https://tpcad.github.io/posts/rust_iterator/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rust Iterator",
  "name": "Rust Iterator",
  "description": "Rust Iterator 可迭代对象与迭代器（Iterable and Iterator） 迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：\n记录当前的迭代状态 产生可以访问下一个元素的迭代器 可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 Vec\u0026lt;T\u0026gt; 可以通过 iter 方法获得一个迭代器，但 Vec\u0026lt;T\u0026gt; 本省不是一个迭代器。\n一个可迭代对象通常有三个方法，分别对应三种迭代类型。\niter()，迭代 \u0026amp;T iter_mut()，迭代 \u0026amp;mut T into_iter()，迭代 T Iterator Trait Rust 迭代器的核心是 Iterator trait。Iterator trait 的核心代码看起来像下面这样：\ntrait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; } 关联类型 Item 表明迭代器返回的对象，next 方法表明迭代器如何返回该对象。\n实现 Iterator Trait 遍历 \u0026amp;T 假设有以下结构体，现在需要为 Todos 实现 Iterator trait。\npub struct Todos { pub list: Vec\u0026lt;Todo\u0026gt;, } #[derive(Debug)] pub struct Todo { pub message: String, pub done: bool, } 实现 Iterator trait 的关键是记录当前的迭代状态。Todos 使用一个 Vec\u0026lt;T\u0026gt; 来进行存储，非常适合用索引来记录迭代状态。我们可以为 Todos 添加一个 index 字段来记录迭代状态。但很显然，这并不妥当。当你对 Todos 进行迭代时会修改 index 字段的值，如果想要再次进行迭代，就必须重置 index 字段，因为迭代器不会在迭代结束后重置状态。\n",
  "keywords": [
    
  ],
  "articleBody": "Rust Iterator 可迭代对象与迭代器（Iterable and Iterator） 迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：\n记录当前的迭代状态 产生可以访问下一个元素的迭代器 可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 Vec 可以通过 iter 方法获得一个迭代器，但 Vec 本省不是一个迭代器。\n一个可迭代对象通常有三个方法，分别对应三种迭代类型。\niter()，迭代 \u0026T iter_mut()，迭代 \u0026mut T into_iter()，迭代 T Iterator Trait Rust 迭代器的核心是 Iterator trait。Iterator trait 的核心代码看起来像下面这样：\ntrait Iterator { type Item; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; } 关联类型 Item 表明迭代器返回的对象，next 方法表明迭代器如何返回该对象。\n实现 Iterator Trait 遍历 \u0026T 假设有以下结构体，现在需要为 Todos 实现 Iterator trait。\npub struct Todos { pub list: Vec\u003cTodo\u003e, } #[derive(Debug)] pub struct Todo { pub message: String, pub done: bool, } 实现 Iterator trait 的关键是记录当前的迭代状态。Todos 使用一个 Vec 来进行存储，非常适合用索引来记录迭代状态。我们可以为 Todos 添加一个 index 字段来记录迭代状态。但很显然，这并不妥当。当你对 Todos 进行迭代时会修改 index 字段的值，如果想要再次进行迭代，就必须重置 index 字段，因为迭代器不会在迭代结束后重置状态。\n所以我们更倾向于只把 Todos 当作一个可迭代对象，并用一个新的数据结构来记录迭代状态。\n下面是一个名为 TodosIterator 的结构体，它两个字段，todos 是对 Todos 的不可变引用，index 是一个 usize，用于记录当前的迭代状态。接下来将为 TodosIterator 实现 Iterator trait。\npub struct TodosIterator\u003c'a\u003e { todos: \u0026'a Todos, index: usize, } 首先指定关联类型 Item 为 \u0026'a Todo，这表明这个迭代器用于迭代 \u0026T。\n接着实现 next 方法。通过比较当前 index 的值与 Vec 的长度判断是否迭代结束。若否，index 字段加 1，并返回当前索引对应的 Some(\u0026Todo)。\nimpl\u003c'a\u003e Iterator for TodosIterator\u003c'a\u003e { type Item = \u0026'a Todo; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { if self.index \u003c self.todos.list.len() { let result = Some(\u0026self.todos.list[self.index]); self.index += 1; result } else { None } } } 现在我们还需要为 Todos 实现一个用于产生迭代器的方法，使其成为可迭代对象。对于迭代 \u0026T 的迭代器，这个方法通常是 iter()。\nimpl Todos { pub fn iter(\u0026self) -\u003e TodosIterator { TodosIterator { todos: self, index: 0, } } } 现在可以通过 iter 方法在 for 循环中迭代 Todos 了。\nfn main() { let todos = Todos { list: vec![ Todo { message: \"Hello\".to_string(), done: false, }, Todo { message: \"Rust\".to_string(), done: false, }, Todo { message: \"World\".to_string(), done: false, }, ], }; for todo in todos.iter() { println!(\"{todo:#?}\") } } IntoIterator Trait IntoIterator trait 的核心代码看起来像下面这样。它有一个 into_iter 方法，用于产生一个拥有对象所有权的迭代器。\n关联类型 Item 与 Iterator 的 Item 相同，IntoIter 是一个实现了 Iterator trait 的类型。 方法 into_iter 会获取对象的所有权，并返回 IntoIter。\npub trait IntoIterator { type Item; type IntoIter: Iterator\u003cItem = Self::Item\u003e; fn into_iter(self) -\u003e Self::IntoIter; } Rust 在标准库中为所有实现了 Iterator trait 的类型实现了 IntoIterator。\nimpl\u003cI: Iterator\u003e IntoIterator for I 实现 IntoIterator Trait 遍历 T 因为 IntoIterator 会获取对象的所有权，所以不能继续使用 TodosIterator 来实现。我们使用一个新的结构体来实现。\npub struct TodosIntoIterator { todos: Todos, } 接着为 Todos 实现 IntoIterator。将关联类型 IntoIter 指定为 TodosIntoIterator，并在 into_iter 方法中返回一个 TodosIntoIterator。\nimpl IntoIterator for Todos { type Item = Todo; type IntoIter = TodosIntoIterator; fn into_iter(self) -\u003e Self::IntoIter { TodosIntoIterator { todos: self } } } 因为 IntoIter 是一个实现了 Iterator trait 的类型，所以我们需要为 TodosIntoIterator 实现 Iterator trait。\n因为 TodosIntoIterator 拥有所有权，所以这里在每次迭代中删除 Vec 的第一个元素，这样迭代器总是指向这个元素。同时以 Vec 为空为迭代结束条件。\nimpl Iterator for TodosIntoIterator { type Item = Todo; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { if self.todos.list.is_empty() { return None; } let result = self.todos.list.remove(0); Some(result) } } 如此一来便能在 for 循环中遍历 todos 并获得其所有权。\nfor todo in todos { println!(\"{todo:#?}\") } 实现 Iterator Trait 遍历 \u0026mut T 要实现遍历 \u0026mut T 的 Iterator trait 并不容易。\n若仿照 \u0026T 来实现 \u0026mut T，编译器会抱怨生命周期太短。\nimpl Todos { pub fn iter_mut(\u0026mut self) -\u003e TodosMutIterator { TodosMutIterator { todos: self, index: 0, } } } pub struct TodosMutIterator\u003c'a\u003e { todos: \u0026'a mut Todos, index: usize, } impl\u003c'a\u003e Iterator for TodosMutIterator\u003c'a\u003e { type Item = \u0026'a mut Todo; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { if self.index \u003c self.todos.list.len() { let result = Some(\u0026mut self.todos.list[self.index]); self.index += 1; result } else { None } } } // error: lifetime may not live long enough // --\u003e src/main.rs:87:13 // | // 81 | impl\u003c'a\u003e Iterator for TodosMutIterator\u003c'a\u003e { // | -- lifetime `'a` defined here // 82 | type Item = \u0026'a mut Todo; // 83 | fn next(\u0026mut self) -\u003e Option { // | - let's call the lifetime of this reference `'1` // ... // 87 | result // | ^^^^^^ method was supposed to return data with lifetime `'a` but it is returning da // ta with lifetime `'1` iter_mut 方法通常用于返回一个可以遍历 \u0026mut T 的迭代器。显然，迭代器只要能访问元素，并记录迭代状态就行了。因此我们可以借助 Vec 来实现 iter_mut 方法。\n创建一个类型为 Vec\u003c\u0026mut Todo\u003e 的 Vec，并获取 Todos 的 Vec 的元素的可变引用，也就是 \u0026mut Todo。最后对新的 Vec 调用方法 into_iter，返回一个可以以可变引用访问元素的迭代器。\n这样虽然不再需要额外的结构体，但每次遍历都需要创建一个新的 Vec。\nimpl Todos { pub fn iter_mut(\u0026mut self) -\u003e std::vec::IntoIter\u003c\u0026mut Todo\u003e { let mut v: Vec\u003c\u0026mut Todo\u003e = vec![]; for todo in self.list.iter_mut() { v.push(todo) } v.into_iter() } } 实现 IntoIterator Trait 遍历 \u0026T 和 \u0026mut T 只需要为对应的类型实现 IntoIterator trait，into_iter 方法就可以根据上下文返回遍历 \u0026T、\u0026mut T 或 T 的迭代器。\nimpl\u003c'a\u003e IntoIterator for \u0026'a Todos { type Item = \u0026'a Todo; type IntoIter = TodosIterator\u003c'a\u003e; fn into_iter(self) -\u003e Self::IntoIter { self.iter() } } impl\u003c'a\u003e IntoIterator for \u0026'a mut Todos { type Item = \u0026'a mut Todo; type IntoIter = std::vec::IntoIter\u003c\u0026'a mut Todo\u003e; fn into_iter(self) -\u003e Self::IntoIter { self.iter_mut() } } 解引用裸指针实现 Iterator Trait 遍历 \u0026mut T 此前编译器抱怨生命周期太短，可以通过解引用裸指针解决。\n这样做的本质是将变量的生命周期变为 'static。将一个值转化为原始指针后，它的生命周期信息会被丢弃，再次引用原始指针则会赋予静态生命周期。静态生命周期存活时间非常长，这样做会带来一些潜在的安全风险。\npub struct TodosMutIterator\u003c'a\u003e { todos: \u0026'a mut Todos, index: usize, } impl\u003c'a\u003e Iterator for TodosMutIterator\u003c'a\u003e { type Item = \u0026'a mut Todo; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { if self.index \u003c self.todos.list.len() { // 解引用裸指针 let result = unsafe { \u0026mut *(\u0026mut self.todos.list[self.index] as *mut _) }; self.index += 1; Some(result) } else { None } } } 如下代码所示，变量 a 是一个引用，它会指向 s1 或 s2 所指向的内容，而 s1 和 s2 在离开其作用域后会被清理，因为 a 拥有静态生命周期，所以它在离开作用域后仍能使用，而它所指向的内容已经被释放，这会导致访问到完全随机的数据。\nfn main() { let a; { let mut v1 = vec![2, 3]; let s1 = \u0026mut v1; let mut v2 = vec![1, 8]; let s2 = \u0026mut v2; a = test(s1, s2); } println!(\"{a:?}\") } fn test\u003c'a\u003e(s1: \u0026mut Vec\u003ci32\u003e, s2: \u0026mut Vec\u003ci32\u003e) -\u003e \u0026'a mut Vec\u003ci32\u003e { let i = 2; if i == 1 { unsafe { \u0026mut *(s1 as *mut _) } } else { unsafe { \u0026mut *(s2 as *mut _) } } } // 一种可能的结果 // [-502036575, 23992] 参考资料 Effectively Using Iterators In Rust How do I create mutable iterator over struct fields Implementing Iterator and IntoIterator in Rust Does dereferencing a raw pointer back to a reference change the lifetime of the reference? Module std::iter ",
  "wordCount" : "891",
  "inLanguage": "en",
  "datePublished": "2024-07-10T20:54:19+08:00",
  "dateModified": "2024-07-10T20:54:19+08:00",
  "author":{
    "@type": "Person",
    "name": "TPCAD"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tpcad.github.io/posts/rust_iterator/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Eulamber",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tpcad.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tpcad.github.io/" accesskey="h" title="Eulamber (Alt + H)">Eulamber</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tpcad.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tpcad.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://tpcad.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Rust Iterator
    </h1>
    <div class="post-meta"><span title='2024-07-10 20:54:19 +0800 +0800'>July 10, 2024</span>&nbsp;·&nbsp;TPCAD

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#可迭代对象与迭代器iterable-and-iterator">可迭代对象与迭代器（Iterable and Iterator）</a></li>
    <li><a href="#iterator-trait">Iterator Trait</a>
      <ul>
        <li><a href="#实现-iterator-trait-遍历-t">实现 Iterator Trait 遍历 &amp;T</a></li>
      </ul>
    </li>
    <li><a href="#intoiterator-trait">IntoIterator Trait</a>
      <ul>
        <li><a href="#实现-intoiterator-trait-遍历-t">实现 IntoIterator Trait 遍历 T</a></li>
      </ul>
    </li>
    <li><a href="#实现-iterator-trait-遍历-mut-t">实现 Iterator Trait 遍历 &amp;mut T</a></li>
    <li><a href="#实现-intoiterator-trait-遍历-t-和-mut-t">实现 IntoIterator Trait 遍历 &amp;T 和 &amp;mut T</a></li>
    <li><a href="#解引用裸指针实现-iterator-trait-遍历-mut-t">解引用裸指针实现 Iterator Trait 遍历 &amp;mut T</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="rust-iterator">Rust Iterator<a hidden class="anchor" aria-hidden="true" href="#rust-iterator">#</a></h1>
<h2 id="可迭代对象与迭代器iterable-and-iterator">可迭代对象与迭代器（Iterable and Iterator）<a hidden class="anchor" aria-hidden="true" href="#可迭代对象与迭代器iterable-and-iterator">#</a></h2>
<p>迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：</p>
<ol>
<li>记录当前的迭代状态</li>
<li>产生可以访问下一个元素的迭代器</li>
</ol>
<p>可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 <code>Vec&lt;T&gt;</code> 可以通过 <code>iter</code> 方法获得一个迭代器，但 <code>Vec&lt;T&gt;</code> 本省不是一个迭代器。</p>
<p>一个可迭代对象通常有三个方法，分别对应三种迭代类型。</p>
<ul>
<li><code>iter()</code>，迭代 <code>&amp;T</code></li>
<li><code>iter_mut()</code>，迭代 <code>&amp;mut T</code></li>
<li><code>into_iter()</code>，迭代 <code>T</code></li>
</ul>
<h2 id="iterator-trait">Iterator Trait<a hidden class="anchor" aria-hidden="true" href="#iterator-trait">#</a></h2>
<p>Rust 迭代器的核心是 <code>Iterator</code> trait。<code>Iterator</code> trait 的核心代码看起来像下面这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Iterator {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>关联类型 <code>Item</code> 表明迭代器返回的对象，<code>next</code> 方法表明迭代器如何返回该对象。</p>
<h3 id="实现-iterator-trait-遍历-t">实现 Iterator Trait 遍历 &amp;T<a hidden class="anchor" aria-hidden="true" href="#实现-iterator-trait-遍历-t">#</a></h3>
<p>假设有以下结构体，现在需要为 <code>Todos</code> 实现 <code>Iterator</code> trait。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Todos</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> list: Vec<span style="color:#f92672">&lt;</span>Todo<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Todo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> message: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> done: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实现 <code>Iterator</code> trait 的关键是记录当前的迭代状态。<code>Todos</code> 使用一个 <code>Vec&lt;T&gt;</code> 来进行存储，非常适合用索引来记录迭代状态。我们可以为 <code>Todos</code> 添加一个 <code>index</code> 字段来记录迭代状态。但很显然，这并不妥当。当你对 <code>Todos</code> 进行迭代时会修改 <code>index</code> 字段的值，如果想要再次进行迭代，就必须重置 <code>index</code> 字段，因为迭代器不会在迭代结束后重置状态。</p>
<p>所以我们更倾向于只把 <code>Todos</code> 当作一个可迭代对象，并用一个新的数据结构来记录迭代状态。</p>
<p>下面是一个名为 <code>TodosIterator</code> 的结构体，它两个字段，<code>todos</code> 是对 <code>Todos</code> 的不可变引用，<code>index</code> 是一个 <code>usize</code>，用于记录当前的迭代状态。接下来将为 <code>TodosIterator</code> 实现 <code>Iterator</code> trait。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TodosIterator</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    todos: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">Todos</span>,
</span></span><span style="display:flex;"><span>    index: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先指定关联类型 <code>Item</code> 为 <code>&amp;'a Todo</code>，这表明这个迭代器用于迭代 <code>&amp;T</code>。</p>
<p>接着实现 <code>next</code> 方法。通过比较当前 <code>index</code> 的值与 Vec 的长度判断是否迭代结束。若否，<code>index</code> 字段加 1，并返回当前索引对应的 <code>Some(&amp;Todo)</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Iterator <span style="color:#66d9ef">for</span> TodosIterator<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> Todo;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self.index <span style="color:#f92672">&lt;</span> self.todos.list.len() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> Some(<span style="color:#f92672">&amp;</span>self.todos.list[self.index]);
</span></span><span style="display:flex;"><span>            self.index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            result
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            None
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在我们还需要为 <code>Todos</code> 实现一个用于产生迭代器的方法，使其成为可迭代对象。对于迭代 <code>&amp;T</code> 的迭代器，这个方法通常是 <code>iter()</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Todos {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">iter</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">TodosIterator</span> {
</span></span><span style="display:flex;"><span>        TodosIterator {
</span></span><span style="display:flex;"><span>            todos: <span style="color:#a6e22e">self</span>,
</span></span><span style="display:flex;"><span>            index: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在可以通过 <code>iter</code> 方法在 for 循环中迭代 <code>Todos</code> 了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> todos <span style="color:#f92672">=</span> Todos {
</span></span><span style="display:flex;"><span>        list: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>            Todo {
</span></span><span style="display:flex;"><span>                message: <span style="color:#e6db74">&#34;Hello&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>                done: <span style="color:#a6e22e">false</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            Todo {
</span></span><span style="display:flex;"><span>                message: <span style="color:#e6db74">&#34;Rust&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>                done: <span style="color:#a6e22e">false</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            Todo {
</span></span><span style="display:flex;"><span>                message: <span style="color:#e6db74">&#34;World&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>                done: <span style="color:#a6e22e">false</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        ],
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> todo <span style="color:#66d9ef">in</span> todos.iter() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{todo:#?}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="intoiterator-trait">IntoIterator Trait<a hidden class="anchor" aria-hidden="true" href="#intoiterator-trait">#</a></h2>
<p><code>IntoIterator</code> trait 的核心代码看起来像下面这样。它有一个 <code>into_iter</code> 方法，用于产生一个拥有对象所有权的迭代器。</p>
<p>关联类型 <code>Item</code> 与 <code>Iterator</code> 的 <code>Item</code> 相同，<code>IntoIter</code> 是一个实现了 <code>Iterator</code> trait 的类型。 方法 <code>into_iter</code> 会获取对象的所有权，并返回 <code>IntoIter</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> IntoIterator {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IntoIter</span>: Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> Self::Item<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">into_iter</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::IntoIter;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Rust 在标准库中为所有实现了 <code>Iterator</code> trait 的类型实现了 <code>IntoIterator</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>I: Iterator<span style="color:#f92672">&gt;</span> IntoIterator <span style="color:#66d9ef">for</span> I
</span></span></code></pre></div><h3 id="实现-intoiterator-trait-遍历-t">实现 IntoIterator Trait 遍历 T<a hidden class="anchor" aria-hidden="true" href="#实现-intoiterator-trait-遍历-t">#</a></h3>
<p>因为 <code>IntoIterator</code> 会获取对象的所有权，所以不能继续使用 <code>TodosIterator</code> 来实现。我们使用一个新的结构体来实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TodosIntoIterator</span> {
</span></span><span style="display:flex;"><span>    todos: <span style="color:#a6e22e">Todos</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着为 <code>Todos</code> 实现 <code>IntoIterator</code>。将关联类型 <code>IntoIter</code> 指定为 <code>TodosIntoIterator</code>，并在 <code>into_iter</code> 方法中返回一个 <code>TodosIntoIterator</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> IntoIterator <span style="color:#66d9ef">for</span> Todos {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> Todo;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IntoIter</span> <span style="color:#f92672">=</span> TodosIntoIterator;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">into_iter</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::IntoIter {
</span></span><span style="display:flex;"><span>        TodosIntoIterator { todos: <span style="color:#a6e22e">self</span> }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为 <code>IntoIter</code> 是一个实现了 <code>Iterator</code> trait 的类型，所以我们需要为 <code>TodosIntoIterator</code> 实现 <code>Iterator</code> trait。</p>
<p>因为 <code>TodosIntoIterator</code> 拥有所有权，所以这里在每次迭代中删除 Vec 的第一个元素，这样迭代器总是指向这个元素。同时以 Vec 为空为迭代结束条件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Iterator <span style="color:#66d9ef">for</span> TodosIntoIterator {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> Todo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self.todos.list.is_empty() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> None;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> self.todos.list.remove(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        Some(result)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如此一来便能在 <code>for</code> 循环中遍历 <code>todos</code> 并获得其所有权。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> todo <span style="color:#66d9ef">in</span> todos {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{todo:#?}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="实现-iterator-trait-遍历-mut-t">实现 Iterator Trait 遍历 &amp;mut T<a hidden class="anchor" aria-hidden="true" href="#实现-iterator-trait-遍历-mut-t">#</a></h2>
<p>要实现遍历 <code>&amp;mut T</code> 的 <code>Iterator</code> trait 并不容易。</p>
<p>若仿照 <code>&amp;T</code> 来实现 <code>&amp;mut T</code>，编译器会抱怨生命周期太短。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Todos {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">iter_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#a6e22e">TodosMutIterator</span> {
</span></span><span style="display:flex;"><span>        TodosMutIterator {
</span></span><span style="display:flex;"><span>            todos: <span style="color:#a6e22e">self</span>,
</span></span><span style="display:flex;"><span>            index: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TodosMutIterator</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    todos: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">mut</span> Todos,
</span></span><span style="display:flex;"><span>    index: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Iterator <span style="color:#66d9ef">for</span> TodosMutIterator<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">mut</span> Todo;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self.index <span style="color:#f92672">&lt;</span> self.todos.list.len() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> Some(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.todos.list[self.index]);
</span></span><span style="display:flex;"><span>            self.index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            result
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            None
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// error: lifetime may not live long enough
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   --&gt; src/main.rs:87:13
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 81 | impl&lt;&#39;a&gt; Iterator for TodosMutIterator&lt;&#39;a&gt; {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    |      -- lifetime `&#39;a` defined here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 82 |     type Item = &amp;&#39;a mut Todo;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 83 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    |             - let&#39;s call the lifetime of this reference `&#39;1`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 87 |             result
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    |             ^^^^^^ method was supposed to return data with lifetime `&#39;a` but it is returning da
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ta with lifetime `&#39;1`
</span></span></span></code></pre></div><p><code>iter_mut</code> 方法通常用于返回一个可以遍历 <code>&amp;mut T</code> 的迭代器。显然，迭代器只要能访问元素，并记录迭代状态就行了。因此我们可以借助 Vec 来实现 <code>iter_mut</code> 方法。</p>
<p>创建一个类型为 <code>Vec&lt;&amp;mut Todo&gt;</code> 的 Vec，并获取 <code>Todos</code> 的 Vec 的元素的可变引用，也就是 <code>&amp;mut Todo</code>。最后对新的 Vec 调用方法 <code>into_iter</code>，返回一个可以以可变引用访问元素的迭代器。</p>
<p>这样虽然不再需要额外的结构体，但每次遍历都需要创建一个新的 Vec。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Todos {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">iter_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#a6e22e">std</span>::vec::IntoIter<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Todo<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v: Vec<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Todo<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> todo <span style="color:#66d9ef">in</span> self.list.iter_mut() {
</span></span><span style="display:flex;"><span>            v.push(todo)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        v.into_iter()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="实现-intoiterator-trait-遍历-t-和-mut-t">实现 IntoIterator Trait 遍历 &amp;T 和 &amp;mut T<a hidden class="anchor" aria-hidden="true" href="#实现-intoiterator-trait-遍历-t-和-mut-t">#</a></h2>
<p>只需要为对应的类型实现 <code>IntoIterator</code> trait，<code>into_iter</code> 方法就可以根据上下文返回遍历 <code>&amp;T</code>、<code>&amp;mut T</code> 或 <code>T</code> 的迭代器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> IntoIterator <span style="color:#66d9ef">for</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> Todos {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> Todo;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IntoIter</span> <span style="color:#f92672">=</span> TodosIterator<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">into_iter</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::IntoIter {
</span></span><span style="display:flex;"><span>        self.iter()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> IntoIterator <span style="color:#66d9ef">for</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">mut</span> Todos {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">mut</span> Todo;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IntoIter</span> <span style="color:#f92672">=</span> std::vec::IntoIter<span style="color:#f92672">&lt;&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">mut</span> Todo<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">into_iter</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::IntoIter {
</span></span><span style="display:flex;"><span>        self.iter_mut()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="解引用裸指针实现-iterator-trait-遍历-mut-t">解引用裸指针实现 Iterator Trait 遍历 &amp;mut T<a hidden class="anchor" aria-hidden="true" href="#解引用裸指针实现-iterator-trait-遍历-mut-t">#</a></h2>
<p>此前编译器抱怨生命周期太短，可以通过解引用裸指针解决。</p>
<p>这样做的本质是将变量的生命周期变为 <code>'static</code>。将一个值转化为原始指针后，它的生命周期信息会被丢弃，再次引用原始指针则会赋予静态生命周期。静态生命周期存活时间非常长，这样做会带来一些潜在的安全风险。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TodosMutIterator</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    todos: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">mut</span> Todos,
</span></span><span style="display:flex;"><span>    index: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Iterator <span style="color:#66d9ef">for</span> TodosMutIterator<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">mut</span> Todo;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self.index <span style="color:#f92672">&lt;</span> self.todos.list.len() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 解引用裸指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.todos.list[self.index] <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> _) };
</span></span><span style="display:flex;"><span>            self.index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            Some(result)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            None
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如下代码所示，变量 <code>a</code> 是一个引用，它会指向 <code>s1</code> 或 <code>s2</code> 所指向的内容，而 <code>s1</code> 和 <code>s2</code> 在离开其作用域后会被清理，因为 <code>a</code> 拥有静态生命周期，所以它在离开作用域后仍能使用，而它所指向的内容已经被释放，这会导致访问到完全随机的数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v1 <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> v1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v2 <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> v2;
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> test(s1, s2);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{a:?}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(s1: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>, s2: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#a6e22e">mut</span> Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsafe</span> { <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> <span style="color:#f92672">*</span>(s1 <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> _) }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsafe</span> { <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> <span style="color:#f92672">*</span>(s2 <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> _) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一种可能的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// [-502036575, 23992]
</span></span></span></code></pre></div><h2 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h2>
<ol>
<li><a href="https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html/">Effectively Using Iterators In Rust</a></li>
<li><a href="https://stackoverflow.com/questions/61978903/how-do-i-create-mutable-iterator-over-struct-fields">How do I create mutable iterator over struct fields</a></li>
<li><a href="https://dev.to/wrongbyte/implementing-iterator-and-intoiterator-in-rust-3nio#:~:text=IntoIterator%20is%20a%20bit%20different,be%20converted%20into%20an%20iterator.">Implementing Iterator and IntoIterator in Rust</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/1bfzs0m/does_dereferencing_a_raw_pointer_back_to_a/">Does dereferencing a raw pointer back to a reference change the lifetime of the reference?</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/index.html">Module std::iter</a></li>
</ol>


  </div>


  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://tpcad.github.io/">Eulamber</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
