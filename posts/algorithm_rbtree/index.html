<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>红黑树 | Eulamber</title>
<meta name="keywords" content="">
<meta name="description" content="红黑树是一种平衡的二叉搜索树，满足如下性质：

节点要么是 黑色，要么是 红色
根节点必须是黑色
所有叶子节点都是黑色
红色节点的子节点必须是黑色
从任一节点到叶子节点的所有简单路径都包含相同数量的黑色节点

其中叶子节点指的是为空的节点。如下图所示，null 是叶子节点，而节点 9 和节点 20 不是叶子节点（它们的子结点也是叶子节点，图中没有画出）。
        10
      /    \
     8      14
    / \    /  \
 null  9  null 20
节点定义
template &lt;typename T&gt;
    requires std::equality_comparable&lt;T&gt; &amp;&amp; std::totally_ordered&lt;T&gt;
struct rb_tree {
  private:
    enum rb_color { red, black }; // 节点颜色

    struct rb_node {
        T key;

        rb_color color; // 颜色字段

        unsigned size;
        unsigned count;
        rb_node *left;
        rb_node *right;
        rb_node *parent; // 父节点

        rb_node(const T &amp;value)
            : key(value), color(rb_color::red), size(1), count(1),
              left(nullptr), right(nullptr), parent(nullptr) {}

        void print_key() {
            std::cout &lt;&lt; key;
            if (color == rb_color::black) {
                std::cout &lt;&lt; &#34;b&#34;;
            } else {
                std::cout &lt;&lt; &#34;r&#34;;
            }
        }
    };

    rb_node *root;

  public:
    rb_tree() : root(nullptr) {}
    rb_tree(const T &amp;value) : root(nullptr) { root = new rb_node(value); }

    rb_tree(std::initializer_list&lt;T&gt; list) : root(nullptr) {
        this-&gt;insert_aux(this-&gt;root, *list.begin());
        std::for_each(list.begin() &#43; 1, list.end(),
                      [this](auto &amp;&amp;x) { this-&gt;insert(x); });
    }
}
旋转
因为增加了 parent 字段用于指向当前节点的父节点，因此旋转操作也需要更新 parent 字段。">
<meta name="author" content="TPCAD">
<link rel="canonical" href="https://tpcad.github.io/posts/algorithm_rbtree/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tpcad.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tpcad.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tpcad.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tpcad.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tpcad.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://tpcad.github.io/posts/algorithm_rbtree/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>

const config = {
    startOnLoad:true,
    theme: 'forest',
    themeVariables: {
        lineColor: "#fafafa"    
    },
    flowchart: {
        useMaxWidth:false,
        htmlLabels:true
        }
};
mermaid.initialize(config);


window.onload = () => {
    window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
}
</script>
<meta property="og:url" content="https://tpcad.github.io/posts/algorithm_rbtree/">
  <meta property="og:site_name" content="Eulamber">
  <meta property="og:title" content="红黑树">
  <meta property="og:description" content="红黑树是一种平衡的二叉搜索树，满足如下性质：
节点要么是 黑色，要么是 红色 根节点必须是黑色 所有叶子节点都是黑色 红色节点的子节点必须是黑色 从任一节点到叶子节点的所有简单路径都包含相同数量的黑色节点 其中叶子节点指的是为空的节点。如下图所示，null 是叶子节点，而节点 9 和节点 20 不是叶子节点（它们的子结点也是叶子节点，图中没有画出）。
10 / \ 8 14 / \ / \ null 9 null 20 节点定义 template &lt;typename T&gt; requires std::equality_comparable&lt;T&gt; &amp;&amp; std::totally_ordered&lt;T&gt; struct rb_tree { private: enum rb_color { red, black }; // 节点颜色 struct rb_node { T key; rb_color color; // 颜色字段 unsigned size; unsigned count; rb_node *left; rb_node *right; rb_node *parent; // 父节点 rb_node(const T &amp;value) : key(value), color(rb_color::red), size(1), count(1), left(nullptr), right(nullptr), parent(nullptr) {} void print_key() { std::cout &lt;&lt; key; if (color == rb_color::black) { std::cout &lt;&lt; &#34;b&#34;; } else { std::cout &lt;&lt; &#34;r&#34;; } } }; rb_node *root; public: rb_tree() : root(nullptr) {} rb_tree(const T &amp;value) : root(nullptr) { root = new rb_node(value); } rb_tree(std::initializer_list&lt;T&gt; list) : root(nullptr) { this-&gt;insert_aux(this-&gt;root, *list.begin()); std::for_each(list.begin() &#43; 1, list.end(), [this](auto &amp;&amp;x) { this-&gt;insert(x); }); } } 旋转 因为增加了 parent 字段用于指向当前节点的父节点，因此旋转操作也需要更新 parent 字段。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-26T10:43:39+08:00">
    <meta property="article:modified_time" content="2024-11-26T10:43:39+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="红黑树">
<meta name="twitter:description" content="红黑树是一种平衡的二叉搜索树，满足如下性质：

节点要么是 黑色，要么是 红色
根节点必须是黑色
所有叶子节点都是黑色
红色节点的子节点必须是黑色
从任一节点到叶子节点的所有简单路径都包含相同数量的黑色节点

其中叶子节点指的是为空的节点。如下图所示，null 是叶子节点，而节点 9 和节点 20 不是叶子节点（它们的子结点也是叶子节点，图中没有画出）。
        10
      /    \
     8      14
    / \    /  \
 null  9  null 20
节点定义
template &lt;typename T&gt;
    requires std::equality_comparable&lt;T&gt; &amp;&amp; std::totally_ordered&lt;T&gt;
struct rb_tree {
  private:
    enum rb_color { red, black }; // 节点颜色

    struct rb_node {
        T key;

        rb_color color; // 颜色字段

        unsigned size;
        unsigned count;
        rb_node *left;
        rb_node *right;
        rb_node *parent; // 父节点

        rb_node(const T &amp;value)
            : key(value), color(rb_color::red), size(1), count(1),
              left(nullptr), right(nullptr), parent(nullptr) {}

        void print_key() {
            std::cout &lt;&lt; key;
            if (color == rb_color::black) {
                std::cout &lt;&lt; &#34;b&#34;;
            } else {
                std::cout &lt;&lt; &#34;r&#34;;
            }
        }
    };

    rb_node *root;

  public:
    rb_tree() : root(nullptr) {}
    rb_tree(const T &amp;value) : root(nullptr) { root = new rb_node(value); }

    rb_tree(std::initializer_list&lt;T&gt; list) : root(nullptr) {
        this-&gt;insert_aux(this-&gt;root, *list.begin());
        std::for_each(list.begin() &#43; 1, list.end(),
                      [this](auto &amp;&amp;x) { this-&gt;insert(x); });
    }
}
旋转
因为增加了 parent 字段用于指向当前节点的父节点，因此旋转操作也需要更新 parent 字段。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tpcad.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "红黑树",
      "item": "https://tpcad.github.io/posts/algorithm_rbtree/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "红黑树",
  "name": "红黑树",
  "description": "红黑树是一种平衡的二叉搜索树，满足如下性质：\n节点要么是 黑色，要么是 红色 根节点必须是黑色 所有叶子节点都是黑色 红色节点的子节点必须是黑色 从任一节点到叶子节点的所有简单路径都包含相同数量的黑色节点 其中叶子节点指的是为空的节点。如下图所示，null 是叶子节点，而节点 9 和节点 20 不是叶子节点（它们的子结点也是叶子节点，图中没有画出）。\n10 / \\ 8 14 / \\ / \\ null 9 null 20 节点定义 template \u0026lt;typename T\u0026gt; requires std::equality_comparable\u0026lt;T\u0026gt; \u0026amp;\u0026amp; std::totally_ordered\u0026lt;T\u0026gt; struct rb_tree { private: enum rb_color { red, black }; // 节点颜色 struct rb_node { T key; rb_color color; // 颜色字段 unsigned size; unsigned count; rb_node *left; rb_node *right; rb_node *parent; // 父节点 rb_node(const T \u0026amp;value) : key(value), color(rb_color::red), size(1), count(1), left(nullptr), right(nullptr), parent(nullptr) {} void print_key() { std::cout \u0026lt;\u0026lt; key; if (color == rb_color::black) { std::cout \u0026lt;\u0026lt; \u0026#34;b\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;r\u0026#34;; } } }; rb_node *root; public: rb_tree() : root(nullptr) {} rb_tree(const T \u0026amp;value) : root(nullptr) { root = new rb_node(value); } rb_tree(std::initializer_list\u0026lt;T\u0026gt; list) : root(nullptr) { this-\u0026gt;insert_aux(this-\u0026gt;root, *list.begin()); std::for_each(list.begin() + 1, list.end(), [this](auto \u0026amp;\u0026amp;x) { this-\u0026gt;insert(x); }); } } 旋转 因为增加了 parent 字段用于指向当前节点的父节点，因此旋转操作也需要更新 parent 字段。\n",
  "keywords": [
    
  ],
  "articleBody": "红黑树是一种平衡的二叉搜索树，满足如下性质：\n节点要么是 黑色，要么是 红色 根节点必须是黑色 所有叶子节点都是黑色 红色节点的子节点必须是黑色 从任一节点到叶子节点的所有简单路径都包含相同数量的黑色节点 其中叶子节点指的是为空的节点。如下图所示，null 是叶子节点，而节点 9 和节点 20 不是叶子节点（它们的子结点也是叶子节点，图中没有画出）。\n10 / \\ 8 14 / \\ / \\ null 9 null 20 节点定义 template \u003ctypename T\u003e requires std::equality_comparable\u003cT\u003e \u0026\u0026 std::totally_ordered\u003cT\u003e struct rb_tree { private: enum rb_color { red, black }; // 节点颜色 struct rb_node { T key; rb_color color; // 颜色字段 unsigned size; unsigned count; rb_node *left; rb_node *right; rb_node *parent; // 父节点 rb_node(const T \u0026value) : key(value), color(rb_color::red), size(1), count(1), left(nullptr), right(nullptr), parent(nullptr) {} void print_key() { std::cout \u003c\u003c key; if (color == rb_color::black) { std::cout \u003c\u003c \"b\"; } else { std::cout \u003c\u003c \"r\"; } } }; rb_node *root; public: rb_tree() : root(nullptr) {} rb_tree(const T \u0026value) : root(nullptr) { root = new rb_node(value); } rb_tree(std::initializer_list\u003cT\u003e list) : root(nullptr) { this-\u003einsert_aux(this-\u003eroot, *list.begin()); std::for_each(list.begin() + 1, list.end(), [this](auto \u0026\u0026x) { this-\u003einsert(x); }); } } 旋转 因为增加了 parent 字段用于指向当前节点的父节点，因此旋转操作也需要更新 parent 字段。\n右旋操作：\n/** * @brief LL 型旋转 * @param root 节点 */ void left_left_rotation(rb_node *root) { rb_node *parent = root-\u003eparent; rb_node *child = root-\u003eleft; root-\u003eleft = child-\u003eright; if (child-\u003eright) { child-\u003eright-\u003eparent = root; } child-\u003eright = root; root-\u003eparent = child; if (root == this-\u003eroot) { this-\u003eroot = child; } child-\u003eparent = parent; if (parent) { if (parent-\u003eleft == root) { parent-\u003eleft = child; } else { parent-\u003eright = child; } } // 更新 size root-\u003esize = root-\u003ecount + (root-\u003eleft ? root-\u003eleft-\u003esize : 0) + (root-\u003eright ? root-\u003eright-\u003esize : 0); child-\u003esize = child-\u003ecount + (child-\u003eleft ? child-\u003eleft-\u003esize : 0) + (child-\u003eright ? child-\u003eright-\u003esize : 0); } 左旋操作：\n/** * @brief RR 型旋转 * @param root 节点 */ void right_right_rotation(rb_node *root) { rb_node *parent = root-\u003eparent; rb_node *child = root-\u003eright; root-\u003eright = child-\u003eleft; if (child-\u003eleft) { child-\u003eleft-\u003eparent = root; } child-\u003eleft = root; root-\u003eparent = child; if (root == this-\u003eroot) { this-\u003eroot = child; } child-\u003eparent = parent; if (parent) { if (parent-\u003eleft == root) { parent-\u003eleft = child; } else { parent-\u003eright = child; } } // 更新 size root-\u003esize = root-\u003ecount + (root-\u003eleft ? root-\u003eleft-\u003esize : 0) + (root-\u003eright ? root-\u003eright-\u003esize : 0); child-\u003esize = child-\u003ecount + (child-\u003eleft ? child-\u003eleft-\u003esize : 0) + (child-\u003eright ? child-\u003eright-\u003esize : 0); } 插入 红黑树的插入操作与二叉搜索树相似，重点在于插入后需要根据插入节点及相关节点的颜色对树进行调整以满足红黑树的性质。根据性质 5，如果插入的节点是黑色，那么必定会破坏性质 5，所以规定插入节点的颜色为红色。\n/** * @brief 插入节点 * @param root 根节点 * @param value 权值 */ void insert_aux(rb_node *root, const T \u0026value) { if (root == nullptr \u0026\u0026 root == this-\u003eroot) { this-\u003eroot = new rb_node(value); root = this-\u003eroot; } else { if (root-\u003ekey == value) { root-\u003ecount++; root-\u003esize++; return; } auto \u0026child = root-\u003ekey \u003e value ? root-\u003eleft : root-\u003eright; if (child == nullptr) { child = new rb_node(value, root); root-\u003esize = root-\u003ecount + (root-\u003eleft ? root-\u003eleft-\u003esize : 0) + (root-\u003eright ? root-\u003eright-\u003esize : 0); root = child; } else { insert_aux(child, value); } } fix_after_insertion(root); // 调整红黑树 root-\u003esize = root-\u003ecount + (root-\u003eleft ? root-\u003eleft-\u003esize : 0) + (root-\u003eright ? root-\u003eright-\u003esize : 0); } 插入后的情况可以分成以下 5 种：\ncase 1 插入节点是根节点，将节点染为黑色即可。\ncase 2 插入节点的父节点是黑色，不需要修改。\ncase 3 插入节点的父节点是红色，叔父节点也是红色。\n此时违反了性质 4，将父节点与叔父节点染黑，祖父节点染红即可局部满足性质 4，然后视祖父节点为插入节点，继续调整红黑树。\ncase 4 插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点与父节点都是 左子节点。\n此时违反了性质 4，先对祖父节点进行一次右旋，然后将父节点染黑，原祖父节点（现在是兄弟节点）染红。\n[G] [P] / \\ Right Rorate G / \\ repaint / \\ [U] --------------\u003e [G] -----------\u003e / \\ \\ [U] [U] N: new node, P: parent node, G: grandparent node, U: uncle node : RED node, [X]: BLACK node, {X}: either RED or BLACK node 该情况还有一种对称的变形，即插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点与父节点都是 右子节点。调整方法也类似，只需要对祖父节点 左旋 再染色即可。\ncase 5 插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点是 右子结点，父节点是 左子节点。\n此时对父节点进行一次 左旋 就变成了 case 4，将父节点视为插入节点继续调整红黑树即可。\n[G] [G] / \\ Left Rorate P / \\ [U] --------------\u003e [U] \\ / N: new node, P: parent node, G: grandparent node, U: uncle node : RED node, [X]: BLACK node, {X}: either RED or BLACK node 该情况还有一种对称的变形，即插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点是 左子结点，父节点是 右子节点。调整方法也类似，只需要对父节点 右旋 就会变成 case 4 的另一种变形。\n示例代码 /** * @brief 调整插入后红黑树 * @param root 插入节点 */ void fix_after_insertion(rb_node *root) { // case 1: 根节点 if (root == this-\u003eroot) { root-\u003ecolor = rb_color::black; return; } // case 2: 父节点是黑色 if (root-\u003eparent-\u003ecolor == rb_color::black) { return; } rb_node *uncle_node = uncle(root); // case 3: 父节点与叔父节点都是红色 if (is_red(root-\u003eparent) \u0026\u0026 is_red(uncle_node)) { root-\u003eparent-\u003ecolor = rb_color::black; uncle_node-\u003ecolor = rb_color::black; grandparent(root)-\u003ecolor = rb_color::red; fix_after_insertion(grandparent(root)); } // case 4,5: 父节点是红色，叔父节点是黑色或空 if (is_red(root-\u003eparent) \u0026\u0026 !is_red(uncle_node)) { if (is_left_child(root) \u0026\u0026 is_left_child(root-\u003eparent)) { // case 5: // 父节点是红色，叔父节点是黑色或空， // 当前节点是左子节点，父节点是左子节点 root-\u003eparent-\u003ecolor = rb_color::black; grandparent(root)-\u003ecolor = rb_color::red; left_left_rotation(grandparent(root)); } else if (!is_left_child(root) \u0026\u0026 !is_left_child(root-\u003eparent)) { // case 5: 对称 root-\u003eparent-\u003ecolor = rb_color::black; grandparent(root)-\u003ecolor = rb_color::red; right_right_rotation(grandparent(root)); } else if (!is_left_child(root) \u0026\u0026 is_left_child(root-\u003eparent)) { // case 4: // 父节点是红色，叔父节点是黑色或空， // 当前节点是右子节点，父节点是左子节点 right_right_rotation(root-\u003eparent); root = root-\u003eleft; fix_after_insertion(root); } else { // case 4: 对称 left_left_rotation(root-\u003eparent); root = root-\u003eright; fix_after_insertion(root); } return; } } 删除 对于红黑树，只有删除黑色节点才会破坏红黑树的性质。\n红黑树的删除操作可以分成以下几种：\n删除操作 case 1 待删除节点的左右子节点都存在。使用直接后继节点替换待删除节点但保留待删除节点的颜色，然后删除直接后继节点。\ncase 2 待删除节点不存在子节点且该节点为红色。直接删除即可。\ncase 3 待删除节点不存在子节点且该节点为黑色。删除后会破坏性质 5，需要进行调整。若此节点为根节点，直接删除即可。\ncase 4 待删除节点仅存在一个子节点，那么子节点一定是红色，否则会破坏性质 5。直接使用子节点替换待删除节点（包括颜色）即可。\n删除后的维护 假设待删除节点是左子节点，对于右子节点的情况，处理方法与左子节点对称。\n删除后的情况可以分为以下几种：\ncase 1 待删除节点的兄弟节点是红色，那么父节点和侄子节点（兄弟节点的子节点）一定是黑色（或为空）（性质 4），删除节点可能会破坏性质 5。\n此时需要将父节点染红，将兄弟节点染黑，并对父节点进行 左旋，此时满足 case 2。\n[P] [S] / \\ repaint / \\ Left Rorate P / \\ [N] --------------\u003e [N] [S] --------------\u003e [D] / \\ / \\ / \\ [C] [D] [C] [D] [N] [C] N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew : RED node, [X]: BLACK node, {X}: either RED or BLACK node case 2 待删除的兄弟节点和侄子节点（兄弟节点的子节点）都是黑色（或为空），父节点是红色。删除节点可能会破坏性质 5。\n此时只需要将父节点染黑，兄弟节点染红即可。\n[P] / \\ repaint / \\ [N] [S] --------------\u003e [N] / \\ / \\ [C] [D] [C] [D] N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew : RED node, [X]: BLACK node, {X}: either RED or BLACK node case 3 待删除节点的兄弟节点和侄子节点（兄弟节点的子节点）都是黑色（或为空），父节点是黑色。\n将叔父节点染红然后视父节点为待删除节点继续调整红黑树。\n[P] [P] / \\ repaint / \\ [N] [S] --------------\u003e [N] / \\ / \\ [C] [D] [C] [D] N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew : RED node, [X]: BLACK node, {X}: either RED or BLACK node case 4 待删除节点的兄弟节点是黑色，左侄子节点是红色，右侄子节点是黑色，父节点是黑色或红色。\n将兄弟节点染红，左侄子节点染黑，然后 右旋 兄弟节点，此时满足 case 5。\n{P} {P} {P} / \\ repaint / \\ Right Rorate S / \\ [N] [S] --------------\u003e [N] --------------\u003e [N] [C] / \\ / \\ \\ [D] [C] [D] N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew : RED node, [X]: BLACK node, {X}: either RED or BLACK node case 5 待删除节点的兄弟节点是黑色，左侄子节点是黑色，右侄子节点是红色，父节点是黑色或红色。\n父节点与兄弟节点交换颜色，右侄子节点染黑，左旋 父节点。\n{P} [P] {S} / \\ repaint / \\ Right Rorate S / \\ [N] [S] --------------\u003e [N] {S} --------------\u003e [P] [D] / \\ / \\ / \\ {C} {C} [D] [N] {C} N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew : RED node, [X]: BLACK node, {X}: either RED or BLACK node 示例代码 /** * @brief 调整删除后的红黑树 * @param root 待删除的节点 * * 因为还需要待删除节点来定位其父节点和兄弟节点等节点，所以此时调整的红黑 * 树其实是未删除节点的红黑树。 * * case a + case b = case 1 + case 2 * !case a + case b = case 3 * !case a + !case b + case c + case d = case 4 + case 5 * !case a + !case b + !case c + case d = case 5 */ void fix_after_remove(rb_node *root) { while (root != this-\u003eroot \u0026\u0026 root-\u003ecolor == rb_color::black) { if (is_left_child(root)) { rb_node *sib = root-\u003eparent-\u003eright; // case a if (is_red(sib)) { sib-\u003ecolor = rb_color::black; root-\u003eparent-\u003ecolor = rb_color::red; right_right_rotation(root-\u003eparent); sib = root-\u003eparent-\u003eright; } // case b if (is_black(sib-\u003eleft) \u0026\u0026 is_black(sib-\u003eright)) { sib-\u003ecolor = rb_color::red; root = root-\u003eparent; } else { // case c if (is_black(sib-\u003eright)) { sib-\u003eleft-\u003ecolor = rb_color::black; sib-\u003ecolor = rb_color::red; left_left_rotation(sib); sib = root-\u003eparent-\u003eright; } // case d sib-\u003ecolor = root-\u003eparent-\u003ecolor; root-\u003eparent-\u003ecolor = rb_color::black; sib-\u003eright-\u003ecolor = rb_color::black; right_right_rotation(root-\u003eparent); root = this-\u003eroot; } } else { rb_node *sib = root-\u003eparent-\u003eleft; // case a if (is_red(sib)) { sib-\u003ecolor = rb_color::black; root-\u003eparent-\u003ecolor = rb_color::red; left_left_rotation(root-\u003eparent); sib = root-\u003eparent-\u003eleft; } // case b if (is_black(sib-\u003eright) \u0026\u0026 is_black(sib-\u003eleft)) { sib-\u003ecolor = rb_color::red; root = root-\u003eparent; } else { // case c if (is_black(sib-\u003eleft)) { sib-\u003eright-\u003ecolor = rb_color::black; sib-\u003ecolor = rb_color::red; right_right_rotation(sib); sib = root-\u003eparent-\u003eleft; } // case d sib-\u003ecolor = root-\u003eparent-\u003ecolor; root-\u003eparent-\u003ecolor = rb_color::black; sib-\u003eleft-\u003ecolor = rb_color::black; left_left_rotation(root-\u003eparent); root = this-\u003eroot; } } } root-\u003ecolor = rb_color::black; } 参考资料 OI Wiki pdai tech pdai tech Open JDK Wikepadia ",
  "wordCount" : "1322",
  "inLanguage": "en",
  "datePublished": "2024-11-26T10:43:39+08:00",
  "dateModified": "2024-11-26T10:43:39+08:00",
  "author":{
    "@type": "Person",
    "name": "TPCAD"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tpcad.github.io/posts/algorithm_rbtree/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Eulamber",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tpcad.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tpcad.github.io/" accesskey="h" title="Eulamber (Alt + H)">Eulamber</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tpcad.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tpcad.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://tpcad.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      红黑树
    </h1>
    <div class="post-meta"><span title='2024-11-26 10:43:39 +0800 +0800'>November 26, 2024</span>&nbsp;·&nbsp;TPCAD

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#节点定义">节点定义</a></li>
    <li><a href="#旋转">旋转</a></li>
    <li><a href="#插入">插入</a>
      <ul>
        <li><a href="#case-1">case 1</a></li>
        <li><a href="#case-2">case 2</a></li>
        <li><a href="#case-3">case 3</a></li>
        <li><a href="#case-4">case 4</a></li>
        <li><a href="#case-5">case 5</a></li>
        <li><a href="#示例代码">示例代码</a></li>
      </ul>
    </li>
    <li><a href="#删除">删除</a>
      <ul>
        <li><a href="#删除操作">删除操作</a></li>
        <li><a href="#删除后的维护">删除后的维护</a></li>
        <li><a href="#示例代码-1">示例代码</a></li>
      </ul>
    </li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>红黑树是一种平衡的二叉搜索树，满足如下性质：</p>
<ol>
<li>节点要么是 <strong>黑色</strong>，要么是 <strong>红色</strong></li>
<li>根节点必须是黑色</li>
<li>所有叶子节点都是黑色</li>
<li>红色节点的子节点必须是黑色</li>
<li>从任一节点到叶子节点的所有简单路径都包含相同数量的黑色节点</li>
</ol>
<p>其中叶子节点指的是为空的节点。如下图所示，<code>null</code> 是叶子节点，而节点 9 和节点 20 不是叶子节点（它们的子结点也是叶子节点，图中没有画出）。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        10
      /    \
     8      14
    / \    /  \
 null  9  null 20
</code></pre><h2 id="节点定义">节点定义<a hidden class="anchor" aria-hidden="true" href="#节点定义">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">requires</span> std<span style="color:#f92672">::</span>equality_comparable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span> std<span style="color:#f92672">::</span>totally_ordered<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">rb_tree</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">rb_color</span> { red, black }; <span style="color:#75715e">// 节点颜色
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">rb_node</span> {
</span></span><span style="display:flex;"><span>        T key;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        rb_color color; <span style="color:#75715e">// 颜色字段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> size;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> count;
</span></span><span style="display:flex;"><span>        rb_node <span style="color:#f92672">*</span>left;
</span></span><span style="display:flex;"><span>        rb_node <span style="color:#f92672">*</span>right;
</span></span><span style="display:flex;"><span>        rb_node <span style="color:#f92672">*</span>parent; <span style="color:#75715e">// 父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        rb_node(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>value)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">:</span> key(value), color(rb_color<span style="color:#f92672">::</span>red), size(<span style="color:#ae81ff">1</span>), count(<span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>              left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>), parent(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_key</span>() {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> key;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (color <span style="color:#f92672">==</span> rb_color<span style="color:#f92672">::</span>black) {
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b&#34;</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;r&#34;</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    rb_node <span style="color:#f92672">*</span>root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    rb_tree() <span style="color:#f92672">:</span> root(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    rb_tree(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>value) <span style="color:#f92672">:</span> root(<span style="color:#66d9ef">nullptr</span>) { root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> rb_node(value); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    rb_tree(std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> list) <span style="color:#f92672">:</span> root(<span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>insert_aux(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root, <span style="color:#f92672">*</span>list.begin());
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>for_each(list.begin() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, list.end(),
</span></span><span style="display:flex;"><span>                      [<span style="color:#66d9ef">this</span>](<span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;&amp;</span>x) { <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>insert(x); });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="旋转">旋转<a hidden class="anchor" aria-hidden="true" href="#旋转">#</a></h2>
<p>因为增加了 <code>parent</code> 字段用于指向当前节点的父节点，因此旋转操作也需要更新 <code>parent</code> 字段。</p>
<p>右旋操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @brief  LL 型旋转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  root  节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">left_left_rotation</span>(rb_node <span style="color:#f92672">*</span>root) {
</span></span><span style="display:flex;"><span>        rb_node <span style="color:#f92672">*</span>parent <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent;
</span></span><span style="display:flex;"><span>        rb_node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (child<span style="color:#f92672">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>            child<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        child<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        child<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (parent) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> root) {
</span></span><span style="display:flex;"><span>                parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新 size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">+</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                     (root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        child<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">+</span> (child<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">?</span> child<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                      (child<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> child<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>左旋操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @brief  RR 型旋转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  root  节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">right_right_rotation</span>(rb_node <span style="color:#f92672">*</span>root) {
</span></span><span style="display:flex;"><span>        rb_node <span style="color:#f92672">*</span>parent <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent;
</span></span><span style="display:flex;"><span>        rb_node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (child<span style="color:#f92672">-&gt;</span>left) {
</span></span><span style="display:flex;"><span>            child<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        child<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        child<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (parent) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> root) {
</span></span><span style="display:flex;"><span>                parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新 size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">+</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                     (root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        child<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">+</span> (child<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">?</span> child<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                      (child<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> child<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="插入">插入<a hidden class="anchor" aria-hidden="true" href="#插入">#</a></h2>
<p>红黑树的插入操作与二叉搜索树相似，重点在于插入后需要根据插入节点及相关节点的颜色对树进行调整以满足红黑树的性质。根据性质 5，如果插入的节点是黑色，那么必定会破坏性质 5，所以规定插入节点的颜色为红色。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @brief  插入节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  root  根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  value  权值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert_aux</span>(rb_node <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> root <span style="color:#f92672">==</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> rb_node(value);
</span></span><span style="display:flex;"><span>            root <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> value) {
</span></span><span style="display:flex;"><span>                root<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                root<span style="color:#f92672">-&gt;</span>size<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>child <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&gt;</span> value <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>left : root<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (child <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>                child <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> rb_node(value, root);
</span></span><span style="display:flex;"><span>                root<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">+</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                             (root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>                root <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                insert_aux(child, value);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        fix_after_insertion(root); <span style="color:#75715e">// 调整红黑树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">+</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                     (root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>size : <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>插入后的情况可以分成以下 5 种：</p>
<h3 id="case-1">case 1<a hidden class="anchor" aria-hidden="true" href="#case-1">#</a></h3>
<p>插入节点是根节点，将节点染为黑色即可。</p>
<h3 id="case-2">case 2<a hidden class="anchor" aria-hidden="true" href="#case-2">#</a></h3>
<p>插入节点的父节点是黑色，不需要修改。</p>
<h3 id="case-3">case 3<a hidden class="anchor" aria-hidden="true" href="#case-3">#</a></h3>
<p>插入节点的父节点是红色，叔父节点也是红色。</p>
<p>此时违反了性质 4，将父节点与叔父节点染黑，祖父节点染红即可局部满足性质 4，然后视祖父节点为插入节点，继续调整红黑树。</p>
<h3 id="case-4">case 4<a hidden class="anchor" aria-hidden="true" href="#case-4">#</a></h3>
<p>插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点与父节点都是 <strong>左子节点</strong>。</p>
<p>此时违反了性质 4，先对祖父节点进行一次右旋，然后将父节点染黑，原祖父节点（现在是兄弟节点）染红。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        [G]                        &lt;P&gt;                       [P]
       /   \   Right Rorate G     /   \      repaint        /   \
     &lt;P&gt;  [U]  --------------&gt;  &lt;N&gt;   [G]  -----------&gt;  &lt;N&gt;   &lt;G&gt;
     /                                  \                         \
    &lt;N&gt;                                 [U]                       [U]

N: new node, P: parent node, G: grandparent node, U: uncle node
&lt;X&gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node
</code></pre><p>该情况还有一种对称的变形，即插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点与父节点都是 <strong>右子节点</strong>。调整方法也类似，只需要对祖父节点 <strong>左旋</strong> 再染色即可。</p>
<h3 id="case-5">case 5<a hidden class="anchor" aria-hidden="true" href="#case-5">#</a></h3>
<p>插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点是 <strong>右子结点</strong>，父节点是 <strong>左子节点</strong>。</p>
<p>此时对父节点进行一次 <strong>左旋</strong> 就变成了 case 4，将父节点视为插入节点继续调整红黑树即可。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        [G]                        [G]   
       /   \    Left Rorate P     /   \  
     &lt;P&gt;  [U]  --------------&gt;  &lt;N&gt;   [U]
       \                        /        
       &lt;N&gt;                    &lt;P&gt;        

N: new node, P: parent node, G: grandparent node, U: uncle node
&lt;X&gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node
</code></pre><p>该情况还有一种对称的变形，即插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点是 <strong>左子结点</strong>，父节点是 <strong>右子节点</strong>。调整方法也类似，只需要对父节点 <strong>右旋</strong> 就会变成 case  4 的另一种变形。</p>
<h3 id="示例代码">示例代码<a hidden class="anchor" aria-hidden="true" href="#示例代码">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @brief  调整插入后红黑树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  root  插入节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fix_after_insertion</span>(rb_node <span style="color:#f92672">*</span>root) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// case 1: 根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root) {
</span></span><span style="display:flex;"><span>            root<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// case 2: 父节点是黑色
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> rb_color<span style="color:#f92672">::</span>black) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        rb_node <span style="color:#f92672">*</span>uncle_node <span style="color:#f92672">=</span> uncle(root);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// case 3: 父节点与叔父节点都是红色
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (is_red(root<span style="color:#f92672">-&gt;</span>parent) <span style="color:#f92672">&amp;&amp;</span> is_red(uncle_node)) {
</span></span><span style="display:flex;"><span>            root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>            uncle_node<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>            grandparent(root)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>red;
</span></span><span style="display:flex;"><span>            fix_after_insertion(grandparent(root));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// case 4,5: 父节点是红色，叔父节点是黑色或空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (is_red(root<span style="color:#f92672">-&gt;</span>parent) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>is_red(uncle_node)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (is_left_child(root) <span style="color:#f92672">&amp;&amp;</span> is_left_child(root<span style="color:#f92672">-&gt;</span>parent)) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// case 5:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 父节点是红色，叔父节点是黑色或空，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 当前节点是左子节点，父节点是左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                grandparent(root)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>red;
</span></span><span style="display:flex;"><span>                left_left_rotation(grandparent(root));
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>is_left_child(root) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>is_left_child(root<span style="color:#f92672">-&gt;</span>parent)) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// case 5: 对称
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                grandparent(root)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>red;
</span></span><span style="display:flex;"><span>                right_right_rotation(grandparent(root));
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>is_left_child(root) <span style="color:#f92672">&amp;&amp;</span> is_left_child(root<span style="color:#f92672">-&gt;</span>parent)) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// case 4:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 父节点是红色，叔父节点是黑色或空，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 当前节点是右子节点，父节点是左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                right_right_rotation(root<span style="color:#f92672">-&gt;</span>parent);
</span></span><span style="display:flex;"><span>                root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>                fix_after_insertion(root);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// case 4: 对称
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                left_left_rotation(root<span style="color:#f92672">-&gt;</span>parent);
</span></span><span style="display:flex;"><span>                root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>                fix_after_insertion(root);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="删除">删除<a hidden class="anchor" aria-hidden="true" href="#删除">#</a></h2>
<p>对于红黑树，只有删除黑色节点才会破坏红黑树的性质。</p>
<p>红黑树的删除操作可以分成以下几种：</p>
<h3 id="删除操作">删除操作<a hidden class="anchor" aria-hidden="true" href="#删除操作">#</a></h3>
<h4 id="case-1-1">case 1<a hidden class="anchor" aria-hidden="true" href="#case-1-1">#</a></h4>
<p>待删除节点的左右子节点都存在。使用直接后继节点替换待删除节点但保留待删除节点的颜色，然后删除直接后继节点。</p>
<h4 id="case-2-1">case 2<a hidden class="anchor" aria-hidden="true" href="#case-2-1">#</a></h4>
<p>待删除节点不存在子节点且该节点为红色。直接删除即可。</p>
<h4 id="case-3-1">case 3<a hidden class="anchor" aria-hidden="true" href="#case-3-1">#</a></h4>
<p>待删除节点不存在子节点且该节点为黑色。删除后会破坏性质 5，需要进行调整。若此节点为根节点，直接删除即可。</p>
<h4 id="case-4-1">case 4<a hidden class="anchor" aria-hidden="true" href="#case-4-1">#</a></h4>
<p>待删除节点仅存在一个子节点，那么子节点一定是红色，否则会破坏性质 5。直接使用子节点替换待删除节点（包括颜色）即可。</p>
<h3 id="删除后的维护">删除后的维护<a hidden class="anchor" aria-hidden="true" href="#删除后的维护">#</a></h3>
<p>假设待删除节点是左子节点，对于右子节点的情况，处理方法与左子节点对称。</p>
<p>删除后的情况可以分为以下几种：</p>
<h4 id="case-1-2">case 1<a hidden class="anchor" aria-hidden="true" href="#case-1-2">#</a></h4>
<p>待删除节点的兄弟节点是红色，那么父节点和侄子节点（兄弟节点的子节点）一定是黑色（或为空）（性质 4），删除节点可能会破坏性质 5。</p>
<p>此时需要将父节点染红，将兄弟节点染黑，并对父节点进行 <strong>左旋</strong>，此时满足 case 2。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        [P]                         &lt;P&gt;                         [S]
       /   \       repaint         /   \     Left Rorate P     /   \
     [N]   &lt;S&gt;  --------------&gt;  [N]   [S]  --------------&gt;  &lt;P&gt;   [D]
          /   \                       /   \                 /   \
        [C]   [D]                   [C]   [D]             [N]   [C]

N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew
&lt;X&gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node
</code></pre><h4 id="case-2-2">case 2<a hidden class="anchor" aria-hidden="true" href="#case-2-2">#</a></h4>
<p>待删除的兄弟节点和侄子节点（兄弟节点的子节点）都是黑色（或为空），父节点是红色。删除节点可能会破坏性质 5。</p>
<p>此时只需要将父节点染黑，兄弟节点染红即可。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        &lt;P&gt;                        [P]      
       /   \       repaint        /   \     
     [N]  [S]  --------------&gt;  [N]   &lt;S&gt;   
         /   \                       /   \  
       [C]   [D]                   [C]   [D]

N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew
&lt;X&gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node
</code></pre><h4 id="case-3-2">case 3<a hidden class="anchor" aria-hidden="true" href="#case-3-2">#</a></h4>
<p>待删除节点的兄弟节点和侄子节点（兄弟节点的子节点）都是黑色（或为空），父节点是黑色。</p>
<p>将叔父节点染红然后视父节点为待删除节点继续调整红黑树。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        [P]                        [P]      
       /   \       repaint        /   \     
     [N]  [S]  --------------&gt;  [N]   &lt;S&gt;   
         /   \                       /   \  
       [C]   [D]                   [C]   [D]

N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew
&lt;X&gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node
</code></pre><h4 id="case-4-2">case 4<a hidden class="anchor" aria-hidden="true" href="#case-4-2">#</a></h4>
<p>待删除节点的兄弟节点是黑色，左侄子节点是红色，右侄子节点是黑色，父节点是黑色或红色。</p>
<p>将兄弟节点染红，左侄子节点染黑，然后 <strong>右旋</strong> 兄弟节点，此时满足 case 5。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        {P}                         {P}                         {P}
       /   \       repaint         /   \    Right Rorate S     /   \
     [N]   [S]  --------------&gt;  [N]   &lt;S&gt;  --------------&gt;  [N]   [C]
          /   \                       /   \                           \
        &lt;C&gt;   [D]                   [C]   [D]                         &lt;S&gt;

N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew
&lt;X&gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node
</code></pre><h4 id="case-5-1">case 5<a hidden class="anchor" aria-hidden="true" href="#case-5-1">#</a></h4>
<p>待删除节点的兄弟节点是黑色，左侄子节点是黑色，右侄子节点是红色，父节点是黑色或红色。</p>
<p>父节点与兄弟节点交换颜色，右侄子节点染黑，<strong>左旋</strong> 父节点。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">        {P}                         [P]                         {S}
       /   \       repaint         /   \    Right Rorate S     /   \
     [N]   [S]  --------------&gt;  [N]   {S}  --------------&gt;  [P]   [D]
          /   \                       /   \                 /   \      
        {C}   &lt;D&gt;                   {C}   [D]             [N]   {C}      

N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew
&lt;X&gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node
</code></pre><h3 id="示例代码-1">示例代码<a hidden class="anchor" aria-hidden="true" href="#示例代码-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @brief  调整删除后的红黑树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  @param  root  待删除的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  因为还需要待删除节点来定位其父节点和兄弟节点等节点，所以此时调整的红黑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  树其实是未删除节点的红黑树。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  case a + case b = case 1 + case 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  !case a + case b = case 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  !case a + !case b + case c + case d = case 4 + case 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  !case a + !case b + !case c + case d = case 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fix_after_remove</span>(rb_node <span style="color:#f92672">*</span>root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (root <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root <span style="color:#f92672">&amp;&amp;</span> root<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> rb_color<span style="color:#f92672">::</span>black) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (is_left_child(root)) {
</span></span><span style="display:flex;"><span>                rb_node <span style="color:#f92672">*</span>sib <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// case a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (is_red(sib)) {
</span></span><span style="display:flex;"><span>                    sib<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                    root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>red;
</span></span><span style="display:flex;"><span>                    right_right_rotation(root<span style="color:#f92672">-&gt;</span>parent);
</span></span><span style="display:flex;"><span>                    sib <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// case b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (is_black(sib<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">&amp;&amp;</span> is_black(sib<span style="color:#f92672">-&gt;</span>right)) {
</span></span><span style="display:flex;"><span>                    sib<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>red;
</span></span><span style="display:flex;"><span>                    root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// case c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (is_black(sib<span style="color:#f92672">-&gt;</span>right)) {
</span></span><span style="display:flex;"><span>                        sib<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                        sib<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>red;
</span></span><span style="display:flex;"><span>                        left_left_rotation(sib);
</span></span><span style="display:flex;"><span>                        sib <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// case d
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    sib<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color;
</span></span><span style="display:flex;"><span>                    root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                    sib<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                    right_right_rotation(root<span style="color:#f92672">-&gt;</span>parent);
</span></span><span style="display:flex;"><span>                    root <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                rb_node <span style="color:#f92672">*</span>sib <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// case a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (is_red(sib)) {
</span></span><span style="display:flex;"><span>                    sib<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                    root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>red;
</span></span><span style="display:flex;"><span>                    left_left_rotation(root<span style="color:#f92672">-&gt;</span>parent);
</span></span><span style="display:flex;"><span>                    sib <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// case b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (is_black(sib<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">&amp;&amp;</span> is_black(sib<span style="color:#f92672">-&gt;</span>left)) {
</span></span><span style="display:flex;"><span>                    sib<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>red;
</span></span><span style="display:flex;"><span>                    root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// case c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (is_black(sib<span style="color:#f92672">-&gt;</span>left)) {
</span></span><span style="display:flex;"><span>                        sib<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                        sib<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>red;
</span></span><span style="display:flex;"><span>                        right_right_rotation(sib);
</span></span><span style="display:flex;"><span>                        sib <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// case d
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    sib<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color;
</span></span><span style="display:flex;"><span>                    root<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                    sib<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>                    left_left_rotation(root<span style="color:#f92672">-&gt;</span>parent);
</span></span><span style="display:flex;"><span>                    root <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>root;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> rb_color<span style="color:#f92672">::</span>black;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h2>
<ol>
<li><a href="https://oi-wiki.org/ds/rbtree/">OI Wiki</a></li>
<li><a href="https://pdai.tech/md/algorithm/alg-basic-tree-redblack.html">pdai tech</a></li>
<li><a href="https://pdai.tech/md/java/collection/java-map-TreeMap&amp;TreeSet.html">pdai tech</a></li>
<li><a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/TreeMap.java#L2705">Open JDK</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">Wikepadia</a></li>
</ol>


  </div>


  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://tpcad.github.io/">Eulamber</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
