<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43; 初始化 | Eulamber</title>
<meta name="keywords" content="">
<meta name="description" content="变量的初始化会在构造时提供变量的初始值。
初始值可以由声明符或 new 表达式的 初始化器 部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。
初始化器（如果存在）必须是下列之一：
1. = expression
2. = {}
   = { initializer-list }
   = { designated-initializer-list }
3. ( expression-list )
   ( initializer-list )
4. {}
   { initializer-list }
   { designated-initializer-list }
默认初始化
1. T object;
2. new T;
当没有为对象指定初始化器时，该对象会默认初始化。具体有以下三种情况：

不带初始化器声明具有自动、静态或线程局部存储器的变量；
不带初始化器使用 new 表达式创建一个对象；
构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数；

默认初始化的效果是：

如果是类类型，调用默认构造函数；
如果是数组类型，数组的每个元素都被默认初始化；
否则不进行初始化；

不确定值
在获取到具有自动或动态存储期的对象的存储时，该对象具有不确定值。
如果不对对象进行任何初始化，那么该对象具有不确定值，直到该值被替换。
示例
case 1
不带初始化器声明具有自动、静态或线程局部存储器的变量。
#include &lt;print&gt;

// 静态全局非类，两次初始化
// 1) 零初始化将 si1 初始化为 0
// 2) 默认初始化不做任何事
int si1;

int main() {
    std::println(&#34;si1 静态全局非类，零初始化：{}&#34;, si1);

    static int si2;     // 静态局部非类，同全局静态非类
    std::println(&#34;si2 静态局部非类，零初始化：{}&#34;, si2);

    int i1;             // 自动局部非类，默认初始化不做任何事，不确定值
    std::println(&#34;i1 非类，不确定值：{}&#34;, i1);

    return 0;
}
case 2
不带初始化器使用 new 表达式创建一个对象。">
<meta name="author" content="TPCAD">
<link rel="canonical" href="https://tpcad.github.io/posts/cpp_initialization/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tpcad.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tpcad.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tpcad.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tpcad.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tpcad.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://tpcad.github.io/posts/cpp_initialization/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>

const config = {
    startOnLoad:true,
    theme: 'forest',
    themeVariables: {
        lineColor: "#fafafa"    
    },
    flowchart: {
        useMaxWidth:false,
        htmlLabels:true
        }
};
mermaid.initialize(config);


window.onload = () => {
    window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
}
</script>
<meta property="og:url" content="https://tpcad.github.io/posts/cpp_initialization/">
  <meta property="og:site_name" content="Eulamber">
  <meta property="og:title" content="C&#43;&#43; 初始化">
  <meta property="og:description" content="变量的初始化会在构造时提供变量的初始值。
初始值可以由声明符或 new 表达式的 初始化器 部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。
初始化器（如果存在）必须是下列之一：
1. = expression 2. = {} = { initializer-list } = { designated-initializer-list } 3. ( expression-list ) ( initializer-list ) 4. {} { initializer-list } { designated-initializer-list } 默认初始化 1. T object; 2. new T; 当没有为对象指定初始化器时，该对象会默认初始化。具体有以下三种情况：
不带初始化器声明具有自动、静态或线程局部存储器的变量； 不带初始化器使用 new 表达式创建一个对象； 构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数； 默认初始化的效果是：
如果是类类型，调用默认构造函数； 如果是数组类型，数组的每个元素都被默认初始化； 否则不进行初始化； 不确定值 在获取到具有自动或动态存储期的对象的存储时，该对象具有不确定值。
如果不对对象进行任何初始化，那么该对象具有不确定值，直到该值被替换。
示例 case 1 不带初始化器声明具有自动、静态或线程局部存储器的变量。
#include &lt;print&gt; // 静态全局非类，两次初始化 // 1) 零初始化将 si1 初始化为 0 // 2) 默认初始化不做任何事 int si1; int main() { std::println(&#34;si1 静态全局非类，零初始化：{}&#34;, si1); static int si2; // 静态局部非类，同全局静态非类 std::println(&#34;si2 静态局部非类，零初始化：{}&#34;, si2); int i1; // 自动局部非类，默认初始化不做任何事，不确定值 std::println(&#34;i1 非类，不确定值：{}&#34;, i1); return 0; } case 2 不带初始化器使用 new 表达式创建一个对象。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-08T09:54:47+08:00">
    <meta property="article:modified_time" content="2024-12-08T09:54:47+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C&#43;&#43; 初始化">
<meta name="twitter:description" content="变量的初始化会在构造时提供变量的初始值。
初始值可以由声明符或 new 表达式的 初始化器 部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。
初始化器（如果存在）必须是下列之一：
1. = expression
2. = {}
   = { initializer-list }
   = { designated-initializer-list }
3. ( expression-list )
   ( initializer-list )
4. {}
   { initializer-list }
   { designated-initializer-list }
默认初始化
1. T object;
2. new T;
当没有为对象指定初始化器时，该对象会默认初始化。具体有以下三种情况：

不带初始化器声明具有自动、静态或线程局部存储器的变量；
不带初始化器使用 new 表达式创建一个对象；
构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数；

默认初始化的效果是：

如果是类类型，调用默认构造函数；
如果是数组类型，数组的每个元素都被默认初始化；
否则不进行初始化；

不确定值
在获取到具有自动或动态存储期的对象的存储时，该对象具有不确定值。
如果不对对象进行任何初始化，那么该对象具有不确定值，直到该值被替换。
示例
case 1
不带初始化器声明具有自动、静态或线程局部存储器的变量。
#include &lt;print&gt;

// 静态全局非类，两次初始化
// 1) 零初始化将 si1 初始化为 0
// 2) 默认初始化不做任何事
int si1;

int main() {
    std::println(&#34;si1 静态全局非类，零初始化：{}&#34;, si1);

    static int si2;     // 静态局部非类，同全局静态非类
    std::println(&#34;si2 静态局部非类，零初始化：{}&#34;, si2);

    int i1;             // 自动局部非类，默认初始化不做任何事，不确定值
    std::println(&#34;i1 非类，不确定值：{}&#34;, i1);

    return 0;
}
case 2
不带初始化器使用 new 表达式创建一个对象。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tpcad.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "C++ 初始化",
      "item": "https://tpcad.github.io/posts/cpp_initialization/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++ 初始化",
  "name": "C\u002b\u002b 初始化",
  "description": "变量的初始化会在构造时提供变量的初始值。\n初始值可以由声明符或 new 表达式的 初始化器 部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。\n初始化器（如果存在）必须是下列之一：\n1. = expression 2. = {} = { initializer-list } = { designated-initializer-list } 3. ( expression-list ) ( initializer-list ) 4. {} { initializer-list } { designated-initializer-list } 默认初始化 1. T object; 2. new T; 当没有为对象指定初始化器时，该对象会默认初始化。具体有以下三种情况：\n不带初始化器声明具有自动、静态或线程局部存储器的变量； 不带初始化器使用 new 表达式创建一个对象； 构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数； 默认初始化的效果是：\n如果是类类型，调用默认构造函数； 如果是数组类型，数组的每个元素都被默认初始化； 否则不进行初始化； 不确定值 在获取到具有自动或动态存储期的对象的存储时，该对象具有不确定值。\n如果不对对象进行任何初始化，那么该对象具有不确定值，直到该值被替换。\n示例 case 1 不带初始化器声明具有自动、静态或线程局部存储器的变量。\n#include \u0026lt;print\u0026gt; // 静态全局非类，两次初始化 // 1) 零初始化将 si1 初始化为 0 // 2) 默认初始化不做任何事 int si1; int main() { std::println(\u0026#34;si1 静态全局非类，零初始化：{}\u0026#34;, si1); static int si2; // 静态局部非类，同全局静态非类 std::println(\u0026#34;si2 静态局部非类，零初始化：{}\u0026#34;, si2); int i1; // 自动局部非类，默认初始化不做任何事，不确定值 std::println(\u0026#34;i1 非类，不确定值：{}\u0026#34;, i1); return 0; } case 2 不带初始化器使用 new 表达式创建一个对象。\n",
  "keywords": [
    
  ],
  "articleBody": "变量的初始化会在构造时提供变量的初始值。\n初始值可以由声明符或 new 表达式的 初始化器 部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。\n初始化器（如果存在）必须是下列之一：\n1. = expression 2. = {} = { initializer-list } = { designated-initializer-list } 3. ( expression-list ) ( initializer-list ) 4. {} { initializer-list } { designated-initializer-list } 默认初始化 1. T object; 2. new T; 当没有为对象指定初始化器时，该对象会默认初始化。具体有以下三种情况：\n不带初始化器声明具有自动、静态或线程局部存储器的变量； 不带初始化器使用 new 表达式创建一个对象； 构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数； 默认初始化的效果是：\n如果是类类型，调用默认构造函数； 如果是数组类型，数组的每个元素都被默认初始化； 否则不进行初始化； 不确定值 在获取到具有自动或动态存储期的对象的存储时，该对象具有不确定值。\n如果不对对象进行任何初始化，那么该对象具有不确定值，直到该值被替换。\n示例 case 1 不带初始化器声明具有自动、静态或线程局部存储器的变量。\n#include // 静态全局非类，两次初始化 // 1) 零初始化将 si1 初始化为 0 // 2) 默认初始化不做任何事 int si1; int main() { std::println(\"si1 静态全局非类，零初始化：{}\", si1); static int si2; // 静态局部非类，同全局静态非类 std::println(\"si2 静态局部非类，零初始化：{}\", si2); int i1; // 自动局部非类，默认初始化不做任何事，不确定值 std::println(\"i1 非类，不确定值：{}\", i1); return 0; } case 2 不带初始化器使用 new 表达式创建一个对象。\n#include // 动态全局非类，默认初始化不做任何事，不确定值 int *pi1 = new int; int main() { int *pi2 = new int; // 动态局部非类，默认初始化不做任何事，不确定值 std::println(\"*pi1 动态全局非类，不确定值：{}\", *pi1); std::println(\"*pi2 动态局部非类，不确定值：{}\", *pi2); return 0; } 多次执行上方代码可能得到的都是相同的结果，*pi1 和 *pi2 的值都是 0。不能就此认为默认初始化是的值就是 0。如果多次销毁并分配 同一块内存 可以发现其初始化值是不确定值。\n#include int main() { int *p = new int; std::println(\"*p：{}\", *p); std::println(\"*p：{:p}\", static_cast\u003cvoid *\u003e(p)); delete p; p = new int; std::println(\"*p：{}\", *p); std::println(\"*p：{:p}\", static_cast\u003cvoid *\u003e(p)); return 0; } case 3 构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数。\n#include struct foo { int mem; }; struct bar { int mema; int memb; bar() : mema() {} }; int main() { foo f1; std::println(\"foo.mem 无成员初始化列表类，不确定值：{}\", f1.mem); bar b1; std::println(\"bar.mema 有成员初始化列表类，值初始化：{}\", b1.mema); std::println(\"bar.memb 无成员初始化列表类，不确定值：{}\", b1.memb); return 0; } 对于具有动态存储期的类类型变量，同样会出现第一次分配内存时，值被初始化为 0，但在销毁并再次分配后是不确定值的现象。\n值初始化 1. T() 2. new T() 3. Class::Class(...) : member() {...} 4. T object {}; 5. T{} 6. new T{} 7. Class::Class(...) : member{} {...} 以空初始化器进行的初始化。有以下几种情况：\n以空的 () 或 {} 组成的初始化器创建临时对象（1，5）； new 表达式以空的 () 或 {} 组成的初始化器创建动态存储期对象（2，6）； 以空的 () 或 {} 组成的成员初始化器初始化非静态数据成员或基类（3，7）； 以空的 {} 对声明 具名对象（4）； 另外，如果使用了 {} 且 T 是聚合体，那么就会进行聚合初始化。如果 T 没有默认构造函数但有接受 std::initializer_list 的构造函数，那么会进行列表初始化。\n值初始化的效果是：\n如果 T 是（可有 cv 限定）类类型： 如果 T 的默认初始化选择了一个 不由用户提供的构造函数，那么对象会首先进行零初始化； 任何情况下，对象都被默认初始化； 如果 T 是数组类型，值初始化每一个元素； 否则，进行零初始化； 注意，引用不能被值初始化。\n示例 case 1 以空的 () 或 {} 组成的初始化器创建临时对象。\n#include int main() { int i1 = int(); // 非类，空 () 创建临时对象，零初始化 int i2 = int{}; // 非类，空 {} 创建临时对象，零初始化 std::println(\"i1 非类，空 () 创建临时对象，零初始化：{}\", i1); std::println(\"i2 非类，空 {{}} 创建临时对象，零初始化：{}\", i2); return 0; } 注意，进行值初始化的其实是 int() 和 int{}，而 i1、i2 则进行 复制初始化。\ncase 2 new 表达式以空的 () 或 {} 组成的初始化器创建动态存储期对象。\n#include int main() { int *ip1 = new int(); // 非类，空 () 创建动态对象，零初始化 int *ip2 = new int{}; // 非类，空 {} 创建动态对象，零初始化 std::println(\"*ip1 非类，空 () 创建动态对象，零初始化：{}\", *ip1); std::println(\"*ip2 非类，空 {{}} 创建动态对象，零初始化：{}\", *ip2); } 注意，进行值初始化的其实是 new int() 和 new int{}，而 ip1、ip2 则进行 复制初始化。\ncase 3 以空的 () 或 {} 组成的成员初始化器初始化非静态数据成员或基类。\n#include struct foo { int mem; // 隐式构造函数，不由用户提供 // foo() = default; 同上 }; struct bar { int mema; int memb; bar() : mema() {} // 用户提供构造函数，部分成员初始化列表 }; int main() { foo f = foo(); std::println(\"foo::mem 类，隐式构造函数，零初始化：{}\", f.mem); bar b = bar{}; std::println(\"bar::mema 类，带成员初始化列表，零初始化：{}\", b.mema); std::println(\"bar::memb 类，不带成员初始化列表，默认初始化：{}\", b.memb); return 0; } case 4 以空的 {} 对声明 具名对象。\n#include struct foo() { int mem; }; int main() { int i{}; std::println(\"i 非类，零初始化：{}\", i); foo f{}; std::println(\"foo.mem 类，隐式构造函数，零初始化：{}\", f1.mem); } 注意，T object() 不初始化对象，而是声明一个无参且返回 T 的函数。\n直接初始化 1. T object(arg); T object(arg1, arg2, ...); 2. T object{arg}; 3. T(other object) T(arg1, arg2) 4. static_cast\u003cT\u003e(other object) 5. new T(args, ...) 6. Class::Class() : member(args, ...) {...} 7. [arg]() {} 以一组明确的构造函数实参对对象进行初始化。有以下几种情况：\n以表达式的非空带括号列表初始化对象； 以 {} 环绕的单个初始化器初始化一个 非类类型 对象； 以函数风格转换或以带括号的表达式列表初始化 纯右值的结果对象； 以 static_cast 表达式初始化 纯右值的结果对象； 以带有非空初始化器的 new 表达式初始化具有动态存储期的对象； 用构造函数初始化器列表初始化基类或非静态成员； 在 lambda 表达式中从按复制捕获的变量初始化闭包对象的成员； 直接初始化的效果是：\n如果 T 是数组类型，那么程序非良构； 如果 T 是类类型， 如果初始化器是纯右值表达式且类型与 T 为相同的类（忽略 cv 限定），则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）； 检验 T 的构造函数并由重载决议选取最佳匹配，然后调用该构造函数以初始化对象； 否则，如果 T 是非类类型但源类型是类类型，则检验源类型及其各基类的转换函数，并由重载决议选取最佳匹配，然后用选取的转换函数，将初始化器表达式转换为所初始化的对象。 否则，如果 T 是 bool 而原类型是 std::nullptr_t，则被初始化对象的值为 false； 否则，在必要时使用标准转换，转换 其他对象 的值为 T 的无 cv 限定版本，而所初始化的对象的初值为（可能为转换后的）该值。 触发示例 case 1 以表达式的非空带括号列表初始化对象。\n#include int main(int argc, char *argv[]) { int i(3); std::println(\"{}\", i); std::string str(3, 't'); std::println(\"{}\", str); return 0; } case 2 以 {} 环绕的单个初始化器初始化一个 非类类型 对象。\n#include int main(int argc, char *argv[]) { int i{3}; std::println(\"{}\", i); return 0; } case 3 以函数风格转换或以带括号的表达式列表初始化 纯右值的结果对象。\n#include int main(int argc, char *argv[]) { // 函数风格转换 std::println(\"{}\", int(3)); // 带括号的表达式列表 std::println(\"{}\", std::string(3, 't')); // 初始化器得到的是纯右值结果对象 // int \u0026x(int(3)); return 0; } case 4 以 static_cast 表达式初始化 纯右值的结果对象。\n#include int main(int argc, char *argv[]) { std::println(\"{}\", static_cast\u003cdouble\u003e(3)); std::println(\"{}\", static_cast\u003cstd::string\u003e(\"hello\")); // 初始化器得到的是纯右值结果对象 // int \u0026x(static_cast(3.3)); // int \u0026x(static_cast(\"hello\")); return 0; } case 5 以带有非空初始化器的 new 表达式初始化具有动态存储期的对象。\n#include int main(int argc, char *argv[]) { std::println(\"{}\", *(new int(3))); std::println(\"{}\", *(new std::string(3, 't'))); // 初始化器得到的是纯右值结果对象 // int \u0026x(new int(3)); return 0; } case 6 用构造函数初始化器列表初始化基类或非静态成员。\n#include struct foo { int mema; std::string memb; foo() : mema(42), memb(3, 't') {} }; int main(int argc, char *argv[]) { foo f; std::println(\"f.mema: {}\", f.mema); std::println(\"f.memb: {}\", f.memb); return 0; } case 7 在 lambda 表达式中从按复制捕获的变量初始化闭包对象的成员。\n#include struct foo { int mema; std::string memb; foo() : mema(42), memb(3, 't') {} }; int main(int argc, char *argv[]) { foo f; auto x = [f]() { std::println(\"f.mema: {}\", f.mema); std::println(\"f.memb: {}\", f.memb); }; x(); return 0; } 效果示例 case 1 T 是类类型，初始化器是纯右值表达式且类型与 T 为相同的类，则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）。\n#include struct foo { foo(int) { std::cout \u003c\u003c \"foo ctor\" \u003c\u003c std::endl; } foo(const foo \u0026) { std::cout \u003c\u003c \"foo copy ctor\" \u003c\u003c std::endl; } }; int main(int argc, char *argv[]) { foo f(foo(1)); return 0; } // outpus: // foo ctor 在 C++17 之前，这并不是一种语言特性，而是编译器优化，可以通过 -fno-elide-constructors 关闭，而且类必须拥有拷贝构造函数。关闭后 foo f(foo(1)) 会先调用合适的构造函数初始化一个纯右值临时量，再调用拷贝构造函数初始化 f。\nfoo ctor foo copy ctor case 2 T 是类类型，检验 T 的构造函数并由重载决议选取最佳匹配，然后调用该构造函数以初始化对象。\n#include struct foo { foo(int, double) { std::println(\"ctor 0\"); } foo(int) { std::println(\"ctor 1\"); } foo(double) { std::println(\"ctor 2\"); } }; int main(int argc, char *argv[]) { foo f0(42, 3.14); foo f1(42); foo(3.14); return 0; } case 3 如果 T 是非类类型但源类型是类类型，则检验源类型及其各基类的转换函数，并由重载决议选取最佳匹配，然后用选取的转换函数，将初始化器表达式转换为所初始化的对象。\n#include struct foo { operator int() { return 42; } }; struct bar : foo { operator int() { return 24; } }; struct meow : foo {}; int main(int argc, char *argv[]) { foo f; bar b; meow m; int i(f); std::println(\"{}\", i); int x(b); std::println(\"{}\", x); int v(m); std::println(\"{}\", v); return 0; } case 4 如果 T 是 bool 而原类型是 std::nullptr_t，则被初始化对象的值为 false。\n#include int main(int argc, char *argv[]) { int *p = nullptr; bool b(p); std::println(\"{}\", b); return 0; } case 5 在必要时使用标准转换，转换 其他对象 的值为 T 的无 cv 限定版本，而所初始化的对象的初值为（可能为转换后的）该值。\n#include struct foo { foo(int) { std::println(\"foo ctor\"); } }; struct bar { bar() { std::println(\"bar ctor\"); } operator int() { std::println(\"bar convertion\"); return 24; } }; struct meow : foo {}; int main(int argc, char *argv[]) { // 类型为 bar 的临时变量被隐式转换为 int 传给 foo 的构造函数 foo f(bar{}); return 0; } // output: // bar ctor // bar convertion // foo ctor 复制初始化 1. T object = other; 2. f(other) 3. return other; 4. throw object; catch(T object) 5. T array[N] = {other-sequence}; 从另一个对象初始化对象。有以下几种情况：\n当非引用类型 T 的具名变量（自动、静态或线程局部），声明时带有以等号后随一个表达式所构成的初始化器时； 当按值传递实参到函数时； 当从按值返回的函数中返回时； 当按值抛出或捕获异常时； 作为聚合初始化的一部分，用以初始化每个提供了初始化器的元素； 复制初始化的效果是：\n如果 T 是类类型，且初始化器是纯右值表达式，类型与 T 为相同的类（忽略 cv 限定），则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）； 如果 T 是类类型，且 其他对象 的类型是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的 非显示构造函数； 如果 T 是类类型，且 其他对象 的类型 不是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的转换函数将 其他对象 转换到 T。该转换的结果会被用于直接初始化该对象； 如果 T 不是 类类型，且 其他对象 的类型是类类型，同上； 如果 T 和 其他对象 都不是类类型，在需要时用标准转换将 其他对象 的值转换成 T 的无 cv 限定版本； 注意，explicit 构造函数不是转换构造函数，不会被复制初始化考虑。另外，如果 其他对象 是右值表达式，那么重载决议会选择 移动构造函数 并在复制初始化期间调用它。\n触发示例 case 1 当非引用类型 T 的具名变量（自动、静态或线程局部），声明时带有以等号后随一个表达式所构成的初始化器时。\n#include struct foo { foo() { std::println(\"foo ctor\"); } foo(const foo \u0026) { std::println(\"foo copy ctor\"); } }; int main(int argc, char *argv[]) { foo f1 = foo(); // 复制消除 foo f2 = f1; return 0; } case 2 当按值传递实参到函数时。\n#include struct foo { foo() { std::println(\"foo ctor\"); } foo(const foo \u0026) { std::println(\"foo copy ctor\"); } }; int main(int argc, char *argv[]) { no_ret_f(foo()); // 复制消除 foo f; // foo ctor no_ret_f(f); // foo copy ctor return 0; } case 3 当从按值返回的函数中返回时。\n#include struct foo { foo() { std::println(\"foo ctor\"); } foo(const foo \u0026) { std::println(\"foo copy ctor\"); } }; foo ret_f() { foo f; return f; } foo ret_r_f() { return foo(); } int main(int argc, char *argv[]) { ret_f(); // foo ctor ret_r_f(); // foo ctor return 0; } case 4 当按值抛出或捕获异常时。\n#include struct foo { foo() { std::println(\"foo ctor\"); } foo(const foo \u0026) { std::println(\"foo copy ctor\"); } }; int main(int argc, char *argv[]) { try { foo f; // foo ctor throw f; // foo copy ctor } catch (foo f) { // foo copy ctor } try { throw foo(); // foo ctor，复制消除 } catch (foo f) { // foo copy ctor } return 0; } case 5 作为聚合初始化的一部分，用以初始化每个提供了初始化器的元素。\n#include struct foo { foo() { std::println(\"foo ctor\"); } foo(const foo \u0026) { std::println(\"foo copy ctor\"); } }; int main(int argc, char *argv[]) { foo f; // foo ctor foo arr[5] = {f, f, f}; // foo copy ctor // foo copy ctor // foo copy ctor // foo ctor // foo ctor return 0; } 效果示例 case 1 如果 T 是类类型，且初始化器是纯右值表达式，类型与 T 为相同的类（忽略 cv 限定），则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）。\n#include struct foo { foo() { std::println(\"foo ctor\"); } foo(const foo \u0026) { std::println(\"foo copy ctor\"); } }; int main(int argc, char *argv[]) { foo f = foo(); return 0; } case 2 如果 T 是类类型，且 其他对象 的类型是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的 非显示构造函数。\n#include struct foo { foo() { std::println(\"foo ctor\"); } foo(const foo \u0026) { std::println(\"foo copy ctor\"); } explicit foo(int) {} }; struct bar : foo { bar() { std::println(\"bar ctor\"); } }; int main(int argc, char *argv[]) { foo f1; foo f2 = f1; // 其他对象的类型是 T，此处调用拷贝构造函数 foo f3 = bar(); // 其他对象的类型是 T 的派生类，bar 被隐式转换为 // foo，然后调用拷贝构造函数 foo f4 = 42; // 错误。复制初始化不考虑显式构造函数 return 0; } case 3 如果 T 是类类型，且 其他对象 的类型 不是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的转换函数将 其他对象 转换到 T。该转换的结果会被用于直接初始化该对象。\n#include struct bar { bar() { std::println(\"bar ctor\"); } }; struct foo { foo() { std::println(\"foo ctor\"); } foo(const foo \u0026) { std::println(\"foo copy ctor\"); } explicit foo(bar) { std::println(\"foo explicit conv from bar\"); } foo(int) { std::println(\"foo implicit conv from int\"); } }; int main(int argc, char *argv[]) { foo f1{bar()}; // 直接初始化，考虑所有构造函数 foo f2 = bar(); // 错误。复制初始化不考虑显式构造函数 foo f3 = 42; // 非显式构造函数 return 0; } case 4 如果 T 不是 类类型，且 其他对象 的类型是类类型，同 case 3。\n#include struct foo { foo() { std::println(\"foo ctor\"); } foo(const foo \u0026) { std::println(\"foo copy ctor\"); } operator int() { return 42; } }; int main(int argc, char *argv[]) { int i = foo(); std::println(\"{}\", i); return 0; } case 5 如果 T 和 其他对象 都不是类类型，在需要时用标准转换将 其他对象 的值转换成 T 的无 cv 限定版本。\n#include int main(int argc, char *argv[]) { int i = 3.14; std::println(\"{}\", i); return 0; } ",
  "wordCount" : "1692",
  "inLanguage": "en",
  "datePublished": "2024-12-08T09:54:47+08:00",
  "dateModified": "2024-12-08T09:54:47+08:00",
  "author":{
    "@type": "Person",
    "name": "TPCAD"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tpcad.github.io/posts/cpp_initialization/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Eulamber",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tpcad.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tpcad.github.io/" accesskey="h" title="Eulamber (Alt + H)">Eulamber</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tpcad.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://tpcad.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tpcad.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://tpcad.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      C&#43;&#43; 初始化
    </h1>
    <div class="post-meta"><span title='2024-12-08 09:54:47 +0800 +0800'>December 8, 2024</span>&nbsp;·&nbsp;TPCAD

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#默认初始化">默认初始化</a>
      <ul>
        <li><a href="#不确定值">不确定值</a></li>
        <li><a href="#示例">示例</a></li>
      </ul>
    </li>
    <li><a href="#值初始化">值初始化</a>
      <ul>
        <li><a href="#示例-1">示例</a></li>
      </ul>
    </li>
    <li><a href="#直接初始化">直接初始化</a>
      <ul>
        <li><a href="#触发示例">触发示例</a></li>
        <li><a href="#效果示例">效果示例</a></li>
      </ul>
    </li>
    <li><a href="#复制初始化">复制初始化</a>
      <ul>
        <li><a href="#触发示例-1">触发示例</a></li>
        <li><a href="#效果示例-1">效果示例</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>变量的初始化会在构造时提供变量的初始值。</p>
<p>初始值可以由声明符或 new 表达式的 <strong>初始化器</strong> 部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。</p>
<p>初始化器（如果存在）必须是下列之一：</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#ca9ee6">1.</span> = expression
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">2.</span> = {}
</span></span><span style="display:flex;"><span>   = { initializer-list }
</span></span><span style="display:flex;"><span>   = { designated-initializer-list }
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">3.</span> ( expression-list )
</span></span><span style="display:flex;"><span>   ( initializer-list )
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">4.</span> {}
</span></span><span style="display:flex;"><span>   { initializer-list }
</span></span><span style="display:flex;"><span>   { designated-initializer-list }
</span></span></code></pre></div><h2 id="默认初始化">默认初始化<a hidden class="anchor" aria-hidden="true" href="#默认初始化">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#ca9ee6">1.</span> T object;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">2.</span> new T;
</span></span></code></pre></div><p>当没有为对象指定初始化器时，该对象会默认初始化。具体有以下三种情况：</p>
<ol>
<li>不带初始化器声明具有自动、静态或线程局部存储器的变量；</li>
<li>不带初始化器使用 new 表达式创建一个对象；</li>
<li>构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数；</li>
</ol>
<p>默认初始化的效果是：</p>
<ol>
<li>如果是类类型，调用默认构造函数；</li>
<li>如果是数组类型，数组的每个元素都被默认初始化；</li>
<li>否则不进行初始化；</li>
</ol>
<h3 id="不确定值">不确定值<a hidden class="anchor" aria-hidden="true" href="#不确定值">#</a></h3>
<p>在获取到具有自动或动态存储期的对象的存储时，该对象具有不确定值。</p>
<p>如果不对对象进行任何初始化，那么该对象具有不确定值，直到该值被替换。</p>
<h3 id="示例">示例<a hidden class="anchor" aria-hidden="true" href="#示例">#</a></h3>
<h4 id="case-1">case 1<a hidden class="anchor" aria-hidden="true" href="#case-1">#</a></h4>
<p>不带初始化器声明具有自动、静态或线程局部存储器的变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 静态全局非类，两次初始化
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 1) 零初始化将 si1 初始化为 0
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 2) 默认初始化不做任何事
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span><span style="color:#e78284">int</span> si1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;si1 静态全局非类，零初始化：{}&#34;</span>, si1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">static</span> <span style="color:#e78284">int</span> si2;     <span style="color:#737994;font-style:italic">// 静态局部非类，同全局静态非类
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;si2 静态局部非类，零初始化：{}&#34;</span>, si2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> i1;             <span style="color:#737994;font-style:italic">// 自动局部非类，默认初始化不做任何事，不确定值
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;i1 非类，不确定值：{}&#34;</span>, i1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-2">case 2<a hidden class="anchor" aria-hidden="true" href="#case-2">#</a></h4>
<p>不带初始化器使用 new 表达式创建一个对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// 动态全局非类，默认初始化不做任何事，不确定值
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span><span style="color:#e78284">int</span> <span style="color:#99d1db;font-weight:bold">*</span>pi1 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> <span style="color:#e78284">int</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> <span style="color:#99d1db;font-weight:bold">*</span>pi2 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> <span style="color:#e78284">int</span>; <span style="color:#737994;font-style:italic">// 动态局部非类，默认初始化不做任何事，不确定值
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;*pi1 动态全局非类，不确定值：{}&#34;</span>, <span style="color:#99d1db;font-weight:bold">*</span>pi1);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;*pi2 动态局部非类，不确定值：{}&#34;</span>, <span style="color:#99d1db;font-weight:bold">*</span>pi2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>多次执行上方代码可能得到的都是相同的结果，<code>*pi1</code> 和 <code>*pi2</code> 的值都是 0。不能就此认为默认初始化是的值就是 0。如果多次销毁并分配 <strong>同一块内存</strong> 可以发现其初始化值是不确定值。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> <span style="color:#99d1db;font-weight:bold">*</span>p <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> <span style="color:#e78284">int</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;*p：{}&#34;</span>, <span style="color:#99d1db;font-weight:bold">*</span>p);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;*p：{:p}&#34;</span>, <span style="color:#ca9ee6">static_cast</span><span style="color:#99d1db;font-weight:bold">&lt;</span><span style="color:#e78284">void</span> <span style="color:#99d1db;font-weight:bold">*&gt;</span>(p));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">delete</span> p;
</span></span><span style="display:flex;"><span>    p <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> <span style="color:#e78284">int</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;*p：{}&#34;</span>, <span style="color:#99d1db;font-weight:bold">*</span>p);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;*p：{:p}&#34;</span>, <span style="color:#ca9ee6">static_cast</span><span style="color:#99d1db;font-weight:bold">&lt;</span><span style="color:#e78284">void</span> <span style="color:#99d1db;font-weight:bold">*&gt;</span>(p));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-3">case 3<a hidden class="anchor" aria-hidden="true" href="#case-3">#</a></h4>
<p>构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> mem;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">bar</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> mema;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> memb;
</span></span><span style="display:flex;"><span>    bar() <span style="color:#99d1db;font-weight:bold">:</span> mema() {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>() {
</span></span><span style="display:flex;"><span>    foo f1;
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo.mem 无成员初始化列表类，不确定值：{}&#34;</span>, f1.mem);
</span></span><span style="display:flex;"><span>    bar b1;
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;bar.mema 有成员初始化列表类，值初始化：{}&#34;</span>, b1.mema);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;bar.memb 无成员初始化列表类，不确定值：{}&#34;</span>, b1.memb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于具有动态存储期的类类型变量，同样会出现第一次分配内存时，值被初始化为 0，但在销毁并再次分配后是不确定值的现象。</p>
<h2 id="值初始化">值初始化<a hidden class="anchor" aria-hidden="true" href="#值初始化">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#ca9ee6">1.</span> T()
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">2.</span> new T()
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">3.</span> Class::Class(...) : member() {...}
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">4.</span> T object {};
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">5.</span> T{}
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">6.</span> new T{}
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">7.</span> Class::Class(...) : member{} {...}
</span></span></code></pre></div><p>以空初始化器进行的初始化。有以下几种情况：</p>
<ol>
<li>以空的 <code>()</code> 或 <code>{}</code> 组成的初始化器创建临时对象（1，5）；</li>
<li>new 表达式以空的 <code>()</code> 或 <code>{}</code> 组成的初始化器创建动态存储期对象（2，6）；</li>
<li>以空的 <code>()</code> 或 <code>{}</code> 组成的成员初始化器初始化非静态数据成员或基类（3，7）；</li>
<li>以空的 <code>{}</code> 对声明 <strong>具名对象</strong>（4）；</li>
</ol>
<p>另外，如果使用了 <code>{}</code> 且 T 是聚合体，那么就会进行聚合初始化。如果 T 没有默认构造函数但有接受 <code>std::initializer_list</code> 的构造函数，那么会进行列表初始化。</p>
<p>值初始化的效果是：</p>
<ol>
<li>如果 T 是（可有 cv 限定）类类型：
<ol>
<li>如果 T 的默认初始化选择了一个 <strong>不由用户提供的构造函数</strong>，那么对象会首先进行零初始化；</li>
<li>任何情况下，对象都被默认初始化；</li>
</ol>
</li>
<li>如果 T 是数组类型，值初始化每一个元素；</li>
<li>否则，进行零初始化；</li>
</ol>
<p>注意，引用不能被值初始化。</p>
<h3 id="示例-1">示例<a hidden class="anchor" aria-hidden="true" href="#示例-1">#</a></h3>
<h4 id="case-1-1">case 1<a hidden class="anchor" aria-hidden="true" href="#case-1-1">#</a></h4>
<p>以空的 <code>()</code> 或 <code>{}</code> 组成的初始化器创建临时对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> i1 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#e78284">int</span>();       <span style="color:#737994;font-style:italic">// 非类，空 () 创建临时对象，零初始化
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#e78284">int</span> i2 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#e78284">int</span>{};       <span style="color:#737994;font-style:italic">// 非类，空 {} 创建临时对象，零初始化
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;i1 非类，空 () 创建临时对象，零初始化：{}&#34;</span>, i1);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;i2 非类，空 {{}} 创建临时对象，零初始化：{}&#34;</span>, i2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意，进行值初始化的其实是 <code>int()</code> 和 <code>int{}</code>，而 <code>i1</code>、<code>i2</code> 则进行 <strong>复制初始化</strong>。</p>
<h4 id="case-2-1">case 2<a hidden class="anchor" aria-hidden="true" href="#case-2-1">#</a></h4>
<p>new 表达式以空的 <code>()</code> 或 <code>{}</code> 组成的初始化器创建动态存储期对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> <span style="color:#99d1db;font-weight:bold">*</span>ip1 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> <span style="color:#e78284">int</span>(); <span style="color:#737994;font-style:italic">// 非类，空 () 创建动态对象，零初始化
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#e78284">int</span> <span style="color:#99d1db;font-weight:bold">*</span>ip2 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">new</span> <span style="color:#e78284">int</span>{}; <span style="color:#737994;font-style:italic">// 非类，空 {} 创建动态对象，零初始化
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;*ip1 非类，空 () 创建动态对象，零初始化：{}&#34;</span>, <span style="color:#99d1db;font-weight:bold">*</span>ip1);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;*ip2 非类，空 {{}} 创建动态对象，零初始化：{}&#34;</span>, <span style="color:#99d1db;font-weight:bold">*</span>ip2);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意，进行值初始化的其实是 <code>new int()</code> 和 <code>new int{}</code>，而 <code>ip1</code>、<code>ip2</code> 则进行 <strong>复制初始化</strong>。</p>
<h4 id="case-3-1">case 3<a hidden class="anchor" aria-hidden="true" href="#case-3-1">#</a></h4>
<p>以空的 <code>()</code> 或 <code>{}</code> 组成的成员初始化器初始化非静态数据成员或基类。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> mem; <span style="color:#737994;font-style:italic">// 隐式构造函数，不由用户提供
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#737994;font-style:italic">// foo() = default; 同上
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">bar</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> mema;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> memb;
</span></span><span style="display:flex;"><span>    bar() <span style="color:#99d1db;font-weight:bold">:</span> mema() {} <span style="color:#737994;font-style:italic">// 用户提供构造函数，部分成员初始化列表
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>() {
</span></span><span style="display:flex;"><span>    foo f <span style="color:#99d1db;font-weight:bold">=</span> foo();
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo::mem 类，隐式构造函数，零初始化：{}&#34;</span>, f.mem);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    bar b <span style="color:#99d1db;font-weight:bold">=</span> bar{};
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;bar::mema 类，带成员初始化列表，零初始化：{}&#34;</span>, b.mema);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;bar::memb 类，不带成员初始化列表，默认初始化：{}&#34;</span>, b.memb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-4">case 4<a hidden class="anchor" aria-hidden="true" href="#case-4">#</a></h4>
<p>以空的 <code>{}</code> 对声明 <strong>具名对象</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#8caaee">foo</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> mem;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> i{};
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;i 非类，零初始化：{}&#34;</span>, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    foo f{};
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo.mem 类，隐式构造函数，零初始化：{}&#34;</span>, f1.mem);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意，<code>T object()</code> 不初始化对象，而是声明一个无参且返回 <code>T</code> 的函数。</p>
<h2 id="直接初始化">直接初始化<a hidden class="anchor" aria-hidden="true" href="#直接初始化">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#ca9ee6">1.</span> T object(arg);
</span></span><span style="display:flex;"><span>   T object(arg1, arg2, ...);
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">2.</span> T object{arg};
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">3.</span> T(other object)
</span></span><span style="display:flex;"><span>   T(arg1, arg2)
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">4.</span> static_cast&lt;<span style="color:#ca9ee6">T</span>&gt;(other object)
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">5.</span> new T(args, ...)
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">6.</span> Class::Class() : member(args, ...) {...}
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">7.</span> [arg]() {}
</span></span></code></pre></div><p>以一组明确的构造函数实参对对象进行初始化。有以下几种情况：</p>
<ol>
<li>以表达式的非空带括号列表初始化对象；</li>
<li>以 <code>{}</code> 环绕的单个初始化器初始化一个 <strong>非类类型</strong> 对象；</li>
<li>以函数风格转换或以带括号的表达式列表初始化 <strong>纯右值的结果对象</strong>；</li>
<li>以 <code>static_cast</code> 表达式初始化 <strong>纯右值的结果对象</strong>；</li>
<li>以带有非空初始化器的 new 表达式初始化具有动态存储期的对象；</li>
<li>用构造函数初始化器列表初始化基类或非静态成员；</li>
<li>在 lambda 表达式中从按复制捕获的变量初始化闭包对象的成员；</li>
</ol>
<p>直接初始化的效果是：</p>
<ol>
<li>如果 T 是数组类型，那么程序非良构；</li>
<li>如果 T 是类类型，
<ol>
<li>如果初始化器是纯右值表达式且类型与 T 为相同的类（忽略 cv 限定），则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）；</li>
<li>检验 T 的构造函数并由重载决议选取最佳匹配，然后调用该构造函数以初始化对象；</li>
</ol>
</li>
<li>否则，如果 T 是非类类型但源类型是类类型，则检验源类型及其各基类的转换函数，并由重载决议选取最佳匹配，然后用选取的转换函数，将初始化器表达式转换为所初始化的对象。</li>
<li>否则，如果 T 是 <code>bool</code> 而原类型是 <code>std::nullptr_t</code>，则被初始化对象的值为 <code>false</code>；</li>
<li>否则，在必要时使用标准转换，转换 <em>其他对象</em> 的值为 T 的无 cv 限定版本，而所初始化的对象的初值为（可能为转换后的）该值。</li>
</ol>
<h3 id="触发示例">触发示例<a hidden class="anchor" aria-hidden="true" href="#触发示例">#</a></h3>
<h4 id="case-1-2">case 1<a hidden class="anchor" aria-hidden="true" href="#case-1-2">#</a></h4>
<p>以表达式的非空带括号列表初始化对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> i(<span style="color:#ef9f76">3</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>string str(<span style="color:#ef9f76">3</span>, <span style="color:#a6d189">&#39;t&#39;</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, str);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-2-2">case 2<a hidden class="anchor" aria-hidden="true" href="#case-2-2">#</a></h4>
<p>以 <code>{}</code> 环绕的单个初始化器初始化一个 <strong>非类类型</strong> 对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> i{<span style="color:#ef9f76">3</span>};
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-3-2">case 3<a hidden class="anchor" aria-hidden="true" href="#case-3-2">#</a></h4>
<p>以函数风格转换或以带括号的表达式列表初始化 <strong>纯右值的结果对象</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 函数风格转换
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, <span style="color:#e78284">int</span>(<span style="color:#ef9f76">3</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 带括号的表达式列表
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, std<span style="color:#99d1db;font-weight:bold">::</span>string(<span style="color:#ef9f76">3</span>, <span style="color:#a6d189">&#39;t&#39;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 初始化器得到的是纯右值结果对象
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#737994;font-style:italic">// int &amp;x(int(3));
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-4-1">case 4<a hidden class="anchor" aria-hidden="true" href="#case-4-1">#</a></h4>
<p>以 <code>static_cast</code> 表达式初始化 <strong>纯右值的结果对象</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, <span style="color:#ca9ee6">static_cast</span><span style="color:#99d1db;font-weight:bold">&lt;</span><span style="color:#e78284">double</span><span style="color:#99d1db;font-weight:bold">&gt;</span>(<span style="color:#ef9f76">3</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, <span style="color:#ca9ee6">static_cast</span><span style="color:#99d1db;font-weight:bold">&lt;</span>std<span style="color:#99d1db;font-weight:bold">::</span>string<span style="color:#99d1db;font-weight:bold">&gt;</span>(<span style="color:#a6d189">&#34;hello&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 初始化器得到的是纯右值结果对象
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#737994;font-style:italic">// int &amp;x(static_cast&lt;int&gt;(3.3));
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#737994;font-style:italic">// int &amp;x(static_cast&lt;std::string&gt;(&#34;hello&#34;));
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-5">case 5<a hidden class="anchor" aria-hidden="true" href="#case-5">#</a></h4>
<p>以带有非空初始化器的 new 表达式初始化具有动态存储期的对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, <span style="color:#99d1db;font-weight:bold">*</span>(<span style="color:#ca9ee6">new</span> <span style="color:#e78284">int</span>(<span style="color:#ef9f76">3</span>)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, <span style="color:#99d1db;font-weight:bold">*</span>(<span style="color:#ca9ee6">new</span> std<span style="color:#99d1db;font-weight:bold">::</span>string(<span style="color:#ef9f76">3</span>, <span style="color:#a6d189">&#39;t&#39;</span>)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 初始化器得到的是纯右值结果对象
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#737994;font-style:italic">// int &amp;x(new int(3));
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-6">case 6<a hidden class="anchor" aria-hidden="true" href="#case-6">#</a></h4>
<p>用构造函数初始化器列表初始化基类或非静态成员。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> mema;
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>string memb;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    foo() <span style="color:#99d1db;font-weight:bold">:</span> mema(<span style="color:#ef9f76">42</span>), memb(<span style="color:#ef9f76">3</span>, <span style="color:#a6d189">&#39;t&#39;</span>) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    foo f;
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;f.mema: {}&#34;</span>, f.mema);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;f.memb: {}&#34;</span>, f.memb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-7">case 7<a hidden class="anchor" aria-hidden="true" href="#case-7">#</a></h4>
<p>在 lambda 表达式中从按复制捕获的变量初始化闭包对象的成员。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> mema;
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>string memb;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    foo() <span style="color:#99d1db;font-weight:bold">:</span> mema(<span style="color:#ef9f76">42</span>), memb(<span style="color:#ef9f76">3</span>, <span style="color:#a6d189">&#39;t&#39;</span>) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    foo f;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">auto</span> x <span style="color:#99d1db;font-weight:bold">=</span> [f]() {
</span></span><span style="display:flex;"><span>        std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;f.mema: {}&#34;</span>, f.mema);
</span></span><span style="display:flex;"><span>        std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;f.memb: {}&#34;</span>, f.memb);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    x();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="效果示例">效果示例<a hidden class="anchor" aria-hidden="true" href="#效果示例">#</a></h3>
<h4 id="case-1-3">case 1<a hidden class="anchor" aria-hidden="true" href="#case-1-3">#</a></h4>
<p>T 是类类型，初始化器是纯右值表达式且类型与 T 为相同的类，则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;iostream&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo(<span style="color:#e78284">int</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>cout <span style="color:#99d1db;font-weight:bold">&lt;&lt;</span> <span style="color:#a6d189">&#34;foo ctor&#34;</span> <span style="color:#99d1db;font-weight:bold">&lt;&lt;</span> std<span style="color:#99d1db;font-weight:bold">::</span>endl; }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>cout <span style="color:#99d1db;font-weight:bold">&lt;&lt;</span> <span style="color:#a6d189">&#34;foo copy ctor&#34;</span> <span style="color:#99d1db;font-weight:bold">&lt;&lt;</span> std<span style="color:#99d1db;font-weight:bold">::</span>endl; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    foo f(foo(<span style="color:#ef9f76">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// outpus:
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// foo ctor
</span></span></span></code></pre></div><p>在 C++17 之前，这并不是一种语言特性，而是编译器优化，可以通过 <code>-fno-elide-constructors</code> 关闭，而且类必须拥有拷贝构造函数。关闭后 <code>foo f(foo(1))</code> 会先调用合适的构造函数初始化一个纯右值临时量，再调用拷贝构造函数初始化 <code>f</code>。</p>
<pre tabindex="0"><code class="language-language" data-lang="language">foo ctor
foo copy ctor
</code></pre><h4 id="case-2-3">case 2<a hidden class="anchor" aria-hidden="true" href="#case-2-3">#</a></h4>
<p>T 是类类型，检验 T 的构造函数并由重载决议选取最佳匹配，然后调用该构造函数以初始化对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo(<span style="color:#e78284">int</span>, <span style="color:#e78284">double</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;ctor 0&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#e78284">int</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;ctor 1&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#e78284">double</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;ctor 2&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    foo f0(<span style="color:#ef9f76">42</span>, <span style="color:#ef9f76">3.14</span>);
</span></span><span style="display:flex;"><span>    foo f1(<span style="color:#ef9f76">42</span>);
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ef9f76">3.14</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-3-3">case 3<a hidden class="anchor" aria-hidden="true" href="#case-3-3">#</a></h4>
<p>如果 T 是非类类型但源类型是类类型，则检验源类型及其各基类的转换函数，并由重载决议选取最佳匹配，然后用选取的转换函数，将初始化器表达式转换为所初始化的对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">operator</span> <span style="color:#8caaee">int</span>() { <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">42</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">bar</span> <span style="color:#99d1db;font-weight:bold">:</span> foo {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">operator</span> <span style="color:#8caaee">int</span>() { <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">24</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">meow</span> <span style="color:#99d1db;font-weight:bold">:</span> foo {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    foo f;
</span></span><span style="display:flex;"><span>    bar b;
</span></span><span style="display:flex;"><span>    meow m;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> i(f);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> x(b);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, x);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> v(m);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, v);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-4-2">case 4<a hidden class="anchor" aria-hidden="true" href="#case-4-2">#</a></h4>
<p>如果 T 是 <code>bool</code> 而原类型是 <code>std::nullptr_t</code>，则被初始化对象的值为 <code>false</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> <span style="color:#99d1db;font-weight:bold">*</span>p <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ca9ee6">nullptr</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">bool</span> b(p);
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, b);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-5-1">case 5<a hidden class="anchor" aria-hidden="true" href="#case-5-1">#</a></h4>
<p>在必要时使用标准转换，转换 <em>其他对象</em> 的值为 T 的无 cv 限定版本，而所初始化的对象的初值为（可能为转换后的）该值。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo(<span style="color:#e78284">int</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">bar</span> {
</span></span><span style="display:flex;"><span>    bar() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;bar ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">operator</span> <span style="color:#8caaee">int</span>() {
</span></span><span style="display:flex;"><span>        std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;bar convertion&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">24</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">meow</span> <span style="color:#99d1db;font-weight:bold">:</span> foo {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// 类型为 bar 的临时变量被隐式转换为 int 传给 foo 的构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    foo f(bar{});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// output:
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// bar ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// bar convertion
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic">// foo ctor
</span></span></span></code></pre></div><h2 id="复制初始化">复制初始化<a hidden class="anchor" aria-hidden="true" href="#复制初始化">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#ca9ee6">1.</span> T object = other;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">2.</span> f(other)
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">3.</span> return other;
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">4.</span> throw object;
</span></span><span style="display:flex;"><span>   catch(T object)
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">5.</span> T array[N] = {other-sequence};
</span></span></code></pre></div><p>从另一个对象初始化对象。有以下几种情况：</p>
<ol>
<li>当非引用类型 T 的具名变量（自动、静态或线程局部），声明时带有以等号后随一个表达式所构成的初始化器时；</li>
<li>当按值传递实参到函数时；</li>
<li>当从按值返回的函数中返回时；</li>
<li>当按值抛出或捕获异常时；</li>
<li>作为聚合初始化的一部分，用以初始化每个提供了初始化器的元素；</li>
</ol>
<p>复制初始化的效果是：</p>
<ol>
<li>如果 T 是类类型，且初始化器是纯右值表达式，类型与 T 为相同的类（忽略 cv 限定），则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）；</li>
<li>如果 T 是类类型，且 <em>其他对象</em> 的类型是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的 <strong>非显示构造函数</strong>；</li>
<li>如果 T 是类类型，且 <em>其他对象</em> 的类型 <strong>不是</strong> T 或从 T 派生的类（忽略 cv 限定），那么调用合适的转换函数将 <em>其他对象</em> 转换到 T。该转换的结果会被用于直接初始化该对象；</li>
<li>如果 T <strong>不是</strong> 类类型，且 <em>其他对象</em> 的类型是类类型，同上；</li>
<li>如果 T 和 <em>其他对象</em> 都不是类类型，在需要时用标准转换将 <em>其他对象</em> 的值转换成 T 的无 cv 限定版本；</li>
</ol>
<p>注意，explicit 构造函数不是转换构造函数，不会被复制初始化考虑。另外，如果 <em>其他对象</em> 是右值表达式，那么重载决议会选择 <strong>移动构造函数</strong> 并在复制初始化期间调用它。</p>
<h3 id="触发示例-1">触发示例<a hidden class="anchor" aria-hidden="true" href="#触发示例-1">#</a></h3>
<h4 id="case-1-4">case 1<a hidden class="anchor" aria-hidden="true" href="#case-1-4">#</a></h4>
<p>当非引用类型 T 的具名变量（自动、静态或线程局部），声明时带有以等号后随一个表达式所构成的初始化器时。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo copy ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    foo f1 <span style="color:#99d1db;font-weight:bold">=</span> foo(); <span style="color:#737994;font-style:italic">// 复制消除
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    foo f2 <span style="color:#99d1db;font-weight:bold">=</span> f1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-2-4">case 2<a hidden class="anchor" aria-hidden="true" href="#case-2-4">#</a></h4>
<p>当按值传递实参到函数时。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo copy ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    no_ret_f(foo()); <span style="color:#737994;font-style:italic">// 复制消除
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    foo f;           <span style="color:#737994;font-style:italic">// foo ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    no_ret_f(f);     <span style="color:#737994;font-style:italic">// foo copy ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-3-4">case 3<a hidden class="anchor" aria-hidden="true" href="#case-3-4">#</a></h4>
<p>当从按值返回的函数中返回时。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo copy ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo <span style="color:#8caaee">ret_f</span>() {
</span></span><span style="display:flex;"><span>    foo f;
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> f;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>foo <span style="color:#8caaee">ret_r_f</span>() { <span style="color:#ca9ee6">return</span> foo(); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    ret_f();   <span style="color:#737994;font-style:italic">// foo ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    ret_r_f(); <span style="color:#737994;font-style:italic">// foo ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-4-3">case 4<a hidden class="anchor" aria-hidden="true" href="#case-4-3">#</a></h4>
<p>当按值抛出或捕获异常时。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo copy ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">try</span> {
</span></span><span style="display:flex;"><span>        foo f;        <span style="color:#737994;font-style:italic">// foo ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>        <span style="color:#ca9ee6">throw</span> f;      <span style="color:#737994;font-style:italic">// foo copy ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    } <span style="color:#ca9ee6">catch</span> (foo f) { <span style="color:#737994;font-style:italic">// foo copy ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ca9ee6">throw</span> foo();  <span style="color:#737994;font-style:italic">// foo ctor，复制消除
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    } <span style="color:#ca9ee6">catch</span> (foo f) { <span style="color:#737994;font-style:italic">// foo copy ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-5-2">case 5<a hidden class="anchor" aria-hidden="true" href="#case-5-2">#</a></h4>
<p>作为聚合初始化的一部分，用以初始化每个提供了初始化器的元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo copy ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    foo f; <span style="color:#737994;font-style:italic">// foo ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    foo arr[<span style="color:#ef9f76">5</span>] <span style="color:#99d1db;font-weight:bold">=</span> {f, f, f};
</span></span><span style="display:flex;"><span>    <span style="color:#737994;font-style:italic">// foo copy ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#737994;font-style:italic">// foo copy ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#737994;font-style:italic">// foo copy ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#737994;font-style:italic">// foo ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#737994;font-style:italic">// foo ctor
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="效果示例-1">效果示例<a hidden class="anchor" aria-hidden="true" href="#效果示例-1">#</a></h3>
<h4 id="case-1-5">case 1<a hidden class="anchor" aria-hidden="true" href="#case-1-5">#</a></h4>
<p>如果 T 是类类型，且初始化器是纯右值表达式，类型与 T 为相同的类（忽略 cv 限定），则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo copy ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) { 
</span></span><span style="display:flex;"><span>    foo f <span style="color:#99d1db;font-weight:bold">=</span> foo();
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-2-5">case 2<a hidden class="anchor" aria-hidden="true" href="#case-2-5">#</a></h4>
<p>如果 T 是类类型，且 <em>其他对象</em> 的类型是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的 <strong>非显示构造函数</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo copy ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">explicit</span> <span style="color:#8caaee">foo</span>(<span style="color:#e78284">int</span>) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">bar</span> <span style="color:#99d1db;font-weight:bold">:</span> foo {
</span></span><span style="display:flex;"><span>    bar() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;bar ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    foo f1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    foo f2 <span style="color:#99d1db;font-weight:bold">=</span> f1; <span style="color:#737994;font-style:italic">// 其他对象的类型是 T，此处调用拷贝构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    foo f3 <span style="color:#99d1db;font-weight:bold">=</span> bar(); <span style="color:#737994;font-style:italic">// 其他对象的类型是 T 的派生类，bar 被隐式转换为
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>                    <span style="color:#737994;font-style:italic">// foo，然后调用拷贝构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    foo f4 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">42</span>; <span style="color:#737994;font-style:italic">// 错误。复制初始化不考虑显式构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-3-5">case 3<a hidden class="anchor" aria-hidden="true" href="#case-3-5">#</a></h4>
<p>如果 T 是类类型，且 <em>其他对象</em> 的类型 <strong>不是</strong> T 或从 T 派生的类（忽略 cv 限定），那么调用合适的转换函数将 <em>其他对象</em> 转换到 T。该转换的结果会被用于直接初始化该对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">bar</span> {
</span></span><span style="display:flex;"><span>    bar() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;bar ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo copy ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">explicit</span> <span style="color:#8caaee">foo</span>(bar) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo explicit conv from bar&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#e78284">int</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo implicit conv from int&#34;</span>); }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    foo f1{bar()};  <span style="color:#737994;font-style:italic">// 直接初始化，考虑所有构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    foo f2 <span style="color:#99d1db;font-weight:bold">=</span> bar(); <span style="color:#737994;font-style:italic">// 错误。复制初始化不考虑显式构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    foo f3 <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">42</span>;    <span style="color:#737994;font-style:italic">// 非显式构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-4-4">case 4<a hidden class="anchor" aria-hidden="true" href="#case-4-4">#</a></h4>
<p>如果 T <strong>不是</strong> 类类型，且 <em>其他对象</em> 的类型是类类型，同 case 3。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span><span style="color:#ca9ee6">struct</span> <span style="color:#e5c890">foo</span> {
</span></span><span style="display:flex;"><span>    foo() { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    foo(<span style="color:#ca9ee6">const</span> foo <span style="color:#99d1db;font-weight:bold">&amp;</span>) { std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;foo copy ctor&#34;</span>); }
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">operator</span> <span style="color:#8caaee">int</span>() { <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">42</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) { 
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> foo();
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="case-5-3">case 5<a hidden class="anchor" aria-hidden="true" href="#case-5-3">#</a></h4>
<p>如果 T 和 <em>其他对象</em> 都不是类类型，在需要时用标准转换将 <em>其他对象</em> 的值转换成 T 的无 cv 限定版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#737994;font-style:italic">#include</span> <span style="color:#737994;font-weight:bold;font-style:italic">&lt;print&gt;</span><span style="color:#737994;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#737994;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#e78284">int</span> <span style="color:#8caaee">main</span>(<span style="color:#e78284">int</span> argc, <span style="color:#e78284">char</span> <span style="color:#99d1db;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#e78284">int</span> i <span style="color:#99d1db;font-weight:bold">=</span> <span style="color:#ef9f76">3.14</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#99d1db;font-weight:bold">::</span>println(<span style="color:#a6d189">&#34;{}&#34;</span>, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ca9ee6">return</span> <span style="color:#ef9f76">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

  </div>


  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://tpcad.github.io/">Eulamber</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
