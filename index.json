[{"content":"Sed 是一个流编辑器，按行处理输入的文本。Sed 默认不会修改文件，只会将修改的内容输出到标准输出。\n模式空间与保持空间 Sed 有两个用于处理输入行的临时缓冲区，模式空间（Pattern Space）和保持空间（Holding Space）。\n模式空间相当于工厂的流水线，每一个输入行都会进入模式空间，一般的命令都会在模式空间进行。在处理结束后模式空间的内容会被打印到标准输出，并自动清空模式空间。\n保持空间是模式空间的缓冲区，用于临时保存模式空间的数据，一般的命令无法作用于保持空间。保持空间的内容不会主动清空，也不会主动打印。\nSed 每处理一行都会先将其保存到模式空间，若该行满足条件，则执行命令。命令执行完毕或输入行不满足条件，则打印模式空间内容到标准输出并清空模式空间。\n命令行参数 -n, \u0026ndash;silent, \u0026ndash;quiet Sed 处理完一行后默认会打印模式空间内容到标准输出。\n# test.md line one sed \u0026#39;1p\u0026#39; test.md # output # line one # line one # line two 使用 -n，--silent 或 --quiet 参数可以关闭自动打印。\nsed \u0026#39;1p\u0026#39; test.md # output # line one -e, \u0026ndash;expression -e 和 --expression 用于直接指定 sed 脚本。\nsed -e \u0026#39;s/Tmux/Zellij/\u0026#39; todo.md sed --expression=\u0026#39;s/Tmux/Zellij/\u0026#39; todo.md 一般情况下不需要使用参数指定 sed 脚本，但 -e 和 --expression 可以同时指定多个 sed 脚本。\nsed --expression=\u0026#39;s/Tmux/Zellij/\u0026#39; -e \u0026#39;s/\\[\\ \\]/[x]/\u0026#39; todo.md #output [x] Zellij 重复环境变量 [x] 地址 地址用于过滤需要处理的行。没有提供地址时，sed 会处理所有的输入行。提供一个地址时 sed 只会选择对应的行。提供两个地址时，sed 会选择对应范围的行。\n地址有「数字」和「正则表达式」两种形式。\n数字表示某一行，正则表达式则表示所有匹配行。数字不能为 0，正则表达式有两种书写方式。\n# 1. /regexp/ # 2. \\cregexpc # 第二种方式中的 \u0026#39;c\u0026#39; 可以是任意字符。若 \u0026#39;c\u0026#39; 出现在正则表达式中，则需要转义。 sed \u0026#39;/font/d\u0026#39; alacritty.toml sed \u0026#39;\\cfontcd\u0026#39; alacritty.toml sed \u0026#39;\\tfon\\ttd\u0026#39; alacritty.toml 单地址 单个数字选择某一行，单个正则表达式选择匹配的所有行。\nsed \u0026#39;3d\u0026#39; test.md # 删除第 3 行 sed \u0026#39;/font/d\u0026#39; alacritty.toml # 删除所有含「font」的行 双地址 双地址可以组合使用数字和正则表达式，两个地址之间以 , 分隔。\n# 测试文本 alacritty.toml 1 [font] 2 size = 18.0 3 [font.bold] 4 family = \u0026#34;Maple Mono NL NF CN\u0026#34; 5 style = \u0026#34;Bold\u0026#34; 6 [font.bold_italic] 7 family = \u0026#34;Maple Mono NL NF CN\u0026#34; 8 style = \u0026#34;Bold Italic\u0026#34; 9 [font.italic] 10 family = \u0026#34;Maple Mono NL NF CN\u0026#34; 11 style = \u0026#34;Italic\u0026#34; 12 [font.normal] 13 family = \u0026#34;Maple Mono NL NF CN\u0026#34; 14 style = \u0026#34;Regular\u0026#34; 15 [general] 16 import = [\u0026#34;/home/tpcad/.config/alacritty/catppuccin-frappe.toml\u0026#34;] sed \u0026#39;2,4d\u0026#39; test.md # 删除 2, 3, 4 行 sed \u0026#39;/Italic/, /Maple/d\u0026#39; alacritty.toml # 删除第 8～10 行，第 11～13 行 sed \u0026#39;2,/Italic/d\u0026#39; test.md # 删除第 2 行到第一次匹配到「Italic」的行（2～8 行） sed \u0026#39;/font/, 7d\u0026#39; test.md # 删除第一次匹配到「font」的行到第 7 行（1～7 行）以及之后所有包含「font」的行 当以正则表达式为起始条件时，sed 会选择所有符合条件的「范围」。如 /Italic/, /Maple/ 选择了第 8～10 行和第 11～13 行两个范围。下一个范围不会选择上一个范围的行，也就是说每个范围不会互相重叠。\n若没有匹配的结束条件，则会一直选择至下一个匹配的起始条件，若已是最后一个范围则选择至最后一行。若结束条件为数字并小于起始条件匹配到的第一行，则只会选择起始条件匹配的所有行。\n# 结束条件不存在，选择至下一个匹配的起始条件 nl alacritty.toml | sed -n \u0026#39;/style/,/non/p\u0026#39; nl alacritty.toml | sed -n \u0026#39;/style/,33p\u0026#39; # 5 style = \u0026#34;Bold\u0026#34; # 6 [font.bold_italic] # 7 family = \u0026#34;Maple Mono NL NF CN\u0026#34; # 8 style = \u0026#34;Bold Italic\u0026#34; # 9 [font.italic] # 10 family = \u0026#34;Maple Mono NL NF CN\u0026#34; # 11 style = \u0026#34;Italic\u0026#34; # 12 [font.normal] # 13 family = \u0026#34;Maple Mono NL NF CN\u0026#34; # 14 style = \u0026#34;Regular\u0026#34; # 15 [general] # 16 import = [\u0026#34;/home/tpcad/.config/alacritty/catppuccin-frappe.toml\u0026#34;] # 小于起始条件匹配到的第一行，选择所有含有 `style` 的行 nl alacritty.toml | sed -n \u0026#39;/style/,3p\u0026#39; # 5 style = \u0026#34;Bold\u0026#34; # 8 style = \u0026#34;Bold Italic\u0026#34; # 11 style = \u0026#34;Italic\u0026#34; # 14 style = \u0026#34;Regular\u0026#34; 使用双地址时，匹配起始条件的行无论如何都会被选中，哪怕结束条件匹配的行在该行之前。\nsed \u0026#39;3, 2p\u0026#39; -n # 打印第 3 行 当第二个地址是正则表达式时，sed 不会再检查第一个地址所选择的行是否满足第二个地址的正则表达式。\nsed \u0026#39;3, /font/p\u0026#39; -n # 打印 3～6 行 其他形式 $ 表示最后一行。\nsed \u0026#39;$d\u0026#39; alacritty.toml # 删除最后一行 first~step 表示从第 first 行开始，步进为 step 行。first 可以为 0，此时相当于从 step 行开始。\nsed \u0026#39;2~4d\u0026#39; test.md # 删除 2, 6, 10 行（从 2 开始，步进为 4） 0,regexp 表示从第 1 行开始直至第一次匹配到 regexp。与 number,regexp 不同，该形式检查第一个地址是否匹配正则表达式。\nsed \u0026#39;0,/font/d\u0026#39; alacritty.toml # [font] sed \u0026#39;1,/font/d\u0026#39; alacritty.toml # [font] # size = 18.0 # [font.bold] addr1,+N 表示选择 addr1 和其随后的 N 行。N 为数字。\nnl alacritty.toml | sed \u0026#39;/font/,+3\u0026#39; # 1 [font] # 2 size = 18.0 # 3 [font.bold] # 4 family = \u0026#34;Maple Mono NL NF CN\u0026#34; # 6 [font.bold_italic] # 7 family = \u0026#34;Maple Mono NL NF CN\u0026#34; # 8 style = \u0026#34;Bold Italic\u0026#34; # 9 [font.italic] # 12 [font.normal] # 13 family = \u0026#34;Maple Mono NL NF CN\u0026#34; # 14 style = \u0026#34;Regular\u0026#34; # 15 [general] # 正则表达式作为第一个地址时仍然会选择多个范围 addr1,~N 表示选择 addr1 和其随后的行，直至行号等于 N 的倍数。\nnl alacritty.toml | sed -n \u0026#39;/style/,~5p\u0026#39; # 两个范围 # 5 style = \u0026#34;Bold\u0026#34; # 6 [font.bold_italic] # 7 family = \u0026#34;Maple Mono NL NF CN\u0026#34; # 8 style = \u0026#34;Bold Italic\u0026#34; # 9 [font.italic] # 10 family = \u0026#34;Maple Mono NL NF CN\u0026#34; # 11 style = \u0026#34;Italic\u0026#34; # 12 [font.normal] # 13 family = \u0026#34;Maple Mono NL NF CN\u0026#34; # 14 style = \u0026#34;Regular\u0026#34; # 15 [general] nl alacritty.toml | sed -n \u0026#39;9,~5p\u0026#39; # 9 [font.italic] # 10 family = \u0026#34;Maple Mono NL NF CN\u0026#34; 命令 命令必须包裹在单引号中。\n常用命令 打印行号 = 打印当前行行号。行号会在新的一行输出。\nsed \u0026#39;/font/=\u0026#39; alacritty.toml -n # 1 # 3 # 6 # 9 # 12 插入内容 a 在行后插入内容。若有多行内容使用 \\ 分隔。\nsed \u0026#39;/general/anew line\u0026#39; alacritty.toml sed \u0026#39;/general/aline one\\ line two\\ line three\u0026#39; alacritty.toml i 在行前插入内容。若有多行内容使用 \\ 分隔。\nsed \u0026#39;/general/inew line\u0026#39; alacritty.toml sed \u0026#39;/general/iline one\\ line two\\ line three\u0026#39; alacritty.toml 删除 d 清空当前模式空间并开始处理下一行。\nsed \u0026#39;/font/, /Maple/d\u0026#39; alacritty.toml D 删除模式空间的第一行并立即开始（跳过自动打印和清空）下一轮处理但不读取新的行。\n# 与 d 相同，因为模式空间总是只有一行 sed \u0026#39;/font/, /Maple/D\u0026#39; alacritty.toml sed \u0026#39;N;D\u0026#39; alacritty.toml # 打印最后一行 替换 c 替换所选择的行为指定内容。若有多行内容使用 \\ 分隔。\n# test.md # line one # line two # line three sed \u0026#39;/line/c\\new line\u0026#39; test.md # new line # new line # new line # 若为范围则会替换整个范围。 sed \u0026#39;/one/,/two/c\\new line\u0026#39; test.md # new line # line three s/regexp/replacement 替换行的匹配部分为指定内容。\nsed \u0026#39;/line/s/line/LINE/\u0026#39; append.txt # LINE one # LINE two # LINE three sed \u0026#39;1,2s/line/LINE/\u0026#39; append.txt # LINE one # LINE two # line three 打印模式空间 p 打印整个模式空间；P 打印模式空间的第一行。\n打印命令通常搭配 -n 参数使用，避免自动打印影响输出内容。\n读取下一行 n 清空当前模式空间并读取下一行到模式空间；N 读取下一行并附加到模式空间。若没有可读取的下一行则结束 sed。\nsed \u0026#39;n;p;q\u0026#39; test.md -n # line two sed \u0026#39;N;p;q\u0026#39; test.md -n # line one # line two 进阶命令 停止并退出 q，Q 立即停止并退出 sed。q 不会停止自定打印，Q 会停止自动打印。\nnl alacritty.toml | sed \u0026#39;/font/p;q\u0026#39; # 1 [font] # 1 [font] nl alacritty.toml | sed \u0026#39;/font/p;Q\u0026#39; # 1 [font] 从文件获取插入内容 r 从文件中获取所有内容并插入到匹配「行后」。\nsed \u0026#39;/font/r append.txt\u0026#39; alacritty.toml # [font] # line one # line two # size = 18.0 # [font.bold] # line one # line two # family = \u0026#34;Maple Mono NL NF CN\u0026#34; # style = \u0026#34;Bold\u0026#34; # [font.bold_italic] # line one # line two 操作保持空间 x 交换模式空间和保持空间。保持空间默认只有一个换行符。\nsed \u0026#39;x;p;q\u0026#39; test.md # 打印空行。 h 拷贝模式空间内容到保持空间；H 附加模式空间内容到保持空间。拷贝会覆盖原有的内容。\nsed \u0026#39;h;x;p\u0026#39; test.md -n # line one # line two # line three sed \u0026#39;H;${x;p}\u0026#39; test.md -n # # line one # line two # line three g 拷贝保持空间内容到模式空间；G 附加保持空间内容到模式空间。拷贝会覆盖原有的内容。\n# 倒序 sed \u0026#39;1!G;h;$!d\u0026#39; test.md # line three # line two # line one 保存模式空间到文件 w 将模式空间写入到指定文件（会覆盖已有内容）。\nsed \u0026#39;/font/!wnew.txt\u0026#39; alacritty.toml 字符替换 y/source/dest 将匹配行中 dest 的字符替换为 source 中的对应字符。soucre 和 dest 的长度必须相同。\nsed \u0026#39;y/abcefghijk/1234567980\u0026#39; test.md # l8n4 on4 # l8n4 two # l8n4 t7r44 GNU 扩展 q，Q 可以指定退出码。\nnl alacritty.toml | sed \u0026#39;/font/p;Q 0\u0026#39; nl alacritty.toml | sed \u0026#39;/font/p;Q 3\u0026#39; R 逐行读取文件内容并插入到匹配行后。\nsed \u0026#39;/font/R append.txt\u0026#39; alacritty.toml # [font] # line one # 第一行 # size = 18.0 # [font.bold] # line two # 第一行 # family = \u0026#34;Maple Mono NL NF CN\u0026#34; # style = \u0026#34;Bold\u0026#34; # [font.bold_italic] # family = \u0026#34;Maple Mono NL NF CN\u0026#34; W 将模式空间第一行写入指定文件。\n","permalink":"https://tpcad.github.io/posts/sed/","summary":"\u003cp\u003eSed 是一个流编辑器，按行处理输入的文本。Sed 默认不会修改文件，只会将修改的内容输出到标准输出。\u003c/p\u003e\n\u003ch2 id=\"模式空间与保持空间\"\u003e模式空间与保持空间\u003c/h2\u003e\n\u003cp\u003eSed 有两个用于处理输入行的临时缓冲区，模式空间（Pattern Space）和保持空间（Holding Space）。\u003c/p\u003e\n\u003cp\u003e模式空间相当于工厂的流水线，每一个输入行都会进入模式空间，一般的命令都会在模式空间进行。在处理结束后模式空间的内容会被打印到标准输出，并自动清空模式空间。\u003c/p\u003e\n\u003cp\u003e保持空间是模式空间的缓冲区，用于临时保存模式空间的数据，一般的命令无法作用于保持空间。保持空间的内容不会主动清空，也不会主动打印。\u003c/p\u003e\n\u003cp\u003eSed 每处理一行都会先将其保存到模式空间，若该行满足条件，则执行命令。命令执行完毕或输入行不满足条件，则打印模式空间内容到标准输出并清空模式空间。\u003c/p\u003e\n\u003ch2 id=\"命令行参数\"\u003e命令行参数\u003c/h2\u003e\n\u003ch3 id=\"-n-silent-quiet\"\u003e-n, \u0026ndash;silent, \u0026ndash;quiet\u003c/h3\u003e\n\u003cp\u003eSed 处理完一行后默认会打印模式空间内容到标准输出。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e# test.md\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eline one\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esed \u003cspan style=\"color:#a6d189\"\u003e\u0026#39;1p\u0026#39;\u003c/span\u003e test.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e# output\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e# line one\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e# line one\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e# line two\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用 \u003ccode\u003e-n\u003c/code\u003e，\u003ccode\u003e--silent\u003c/code\u003e 或 \u003ccode\u003e--quiet\u003c/code\u003e 参数可以关闭自动打印。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esed \u003cspan style=\"color:#a6d189\"\u003e\u0026#39;1p\u0026#39;\u003c/span\u003e test.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e# output\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e# line one\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"-e-expression\"\u003e-e, \u0026ndash;expression\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e-e\u003c/code\u003e 和 \u003ccode\u003e--expression\u003c/code\u003e 用于直接指定 sed 脚本。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esed -e \u003cspan style=\"color:#a6d189\"\u003e\u0026#39;s/Tmux/Zellij/\u0026#39;\u003c/span\u003e todo.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esed --expression\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e\u0026#39;s/Tmux/Zellij/\u0026#39;\u003c/span\u003e todo.md\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e一般情况下不需要使用参数指定 sed 脚本，但 \u003ccode\u003e-e\u003c/code\u003e 和 \u003ccode\u003e--expression\u003c/code\u003e 可以同时指定多个 sed 脚本。\u003c/p\u003e","title":"Sed 参考手册"},{"content":"变量的初始化会在构造时提供变量的初始值。\n初始值可以由声明符或 new 表达式的 初始化器 部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。\n初始化器（如果存在）必须是下列之一：\n1. = expression 2. = {} = { initializer-list } = { designated-initializer-list } 3. ( expression-list ) ( initializer-list ) 4. {} { initializer-list } { designated-initializer-list } 默认初始化 1. T object; 2. new T; 当没有为对象指定初始化器时，该对象会默认初始化。具体有以下三种情况：\n不带初始化器声明具有自动、静态或线程局部存储器的变量； 不带初始化器使用 new 表达式创建一个对象； 构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数； 默认初始化的效果是：\n如果是类类型，调用默认构造函数； 如果是数组类型，数组的每个元素都被默认初始化； 否则不进行初始化； 不确定值 在获取到具有自动或动态存储期的对象的存储时，该对象具有不确定值。\n如果不对对象进行任何初始化，那么该对象具有不确定值，直到该值被替换。\n示例 case 1 不带初始化器声明具有自动、静态或线程局部存储器的变量。\n#include \u0026lt;print\u0026gt; // 静态全局非类，两次初始化 // 1) 零初始化将 si1 初始化为 0 // 2) 默认初始化不做任何事 int si1; int main() { std::println(\u0026#34;si1 静态全局非类，零初始化：{}\u0026#34;, si1); static int si2; // 静态局部非类，同全局静态非类 std::println(\u0026#34;si2 静态局部非类，零初始化：{}\u0026#34;, si2); int i1; // 自动局部非类，默认初始化不做任何事，不确定值 std::println(\u0026#34;i1 非类，不确定值：{}\u0026#34;, i1); return 0; } case 2 不带初始化器使用 new 表达式创建一个对象。\n#include \u0026lt;print\u0026gt; // 动态全局非类，默认初始化不做任何事，不确定值 int *pi1 = new int; int main() { int *pi2 = new int; // 动态局部非类，默认初始化不做任何事，不确定值 std::println(\u0026#34;*pi1 动态全局非类，不确定值：{}\u0026#34;, *pi1); std::println(\u0026#34;*pi2 动态局部非类，不确定值：{}\u0026#34;, *pi2); return 0; } 多次执行上方代码可能得到的都是相同的结果，*pi1 和 *pi2 的值都是 0。不能就此认为默认初始化是的值就是 0。如果多次销毁并分配 同一块内存 可以发现其初始化值是不确定值。\n#include \u0026lt;print\u0026gt; int main() { int *p = new int; std::println(\u0026#34;*p：{}\u0026#34;, *p); std::println(\u0026#34;*p：{:p}\u0026#34;, static_cast\u0026lt;void *\u0026gt;(p)); delete p; p = new int; std::println(\u0026#34;*p：{}\u0026#34;, *p); std::println(\u0026#34;*p：{:p}\u0026#34;, static_cast\u0026lt;void *\u0026gt;(p)); return 0; } case 3 构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数。\n#include \u0026lt;print\u0026gt; struct foo { int mem; }; struct bar { int mema; int memb; bar() : mema() {} }; int main() { foo f1; std::println(\u0026#34;foo.mem 无成员初始化列表类，不确定值：{}\u0026#34;, f1.mem); bar b1; std::println(\u0026#34;bar.mema 有成员初始化列表类，值初始化：{}\u0026#34;, b1.mema); std::println(\u0026#34;bar.memb 无成员初始化列表类，不确定值：{}\u0026#34;, b1.memb); return 0; } 对于具有动态存储期的类类型变量，同样会出现第一次分配内存时，值被初始化为 0，但在销毁并再次分配后是不确定值的现象。\n值初始化 1. T() 2. new T() 3. Class::Class(...) : member() {...} 4. T object {}; 5. T{} 6. new T{} 7. Class::Class(...) : member{} {...} 以空初始化器进行的初始化。有以下几种情况：\n以空的 () 或 {} 组成的初始化器创建临时对象（1，5）； new 表达式以空的 () 或 {} 组成的初始化器创建动态存储期对象（2，6）； 以空的 () 或 {} 组成的成员初始化器初始化非静态数据成员或基类（3，7）； 以空的 {} 对声明 具名对象（4）； 另外，如果使用了 {} 且 T 是聚合体，那么就会进行聚合初始化。如果 T 没有默认构造函数但有接受 std::initializer_list 的构造函数，那么会进行列表初始化。\n值初始化的效果是：\n如果 T 是（可有 cv 限定）类类型： 如果 T 的默认初始化选择了一个 不由用户提供的构造函数，那么对象会首先进行零初始化； 任何情况下，对象都被默认初始化； 如果 T 是数组类型，值初始化每一个元素； 否则，进行零初始化； 注意，引用不能被值初始化。\n示例 case 1 以空的 () 或 {} 组成的初始化器创建临时对象。\n#include \u0026lt;print\u0026gt; int main() { int i1 = int(); // 非类，空 () 创建临时对象，零初始化 int i2 = int{}; // 非类，空 {} 创建临时对象，零初始化 std::println(\u0026#34;i1 非类，空 () 创建临时对象，零初始化：{}\u0026#34;, i1); std::println(\u0026#34;i2 非类，空 {{}} 创建临时对象，零初始化：{}\u0026#34;, i2); return 0; } 注意，进行值初始化的其实是 int() 和 int{}，而 i1、i2 则进行 复制初始化。\ncase 2 new 表达式以空的 () 或 {} 组成的初始化器创建动态存储期对象。\n#include \u0026lt;print\u0026gt; int main() { int *ip1 = new int(); // 非类，空 () 创建动态对象，零初始化 int *ip2 = new int{}; // 非类，空 {} 创建动态对象，零初始化 std::println(\u0026#34;*ip1 非类，空 () 创建动态对象，零初始化：{}\u0026#34;, *ip1); std::println(\u0026#34;*ip2 非类，空 {{}} 创建动态对象，零初始化：{}\u0026#34;, *ip2); } 注意，进行值初始化的其实是 new int() 和 new int{}，而 ip1、ip2 则进行 复制初始化。\ncase 3 以空的 () 或 {} 组成的成员初始化器初始化非静态数据成员或基类。\n#include \u0026lt;print\u0026gt; struct foo { int mem; // 隐式构造函数，不由用户提供 // foo() = default; 同上 }; struct bar { int mema; int memb; bar() : mema() {} // 用户提供构造函数，部分成员初始化列表 }; int main() { foo f = foo(); std::println(\u0026#34;foo::mem 类，隐式构造函数，零初始化：{}\u0026#34;, f.mem); bar b = bar{}; std::println(\u0026#34;bar::mema 类，带成员初始化列表，零初始化：{}\u0026#34;, b.mema); std::println(\u0026#34;bar::memb 类，不带成员初始化列表，默认初始化：{}\u0026#34;, b.memb); return 0; } case 4 以空的 {} 对声明 具名对象。\n#include \u0026lt;print\u0026gt; struct foo() { int mem; }; int main() { int i{}; std::println(\u0026#34;i 非类，零初始化：{}\u0026#34;, i); foo f{}; std::println(\u0026#34;foo.mem 类，隐式构造函数，零初始化：{}\u0026#34;, f1.mem); } 注意，T object() 不初始化对象，而是声明一个无参且返回 T 的函数。\n直接初始化 1. T object(arg); T object(arg1, arg2, ...); 2. T object{arg}; 3. T(other object) T(arg1, arg2) 4. static_cast\u0026lt;T\u0026gt;(other object) 5. new T(args, ...) 6. Class::Class() : member(args, ...) {...} 7. [arg]() {} 以一组明确的构造函数实参对对象进行初始化。有以下几种情况：\n以表达式的非空带括号列表初始化对象； 以 {} 环绕的单个初始化器初始化一个 非类类型 对象； 以函数风格转换或以带括号的表达式列表初始化 纯右值的结果对象； 以 static_cast 表达式初始化 纯右值的结果对象； 以带有非空初始化器的 new 表达式初始化具有动态存储期的对象； 用构造函数初始化器列表初始化基类或非静态成员； 在 lambda 表达式中从按复制捕获的变量初始化闭包对象的成员； 直接初始化的效果是：\n如果 T 是数组类型，那么程序非良构； 如果 T 是类类型， 如果初始化器是纯右值表达式且类型与 T 为相同的类（忽略 cv 限定），则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）； 检验 T 的构造函数并由重载决议选取最佳匹配，然后调用该构造函数以初始化对象； 否则，如果 T 是非类类型但源类型是类类型，则检验源类型及其各基类的转换函数，并由重载决议选取最佳匹配，然后用选取的转换函数，将初始化器表达式转换为所初始化的对象。 否则，如果 T 是 bool 而原类型是 std::nullptr_t，则被初始化对象的值为 false； 否则，在必要时使用标准转换，转换 其他对象 的值为 T 的无 cv 限定版本，而所初始化的对象的初值为（可能为转换后的）该值。 触发示例 case 1 以表达式的非空带括号列表初始化对象。\n#include \u0026lt;print\u0026gt; int main(int argc, char *argv[]) { int i(3); std::println(\u0026#34;{}\u0026#34;, i); std::string str(3, \u0026#39;t\u0026#39;); std::println(\u0026#34;{}\u0026#34;, str); return 0; } case 2 以 {} 环绕的单个初始化器初始化一个 非类类型 对象。\n#include \u0026lt;print\u0026gt; int main(int argc, char *argv[]) { int i{3}; std::println(\u0026#34;{}\u0026#34;, i); return 0; } case 3 以函数风格转换或以带括号的表达式列表初始化 纯右值的结果对象。\n#include \u0026lt;print\u0026gt; int main(int argc, char *argv[]) { // 函数风格转换 std::println(\u0026#34;{}\u0026#34;, int(3)); // 带括号的表达式列表 std::println(\u0026#34;{}\u0026#34;, std::string(3, \u0026#39;t\u0026#39;)); // 初始化器得到的是纯右值结果对象 // int \u0026amp;x(int(3)); return 0; } case 4 以 static_cast 表达式初始化 纯右值的结果对象。\n#include \u0026lt;print\u0026gt; int main(int argc, char *argv[]) { std::println(\u0026#34;{}\u0026#34;, static_cast\u0026lt;double\u0026gt;(3)); std::println(\u0026#34;{}\u0026#34;, static_cast\u0026lt;std::string\u0026gt;(\u0026#34;hello\u0026#34;)); // 初始化器得到的是纯右值结果对象 // int \u0026amp;x(static_cast\u0026lt;int\u0026gt;(3.3)); // int \u0026amp;x(static_cast\u0026lt;std::string\u0026gt;(\u0026#34;hello\u0026#34;)); return 0; } case 5 以带有非空初始化器的 new 表达式初始化具有动态存储期的对象。\n#include \u0026lt;print\u0026gt; int main(int argc, char *argv[]) { std::println(\u0026#34;{}\u0026#34;, *(new int(3))); std::println(\u0026#34;{}\u0026#34;, *(new std::string(3, \u0026#39;t\u0026#39;))); // 初始化器得到的是纯右值结果对象 // int \u0026amp;x(new int(3)); return 0; } case 6 用构造函数初始化器列表初始化基类或非静态成员。\n#include \u0026lt;print\u0026gt; struct foo { int mema; std::string memb; foo() : mema(42), memb(3, \u0026#39;t\u0026#39;) {} }; int main(int argc, char *argv[]) { foo f; std::println(\u0026#34;f.mema: {}\u0026#34;, f.mema); std::println(\u0026#34;f.memb: {}\u0026#34;, f.memb); return 0; } case 7 在 lambda 表达式中从按复制捕获的变量初始化闭包对象的成员。\n#include \u0026lt;print\u0026gt; struct foo { int mema; std::string memb; foo() : mema(42), memb(3, \u0026#39;t\u0026#39;) {} }; int main(int argc, char *argv[]) { foo f; auto x = [f]() { std::println(\u0026#34;f.mema: {}\u0026#34;, f.mema); std::println(\u0026#34;f.memb: {}\u0026#34;, f.memb); }; x(); return 0; } 效果示例 case 1 T 是类类型，初始化器是纯右值表达式且类型与 T 为相同的类，则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）。\n#include \u0026lt;iostream\u0026gt; struct foo { foo(int) { std::cout \u0026lt;\u0026lt; \u0026#34;foo ctor\u0026#34; \u0026lt;\u0026lt; std::endl; } foo(const foo \u0026amp;) { std::cout \u0026lt;\u0026lt; \u0026#34;foo copy ctor\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main(int argc, char *argv[]) { foo f(foo(1)); return 0; } // outpus: // foo ctor 在 C++17 之前，这并不是一种语言特性，而是编译器优化，可以通过 -fno-elide-constructors 关闭，而且类必须拥有拷贝构造函数。关闭后 foo f(foo(1)) 会先调用合适的构造函数初始化一个纯右值临时量，再调用拷贝构造函数初始化 f。\nfoo ctor foo copy ctor case 2 T 是类类型，检验 T 的构造函数并由重载决议选取最佳匹配，然后调用该构造函数以初始化对象。\n#include \u0026lt;print\u0026gt; struct foo { foo(int, double) { std::println(\u0026#34;ctor 0\u0026#34;); } foo(int) { std::println(\u0026#34;ctor 1\u0026#34;); } foo(double) { std::println(\u0026#34;ctor 2\u0026#34;); } }; int main(int argc, char *argv[]) { foo f0(42, 3.14); foo f1(42); foo(3.14); return 0; } case 3 如果 T 是非类类型但源类型是类类型，则检验源类型及其各基类的转换函数，并由重载决议选取最佳匹配，然后用选取的转换函数，将初始化器表达式转换为所初始化的对象。\n#include \u0026lt;print\u0026gt; struct foo { operator int() { return 42; } }; struct bar : foo { operator int() { return 24; } }; struct meow : foo {}; int main(int argc, char *argv[]) { foo f; bar b; meow m; int i(f); std::println(\u0026#34;{}\u0026#34;, i); int x(b); std::println(\u0026#34;{}\u0026#34;, x); int v(m); std::println(\u0026#34;{}\u0026#34;, v); return 0; } case 4 如果 T 是 bool 而原类型是 std::nullptr_t，则被初始化对象的值为 false。\n#include \u0026lt;print\u0026gt; int main(int argc, char *argv[]) { int *p = nullptr; bool b(p); std::println(\u0026#34;{}\u0026#34;, b); return 0; } case 5 在必要时使用标准转换，转换 其他对象 的值为 T 的无 cv 限定版本，而所初始化的对象的初值为（可能为转换后的）该值。\n#include \u0026lt;print\u0026gt; struct foo { foo(int) { std::println(\u0026#34;foo ctor\u0026#34;); } }; struct bar { bar() { std::println(\u0026#34;bar ctor\u0026#34;); } operator int() { std::println(\u0026#34;bar convertion\u0026#34;); return 24; } }; struct meow : foo {}; int main(int argc, char *argv[]) { // 类型为 bar 的临时变量被隐式转换为 int 传给 foo 的构造函数 foo f(bar{}); return 0; } // output: // bar ctor // bar convertion // foo ctor 复制初始化 1. T object = other; 2. f(other) 3. return other; 4. throw object; catch(T object) 5. T array[N] = {other-sequence}; 从另一个对象初始化对象。有以下几种情况：\n当非引用类型 T 的具名变量（自动、静态或线程局部），声明时带有以等号后随一个表达式所构成的初始化器时； 当按值传递实参到函数时； 当从按值返回的函数中返回时； 当按值抛出或捕获异常时； 作为聚合初始化的一部分，用以初始化每个提供了初始化器的元素； 复制初始化的效果是：\n如果 T 是类类型，且初始化器是纯右值表达式，类型与 T 为相同的类（忽略 cv 限定），则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）； 如果 T 是类类型，且 其他对象 的类型是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的 非显示构造函数； 如果 T 是类类型，且 其他对象 的类型 不是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的转换函数将 其他对象 转换到 T。该转换的结果会被用于直接初始化该对象； 如果 T 不是 类类型，且 其他对象 的类型是类类型，同上； 如果 T 和 其他对象 都不是类类型，在需要时用标准转换将 其他对象 的值转换成 T 的无 cv 限定版本； 注意，explicit 构造函数不是转换构造函数，不会被复制初始化考虑。另外，如果 其他对象 是右值表达式，那么重载决议会选择 移动构造函数 并在复制初始化期间调用它。\n复制初始化中的隐式转换必须从初始化器直接生成 T，而直接初始化则允许从初始化器到 T 的某个构造函数实参的隐式转换。\n#include \u0026lt;print\u0026gt; struct foo { foo(int) { std::println(\u0026#34;foo int ctor\u0026#34;); } }; struct bar { bar(foo) { std::println(\u0026#34;bar foo ctor\u0026#34;); } }; int main(int argc, char *argv[]) { bar b1(42); // OK。42 先被转换成 foo，再转换成 bar bar b2 = 42; // 错误。复制初始化的初始化器必须直接生成 T bar b3(foo{42}); // OK。初始化器 foo{42} 直接生成 T return 0; } 触发示例 case 1 当非引用类型 T 的具名变量（自动、静态或线程局部），声明时带有以等号后随一个表达式所构成的初始化器时。\n#include \u0026lt;print\u0026gt; struct foo { foo() { std::println(\u0026#34;foo ctor\u0026#34;); } foo(const foo \u0026amp;) { std::println(\u0026#34;foo copy ctor\u0026#34;); } }; int main(int argc, char *argv[]) { foo f1 = foo(); // 复制消除 foo f2 = f1; return 0; } case 2 当按值传递实参到函数时。\n#include \u0026lt;print\u0026gt; struct foo { foo() { std::println(\u0026#34;foo ctor\u0026#34;); } foo(const foo \u0026amp;) { std::println(\u0026#34;foo copy ctor\u0026#34;); } }; int main(int argc, char *argv[]) { no_ret_f(foo()); // 复制消除 foo f; // foo ctor no_ret_f(f); // foo copy ctor return 0; } case 3 当从按值返回的函数中返回时。\n#include \u0026lt;print\u0026gt; struct foo { foo() { std::println(\u0026#34;foo ctor\u0026#34;); } foo(const foo \u0026amp;) { std::println(\u0026#34;foo copy ctor\u0026#34;); } }; foo ret_f() { foo f; return f; } foo ret_r_f() { return foo(); } int main(int argc, char *argv[]) { ret_f(); // foo ctor ret_r_f(); // foo ctor return 0; } case 4 当按值抛出或捕获异常时。\n#include \u0026lt;print\u0026gt; struct foo { foo() { std::println(\u0026#34;foo ctor\u0026#34;); } foo(const foo \u0026amp;) { std::println(\u0026#34;foo copy ctor\u0026#34;); } }; int main(int argc, char *argv[]) { try { foo f; // foo ctor throw f; // foo copy ctor } catch (foo f) { // foo copy ctor } try { throw foo(); // foo ctor，复制消除 } catch (foo f) { // foo copy ctor } return 0; } case 5 作为聚合初始化的一部分，用以初始化每个提供了初始化器的元素。\n#include \u0026lt;print\u0026gt; struct foo { foo() { std::println(\u0026#34;foo ctor\u0026#34;); } foo(const foo \u0026amp;) { std::println(\u0026#34;foo copy ctor\u0026#34;); } }; int main(int argc, char *argv[]) { foo f; // foo ctor foo arr[5] = {f, f, f}; // foo copy ctor // foo copy ctor // foo copy ctor // foo ctor // foo ctor return 0; } 效果示例 case 1 如果 T 是类类型，且初始化器是纯右值表达式，类型与 T 为相同的类（忽略 cv 限定），则用初始化器表达式自身，而非从它实质化的临时量，初始化目标对象（参考复制消除）。\n#include \u0026lt;print\u0026gt; struct foo { foo() { std::println(\u0026#34;foo ctor\u0026#34;); } foo(const foo \u0026amp;) { std::println(\u0026#34;foo copy ctor\u0026#34;); } }; int main(int argc, char *argv[]) { foo f = foo(); return 0; } case 2 如果 T 是类类型，且 其他对象 的类型是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的 非显示构造函数。\n#include \u0026lt;print\u0026gt; struct foo { foo() { std::println(\u0026#34;foo ctor\u0026#34;); } foo(const foo \u0026amp;) { std::println(\u0026#34;foo copy ctor\u0026#34;); } explicit foo(int) {} }; struct bar : foo { bar() { std::println(\u0026#34;bar ctor\u0026#34;); } }; int main(int argc, char *argv[]) { foo f1; foo f2 = f1; // 其他对象的类型是 T，此处调用拷贝构造函数 foo f3 = bar(); // 其他对象的类型是 T 的派生类，bar 被隐式转换为 // foo，然后调用拷贝构造函数 foo f4 = 42; // 错误。复制初始化不考虑显式构造函数 return 0; } case 3 如果 T 是类类型，且 其他对象 的类型 不是 T 或从 T 派生的类（忽略 cv 限定），那么调用合适的转换函数将 其他对象 转换到 T。该转换的结果会被用于直接初始化该对象。\n#include \u0026lt;print\u0026gt; struct bar { bar() { std::println(\u0026#34;bar ctor\u0026#34;); } }; struct foo { foo() { std::println(\u0026#34;foo ctor\u0026#34;); } foo(const foo \u0026amp;) { std::println(\u0026#34;foo copy ctor\u0026#34;); } explicit foo(bar) { std::println(\u0026#34;foo explicit conv from bar\u0026#34;); } foo(int) { std::println(\u0026#34;foo implicit conv from int\u0026#34;); } }; int main(int argc, char *argv[]) { foo f1{bar()}; // 直接初始化，考虑所有构造函数 foo f2 = bar(); // 错误。复制初始化不考虑显式构造函数 foo f3 = 42; // 非显式构造函数 return 0; } case 4 如果 T 不是 类类型，且 其他对象 的类型是类类型，同 case 3。\n#include \u0026lt;print\u0026gt; struct foo { foo() { std::println(\u0026#34;foo ctor\u0026#34;); } foo(const foo \u0026amp;) { std::println(\u0026#34;foo copy ctor\u0026#34;); } operator int() { return 42; } }; int main(int argc, char *argv[]) { int i = foo(); std::println(\u0026#34;{}\u0026#34;, i); return 0; } case 5 如果 T 和 其他对象 都不是类类型，在需要时用标准转换将 其他对象 的值转换成 T 的无 cv 限定版本。\n#include \u0026lt;print\u0026gt; int main(int argc, char *argv[]) { int i = 3.14; std::println(\u0026#34;{}\u0026#34;, i); return 0; } ","permalink":"https://tpcad.github.io/posts/cpp_initialization/","summary":"\u003cp\u003e变量的初始化会在构造时提供变量的初始值。\u003c/p\u003e\n\u003cp\u003e初始值可以由声明符或 new 表达式的 \u003cstrong\u003e初始化器\u003c/strong\u003e 部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。\u003c/p\u003e\n\u003cp\u003e初始化器（如果存在）必须是下列之一：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003e1.\u003c/span\u003e = expression\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003e2.\u003c/span\u003e = {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   = { initializer-list }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   = { designated-initializer-list }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003e3.\u003c/span\u003e ( expression-list )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   ( initializer-list )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003e4.\u003c/span\u003e {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   { initializer-list }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   { designated-initializer-list }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"默认初始化\"\u003e默认初始化\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-markdown\" data-lang=\"markdown\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003e1.\u003c/span\u003e T object;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003e2.\u003c/span\u003e new T;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当没有为对象指定初始化器时，该对象会默认初始化。具体有以下三种情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e不带初始化器声明具有自动、静态或线程局部存储器的变量；\u003c/li\u003e\n\u003cli\u003e不带初始化器使用 new 表达式创建一个对象；\u003c/li\u003e\n\u003cli\u003e构造函数的成员初始化器列表没有提及某个基类或非静态数据成员，且调用了该构造函数；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e默认初始化的效果是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如果是类类型，调用默认构造函数；\u003c/li\u003e\n\u003cli\u003e如果是数组类型，数组的每个元素都被默认初始化；\u003c/li\u003e\n\u003cli\u003e否则不进行初始化；\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"不确定值\"\u003e不确定值\u003c/h3\u003e\n\u003cp\u003e在获取到具有自动或动态存储期的对象的存储时，该对象具有不确定值。\u003c/p\u003e\n\u003cp\u003e如果不对对象进行任何初始化，那么该对象具有不确定值，直到该值被替换。\u003c/p\u003e\n\u003ch3 id=\"示例\"\u003e示例\u003c/h3\u003e\n\u003ch4 id=\"case-1\"\u003ecase 1\u003c/h4\u003e\n\u003cp\u003e不带初始化器声明具有自动、静态或线程局部存储器的变量。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#737994;font-weight:bold;font-style:italic\"\u003e\u0026lt;print\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 静态全局非类，两次初始化\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 1) 零初始化将 si1 初始化为 0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 2) 默认初始化不做任何事\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e si1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003eprintln(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;si1 静态全局非类，零初始化：{}\u0026#34;\u003c/span\u003e, si1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e si2;     \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 静态局部非类，同全局静态非类\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003eprintln(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;si2 静态局部非类，零初始化：{}\u0026#34;\u003c/span\u003e, si2);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e i1;             \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 自动局部非类，默认初始化不做任何事，不确定值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003eprintln(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;i1 非类，不确定值：{}\u0026#34;\u003c/span\u003e, i1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"case-2\"\u003ecase 2\u003c/h4\u003e\n\u003cp\u003e不带初始化器使用 new 表达式创建一个对象。\u003c/p\u003e","title":"C++ 初始化"},{"content":"红黑树是一种平衡的二叉搜索树，满足如下性质：\n节点要么是 黑色，要么是 红色 根节点必须是黑色 所有叶子节点都是黑色 红色节点的子节点必须是黑色 从任一节点到叶子节点的所有简单路径都包含相同数量的黑色节点 其中叶子节点指的是为空的节点。如下图所示，null 是叶子节点，而节点 9 和节点 20 不是叶子节点（它们的子结点也是叶子节点，图中没有画出）。\n10 / \\ 8 14 / \\ / \\ null 9 null 20 节点定义 template \u0026lt;typename T\u0026gt; requires std::equality_comparable\u0026lt;T\u0026gt; \u0026amp;\u0026amp; std::totally_ordered\u0026lt;T\u0026gt; struct rb_tree { private: enum rb_color { red, black }; // 节点颜色 struct rb_node { T key; rb_color color; // 颜色字段 unsigned size; unsigned count; rb_node *left; rb_node *right; rb_node *parent; // 父节点 rb_node(const T \u0026amp;value) : key(value), color(rb_color::red), size(1), count(1), left(nullptr), right(nullptr), parent(nullptr) {} void print_key() { std::cout \u0026lt;\u0026lt; key; if (color == rb_color::black) { std::cout \u0026lt;\u0026lt; \u0026#34;b\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;r\u0026#34;; } } }; rb_node *root; public: rb_tree() : root(nullptr) {} rb_tree(const T \u0026amp;value) : root(nullptr) { root = new rb_node(value); } rb_tree(std::initializer_list\u0026lt;T\u0026gt; list) : root(nullptr) { this-\u0026gt;insert_aux(this-\u0026gt;root, *list.begin()); std::for_each(list.begin() + 1, list.end(), [this](auto \u0026amp;\u0026amp;x) { this-\u0026gt;insert(x); }); } } 旋转 因为增加了 parent 字段用于指向当前节点的父节点，因此旋转操作也需要更新 parent 字段。\n右旋操作：\n/** * @brief LL 型旋转 * @param root 节点 */ void left_left_rotation(rb_node *root) { rb_node *parent = root-\u0026gt;parent; rb_node *child = root-\u0026gt;left; root-\u0026gt;left = child-\u0026gt;right; if (child-\u0026gt;right) { child-\u0026gt;right-\u0026gt;parent = root; } child-\u0026gt;right = root; root-\u0026gt;parent = child; if (root == this-\u0026gt;root) { this-\u0026gt;root = child; } child-\u0026gt;parent = parent; if (parent) { if (parent-\u0026gt;left == root) { parent-\u0026gt;left = child; } else { parent-\u0026gt;right = child; } } // 更新 size root-\u0026gt;size = root-\u0026gt;count + (root-\u0026gt;left ? root-\u0026gt;left-\u0026gt;size : 0) + (root-\u0026gt;right ? root-\u0026gt;right-\u0026gt;size : 0); child-\u0026gt;size = child-\u0026gt;count + (child-\u0026gt;left ? child-\u0026gt;left-\u0026gt;size : 0) + (child-\u0026gt;right ? child-\u0026gt;right-\u0026gt;size : 0); } 左旋操作：\n/** * @brief RR 型旋转 * @param root 节点 */ void right_right_rotation(rb_node *root) { rb_node *parent = root-\u0026gt;parent; rb_node *child = root-\u0026gt;right; root-\u0026gt;right = child-\u0026gt;left; if (child-\u0026gt;left) { child-\u0026gt;left-\u0026gt;parent = root; } child-\u0026gt;left = root; root-\u0026gt;parent = child; if (root == this-\u0026gt;root) { this-\u0026gt;root = child; } child-\u0026gt;parent = parent; if (parent) { if (parent-\u0026gt;left == root) { parent-\u0026gt;left = child; } else { parent-\u0026gt;right = child; } } // 更新 size root-\u0026gt;size = root-\u0026gt;count + (root-\u0026gt;left ? root-\u0026gt;left-\u0026gt;size : 0) + (root-\u0026gt;right ? root-\u0026gt;right-\u0026gt;size : 0); child-\u0026gt;size = child-\u0026gt;count + (child-\u0026gt;left ? child-\u0026gt;left-\u0026gt;size : 0) + (child-\u0026gt;right ? child-\u0026gt;right-\u0026gt;size : 0); } 插入 红黑树的插入操作与二叉搜索树相似，重点在于插入后需要根据插入节点及相关节点的颜色对树进行调整以满足红黑树的性质。根据性质 5，如果插入的节点是黑色，那么必定会破坏性质 5，所以规定插入节点的颜色为红色。\n/** * @brief 插入节点 * @param root 根节点 * @param value 权值 */ void insert_aux(rb_node *root, const T \u0026amp;value) { if (root == nullptr \u0026amp;\u0026amp; root == this-\u0026gt;root) { this-\u0026gt;root = new rb_node(value); root = this-\u0026gt;root; } else { if (root-\u0026gt;key == value) { root-\u0026gt;count++; root-\u0026gt;size++; return; } auto \u0026amp;child = root-\u0026gt;key \u0026gt; value ? root-\u0026gt;left : root-\u0026gt;right; if (child == nullptr) { child = new rb_node(value, root); root-\u0026gt;size = root-\u0026gt;count + (root-\u0026gt;left ? root-\u0026gt;left-\u0026gt;size : 0) + (root-\u0026gt;right ? root-\u0026gt;right-\u0026gt;size : 0); root = child; } else { insert_aux(child, value); } } fix_after_insertion(root); // 调整红黑树 root-\u0026gt;size = root-\u0026gt;count + (root-\u0026gt;left ? root-\u0026gt;left-\u0026gt;size : 0) + (root-\u0026gt;right ? root-\u0026gt;right-\u0026gt;size : 0); } 插入后的情况可以分成以下 5 种：\ncase 1 插入节点是根节点，将节点染为黑色即可。\ncase 2 插入节点的父节点是黑色，不需要修改。\ncase 3 插入节点的父节点是红色，叔父节点也是红色。\n此时违反了性质 4，将父节点与叔父节点染黑，祖父节点染红即可局部满足性质 4，然后视祖父节点为插入节点，继续调整红黑树。\ncase 4 插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点与父节点都是 左子节点。\n此时违反了性质 4，先对祖父节点进行一次右旋，然后将父节点染黑，原祖父节点（现在是兄弟节点）染红。\n[G] \u0026lt;P\u0026gt; [P] / \\ Right Rorate G / \\ repaint / \\ \u0026lt;P\u0026gt; [U] --------------\u0026gt; \u0026lt;N\u0026gt; [G] -----------\u0026gt; \u0026lt;N\u0026gt; \u0026lt;G\u0026gt; / \\ \\ \u0026lt;N\u0026gt; [U] [U] N: new node, P: parent node, G: grandparent node, U: uncle node \u0026lt;X\u0026gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node 该情况还有一种对称的变形，即插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点与父节点都是 右子节点。调整方法也类似，只需要对祖父节点 左旋 再染色即可。\ncase 5 插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点是 右子结点，父节点是 左子节点。\n此时对父节点进行一次 左旋 就变成了 case 4，将父节点视为插入节点继续调整红黑树即可。\n[G] [G] / \\ Left Rorate P / \\ \u0026lt;P\u0026gt; [U] --------------\u0026gt; \u0026lt;N\u0026gt; [U] \\ / \u0026lt;N\u0026gt; \u0026lt;P\u0026gt; N: new node, P: parent node, G: grandparent node, U: uncle node \u0026lt;X\u0026gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node 该情况还有一种对称的变形，即插入节点的父节点是红色，叔父节点是黑色（或是叶子结点），且插入节点是 左子结点，父节点是 右子节点。调整方法也类似，只需要对父节点 右旋 就会变成 case 4 的另一种变形。\n示例代码 /** * @brief 调整插入后红黑树 * @param root 插入节点 */ void fix_after_insertion(rb_node *root) { // case 1: 根节点 if (root == this-\u0026gt;root) { root-\u0026gt;color = rb_color::black; return; } // case 2: 父节点是黑色 if (root-\u0026gt;parent-\u0026gt;color == rb_color::black) { return; } rb_node *uncle_node = uncle(root); // case 3: 父节点与叔父节点都是红色 if (is_red(root-\u0026gt;parent) \u0026amp;\u0026amp; is_red(uncle_node)) { root-\u0026gt;parent-\u0026gt;color = rb_color::black; uncle_node-\u0026gt;color = rb_color::black; grandparent(root)-\u0026gt;color = rb_color::red; fix_after_insertion(grandparent(root)); } // case 4,5: 父节点是红色，叔父节点是黑色或空 if (is_red(root-\u0026gt;parent) \u0026amp;\u0026amp; !is_red(uncle_node)) { if (is_left_child(root) \u0026amp;\u0026amp; is_left_child(root-\u0026gt;parent)) { // case 4: // 父节点是红色，叔父节点是黑色或空， // 当前节点是左子节点，父节点是左子节点 root-\u0026gt;parent-\u0026gt;color = rb_color::black; grandparent(root)-\u0026gt;color = rb_color::red; left_left_rotation(grandparent(root)); } else if (!is_left_child(root) \u0026amp;\u0026amp; !is_left_child(root-\u0026gt;parent)) { // case 4: 对称 root-\u0026gt;parent-\u0026gt;color = rb_color::black; grandparent(root)-\u0026gt;color = rb_color::red; right_right_rotation(grandparent(root)); } else if (!is_left_child(root) \u0026amp;\u0026amp; is_left_child(root-\u0026gt;parent)) { // case 5: // 父节点是红色，叔父节点是黑色或空， // 当前节点是右子节点，父节点是左子节点 right_right_rotation(root-\u0026gt;parent); root = root-\u0026gt;left; fix_after_insertion(root); } else { // case 5: 对称 left_left_rotation(root-\u0026gt;parent); root = root-\u0026gt;right; fix_after_insertion(root); } return; } } 删除 与二叉树的删除操作类似，可以根据待删除的节点有无子节点分为以下几种情况：\ncase 1 待删除节点的左右子节点都存在。使用直接后继节点替换待删除节点（不包括颜色），然后删除直接后继节点。\ncase 2 待删除节点仅有一个子节点，那么子节点一定是红色，否则违反性质 5。直接使用子节点替换待删除节点（不包括颜色）即可。\ncase 3 待删除节点不存在子节点且该节点为红色。直接删除即可。\ncase 4 待删除节点不存在子节点且该节点为黑色。删除后会破坏性质 5，需要进行调整。若此节点为根节点，直接删除即可。\n示例代码 void remove_aux(rb_node *root, const T \u0026amp;value) { if (root == nullptr) { return; } if (root-\u0026gt;key == value) { if (root-\u0026gt;count \u0026gt; 1) { root-\u0026gt;count--; } else { if (root-\u0026gt;left \u0026amp;\u0026amp; root-\u0026gt;right) { // case 1: 左右子树存在 rb_node *successor = min_node(root-\u0026gt;right); root-\u0026gt;key = successor-\u0026gt;key; root-\u0026gt;count = successor-\u0026gt;count; successor-\u0026gt;count = 1; successor-\u0026gt;size = 0; remove_aux(root-\u0026gt;right, successor-\u0026gt;key); } else { // 至多存在一棵子树 rb_node *child = root-\u0026gt;left != nullptr ? root-\u0026gt;left : root-\u0026gt;right; rb_node *parent = root-\u0026gt;parent; // case 2: 仅存在一个子节点 if (child) { child-\u0026gt;parent = parent; // 调整待删除节点的父节点 if (parent == nullptr) { // 待删除节点是根节点 this-\u0026gt;root = child; } else if (is_left_child(root)) { parent-\u0026gt;left = child; } else { parent-\u0026gt;right = child; } child-\u0026gt;color = rb_color::black; } else if (parent == nullptr) { // case 3: 没有子树的根节点 this-\u0026gt;root = nullptr; } else { // case 3: 没有子树的黑色节点（非根节点） if (root-\u0026gt;color == rb_color::black) { root-\u0026gt;size = 0; fix_after_remove(root); } // 调整待删除节点的父节点 if (parent) { if (is_left_child(root)) { parent-\u0026gt;left = nullptr; } else { parent-\u0026gt;right = nullptr; } } } // case 4: 不存在子节点且为红色，直接删除 delete root; return; } } } else { rb_node *child = root-\u0026gt;key \u0026gt; value ? root-\u0026gt;left : root-\u0026gt;right; remove_aux(child, value); } root-\u0026gt;size = root-\u0026gt;count + (root-\u0026gt;left ? root-\u0026gt;left-\u0026gt;size : 0) + (root-\u0026gt;right ? root-\u0026gt;right-\u0026gt;size : 0); } 维护 根据上面的各种情况可以发现，只有删除 没有子节点的黑色节点（非根节点） 才会破坏红黑树的性质。\n以下情况均假设待删除节点是左子节点，对于右子节点的情况，处理方法与左子节点的情况对称。\ncase 1 待删除节点的兄弟节点是红色，那么父节点和侄子节点（兄弟节点的子节点）一定是黑色（或为空）（性质 4），删除节点可能会破坏性质 5。\n此时需要将父节点染红，将兄弟节点染黑，并对父节点进行 左旋，随后继续维护红黑树。\n[P] \u0026lt;P\u0026gt; [S] / \\ repaint / \\ Left Rorate P / \\ [N] \u0026lt;S\u0026gt; --------------\u0026gt; [N] [S] --------------\u0026gt; \u0026lt;P\u0026gt; [D] / \\ / \\ / \\ [C] [D] [C] [D] [N] [C] N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew \u0026lt;X\u0026gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node case 2 待删除的兄弟节点和侄子节点（兄弟节点的子节点）都是黑色（或为空），父节点是红色。删除节点可能会破坏性质 5。\n此时只需要将父节点染黑，兄弟节点染红即可。\n\u0026lt;P\u0026gt; [P] / \\ repaint / \\ [N] [S] --------------\u0026gt; [N] \u0026lt;S\u0026gt; / \\ / \\ [C] [D] [C] [D] N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew \u0026lt;X\u0026gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node case 3 待删除节点的兄弟节点和侄子节点（兄弟节点的子节点）都是黑色（或为空），父节点是黑色。\n将兄弟节点染红然后视父节点为待删除节点继续调整红黑树。若父节点是根节点，则不需要再调整。\n[P] [P] / \\ repaint / \\ [N] [S] --------------\u0026gt; [N] \u0026lt;S\u0026gt; / \\ / \\ [C] [D] [C] [D] N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew \u0026lt;X\u0026gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node case 4 待删除节点的兄弟节点是黑色，左侄子节点是红色，右侄子节点是黑色（或为空），父节点是黑色或红色。\n将兄弟节点染红，左侄子节点染黑，然后 右旋 兄弟节点，此时满足 case 5。\n{P} {P} {P} / \\ repaint / \\ Right Rorate S / \\ [N] [S] --------------\u0026gt; [N] \u0026lt;S\u0026gt; --------------\u0026gt; [N] [C] / \\ / \\ \\ \u0026lt;C\u0026gt; [D] [C] [D] \u0026lt;S\u0026gt; N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew \u0026lt;X\u0026gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node case 5 待删除节点的兄弟节点是黑色，左侄子节点是黑色（或为空），右侄子节点是红色，父节点是黑色或红色。\n父节点与兄弟节点交换颜色，右侄子节点染黑，左旋 父节点。\n{P} [P] {S} / \\ repaint / \\ Right Rorate S / \\ [N] [S] --------------\u0026gt; [N] {S} --------------\u0026gt; [P] [D] / \\ / \\ / \\ {C} \u0026lt;D\u0026gt; {C} [D] [N] {C} N: delete node, P: parent node, S: sibling node, C: close nephew, D: distant nephew \u0026lt;X\u0026gt;: RED node, [X]: BLACK node, {X}: either RED or BLACK node 示例代码 /** * @brief 调整红黑树 * @param root 待删除的节点 * * 因为还需要待删除节点来定位其父节点和兄弟节点等节点，所以此时调整的红黑 * 树其实是未删除节点的红黑树。 * * case a + case b = case 1 + case 2 * !case a + case b = case 2 / case 3 * !case a + !case b + case c + case d = case 4 + case 5 * !case a + !case b + !case c + case d = case 5 */ void fix_after_remove(rb_node *root) { while (root != this-\u0026gt;root \u0026amp;\u0026amp; root-\u0026gt;color == rb_color::black) { if (is_left_child(root)) { rb_node *sib = root-\u0026gt;parent-\u0026gt;right; // case a if (is_red(sib)) { sib-\u0026gt;color = rb_color::black; root-\u0026gt;parent-\u0026gt;color = rb_color::red; right_right_rotation(root-\u0026gt;parent); sib = root-\u0026gt;parent-\u0026gt;right; } // case b if (is_black(sib-\u0026gt;left) \u0026amp;\u0026amp; is_black(sib-\u0026gt;right)) { sib-\u0026gt;color = rb_color::red; root = root-\u0026gt;parent; } else { // case c if (is_black(sib-\u0026gt;right)) { sib-\u0026gt;left-\u0026gt;color = rb_color::black; sib-\u0026gt;color = rb_color::red; left_left_rotation(sib); sib = root-\u0026gt;parent-\u0026gt;right; } // case d sib-\u0026gt;color = root-\u0026gt;parent-\u0026gt;color; root-\u0026gt;parent-\u0026gt;color = rb_color::black; sib-\u0026gt;right-\u0026gt;color = rb_color::black; right_right_rotation(root-\u0026gt;parent); root = this-\u0026gt;root; } } else { rb_node *sib = root-\u0026gt;parent-\u0026gt;left; // case a if (is_red(sib)) { sib-\u0026gt;color = rb_color::black; root-\u0026gt;parent-\u0026gt;color = rb_color::red; left_left_rotation(root-\u0026gt;parent); sib = root-\u0026gt;parent-\u0026gt;left; } // case b if (is_black(sib-\u0026gt;right) \u0026amp;\u0026amp; is_black(sib-\u0026gt;left)) { sib-\u0026gt;color = rb_color::red; root = root-\u0026gt;parent; } else { // case c if (is_black(sib-\u0026gt;left)) { sib-\u0026gt;right-\u0026gt;color = rb_color::black; sib-\u0026gt;color = rb_color::red; right_right_rotation(sib); sib = root-\u0026gt;parent-\u0026gt;left; } // case d sib-\u0026gt;color = root-\u0026gt;parent-\u0026gt;color; root-\u0026gt;parent-\u0026gt;color = rb_color::black; sib-\u0026gt;left-\u0026gt;color = rb_color::black; left_left_rotation(root-\u0026gt;parent); root = this-\u0026gt;root; } } } root-\u0026gt;color = rb_color::black; } 参考资料 OI Wiki pdai tech pdai tech Open JDK Wikepadia ","permalink":"https://tpcad.github.io/posts/algorithm_rbtree/","summary":"\u003cp\u003e红黑树是一种平衡的二叉搜索树，满足如下性质：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e节点要么是 \u003cstrong\u003e黑色\u003c/strong\u003e，要么是 \u003cstrong\u003e红色\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e根节点必须是黑色\u003c/li\u003e\n\u003cli\u003e所有叶子节点都是黑色\u003c/li\u003e\n\u003cli\u003e红色节点的子节点必须是黑色\u003c/li\u003e\n\u003cli\u003e从任一节点到叶子节点的所有简单路径都包含相同数量的黑色节点\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e其中叶子节点指的是为空的节点。如下图所示，\u003ccode\u003enull\u003c/code\u003e 是叶子节点，而节点 9 和节点 20 不是叶子节点（它们的子结点也是叶子节点，图中没有画出）。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-language\" data-lang=\"language\"\u003e        10\n      /    \\\n     8      14\n    / \\    /  \\\n null  9  null 20\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"节点定义\"\u003e节点定义\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003etemplate\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#ca9ee6\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003erequires\u003c/span\u003e std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003eequality_comparable\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003etotally_ordered\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003erb_tree\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ca9ee6\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003erb_color\u003c/span\u003e { red, black }; \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 节点颜色\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003erb_node\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        T key;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        rb_color color; \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 颜色字段\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003eunsigned\u003c/span\u003e size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003eunsigned\u003c/span\u003e count;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        rb_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eleft;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        rb_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eright;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        rb_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eparent; \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 父节点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        rb_node(\u003cspan style=\"color:#ca9ee6\"\u003econst\u003c/span\u003e T \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003evalue)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e key(value), color(rb_color\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003ered), size(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e), count(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              left(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e), right(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e), parent(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003eprint_key\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e key;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ca9ee6\"\u003eif\u003c/span\u003e (color \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e==\u003c/span\u003e rb_color\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003eblack) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6d189\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            } \u003cspan style=\"color:#ca9ee6\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#a6d189\"\u003e\u0026#34;r\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    rb_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eroot;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ca9ee6\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    rb_tree() \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e root(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    rb_tree(\u003cspan style=\"color:#ca9ee6\"\u003econst\u003c/span\u003e T \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003evalue) \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e root(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) { root \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003enew\u003c/span\u003e rb_node(value); }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    rb_tree(std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003einitializer_list\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e list) \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e root(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ca9ee6\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e-\u0026gt;\u003c/span\u003einsert_aux(\u003cspan style=\"color:#ca9ee6\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e-\u0026gt;\u003c/span\u003eroot, \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003elist.begin());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003efor_each(list.begin() \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e, list.end(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                      [\u003cspan style=\"color:#ca9ee6\"\u003ethis\u003c/span\u003e](\u003cspan style=\"color:#ca9ee6\"\u003eauto\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ex) { \u003cspan style=\"color:#ca9ee6\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e-\u0026gt;\u003c/span\u003einsert(x); });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"旋转\"\u003e旋转\u003c/h2\u003e\n\u003cp\u003e因为增加了 \u003ccode\u003eparent\u003c/code\u003e 字段用于指向当前节点的父节点，因此旋转操作也需要更新 \u003ccode\u003eparent\u003c/code\u003e 字段。\u003c/p\u003e","title":"红黑树"},{"content":"平衡二叉树是一种平衡的二叉搜索树。\n空树是平衡二叉树 左右子树的高度差的绝对值不超过 1 左右子树也是平衡二叉树 AVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 平衡因子。即\n$$ 平衡因子 = 左子树的高度 - 右子树的高度 $$\n节点定义 AVL 树的节点与二叉搜索树类似，但多了一个 height 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。\nstruct avl_tree { private: struct avl_node { public: T key; unsigned size; unsigned count; unsigned height; avl_node *left; avl_node *right; avl_node(const T \u0026amp;value) : key(value), size(1), count(1), height(1), left(nullptr), right(nullptr) {} }; avl_node *root; public: avl_tree() : root(nullptr) {} avl_tree(const T \u0026amp;value) : root(nullptr) { root = new avl_node(value); } avl_tree(std::initializer_list\u0026lt;T\u0026gt; list) : root(nullptr) { root = new avl_node(*list.begin()); std::for_each(list.begin() + 1, list.end(), [this](auto \u0026amp;\u0026amp;x) { this-\u0026gt;insert(x); }); } } 平衡 旋转 旋转 是一种将节点变成它的子节点的节点的操作，可以分为 左旋 和 右旋。关于旋转方向的定义有很多，甚至有些相互矛盾。这里规定，\n左旋 指的是将一个节点变成它的右子节点的左子节点的操作，即该节点向左下方旋转，其子节点向左上方旋转，整体呈逆时针旋转。\n右旋 指的是将一个节点变成它的左子节点的右子节点的操作，即该节点向右下方旋转，其子节点向右上方旋转，整体呈顺时针旋转。\n下图是一个右旋操作，节点 6 和其左子节点 4 顺时针旋转，旋转后节点 4 的右子节点会变成节点 6 的左子节点。\n6 4 / \\ / \\ 4 7 Right Rotate 3 6 / \\ ------------\u0026gt; / / \\ 3 5 2 5 7 / 2 下图是一个左旋操作，节点 6 和其右子节点 9 逆时针旋转，旋转后节点 9 的左子节点会变成节点 6 的右子节点。\n6 9 / \\ / \\ 4 9 Left Rotate 6 10 / \\ ------------\u0026gt; / \\ \\ 8 10 4 8 11 \\ 11 在插入或删除节点时可能会导致 AVL 树不平衡，即平衡因子的绝对值大于 1，此时便需要通过 旋转 操作使二叉树再次平衡。\n失衡状态可以分为四种情况：\nLL 型 6 \u0026lt;-- h(l) - h(r) = 2 4 / \\ / \\ h(l) - h(r) = 1 --\u0026gt; 4 7 ---------\u0026gt; 3 6 / \\ / / \\ 3 5 2 5 7 / 2 以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 1，这种失衡状态称为 LL 型。对于 LL 型失衡，将其失衡根节点进行一次 右旋 即可重新平衡。\n/** * @brief 处理 LL 型失衡 * @param root 失衡节点 * @return 旋转后的根节点，即原失衡节点的左子节点 */ avl_node *left_left_rotation(avl_node *root) { avl_node *new_rt = root-\u0026gt;left; // 失衡节点的左子节点 // 失衡节点的新左子节点等于其旧左子节点的右子节点 root-\u0026gt;left = new_rt-\u0026gt;right; // 左子节点的右子节点等于失衡节点 new_rt-\u0026gt;right = root; // 更新高度 root-\u0026gt;height = std::max(height(root-\u0026gt;left), height(root-\u0026gt;right)) + 1; new_rt-\u0026gt;height = std::max(height(new_rt-\u0026gt;left), height(new_rt-\u0026gt;right)) + 1; // 返回新的根节点 return new_rt; } RR 型 6 --\u0026gt; h(l) - h(r) = -2 9 / \\ / \\ 4 9 --\u0026gt; h(l) - h(r) = -1 6 10 / \\ ------\u0026gt; / \\ \\ 8 10 4 8 11 \\ 11 以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 -1，这种失衡状态称为 RR 型。对于 RR 型失衡，将其失衡根节点进行一次 左旋 即可重新平衡。\n/** * @brief 处理 RR 型失衡 * @param root 失衡节点 * @return 旋转后的根节点，即原失衡节点的右子节点 */ avl_node *right_right_rotation(avl_node *root) { avl_node *new_rt = root-\u0026gt;right; // 失衡节点的右子节点 // 失衡节点的新右子节点等于其旧右子节点的左子节点 root-\u0026gt;right = new_rt-\u0026gt;left; // 右子节点的左子节点等于失衡节点 new_rt-\u0026gt;left = root; root-\u0026gt;height = std::max(height(root-\u0026gt;left), height(root-\u0026gt;right)) + 1; new_rt-\u0026gt;height = std::max(height(new_rt-\u0026gt;left), height(new_rt-\u0026gt;right)) + 1; return new_rt; } LR 型 6 --\u0026gt; h(l) - h(r) = 2 / \\ h(l) - h(r) = -1 \u0026lt;-- 4 7 / \\ 3 5 \\ 2 以上图为例，根节点的平衡因子等于 2，根节点的左子树的平衡因子等于 -1，这种失衡状态称为 LR 型。对于 LR 型失衡，需要一次左旋和一次右旋才能重新平衡。\n6 6 5 / \\ / \\ / \\ 4 7 5 7 4 6 / \\ / \\ / / \\ 3 5 4 2 3 2 7 \\ / 2 3 Original Left Rotate Right Rotate 第一次旋转是对失衡节点的左子节点左旋，旋转之后二叉树的失衡状态变为 LL 型。第二次旋转是对失衡节点的右旋，旋转后二叉树重新平衡。\n/** * @brief 处理 LR 型失衡 * @param root 失衡节点 * @return 旋转后的根节点 */ avl_node *left_right_rotation(avl_node *root) { // 对失衡节点的左节点左旋 root-\u0026gt;left = right_right_rotation(root-\u0026gt;left); // 对失衡节点右旋 return left_left_rotation(root); } RL 型 6 --\u0026gt; h(l) - h(r) = 2 / \\ 4 9 --\u0026gt; h(l) - h(r) = 1 / \\ 8 10 / 11 以上图为例，根节点的平衡因子等于 -2，根节点的右子树的平衡因子等于 1，这种失衡状态称为 RL 型。对于 RR 型失衡，需要一次左旋和一次右旋才能重新平衡。\n6 6 8 / \\ / \\ / \\ 4 9 4 8 6 9 / \\ / \\ / \\ \\ 8 10 11 9 4 11 10 / \\ 11 10 Original Right Rotate Left Rotate 第一次旋转是对失衡节点的右子节点右旋，旋转之后二叉树的失衡状态变为 RR 型。第二次旋转是对失衡节点的左旋，旋转后二叉树重新平衡。\n/** * @brief 处理 RL 型失衡 * @param root 失衡节点 * @return 旋转后的根节点 */ avl_node *right_left_rotation(avl_node *root) { // 对失衡节点的右节点右旋 root-\u0026gt;right = left_left_rotation(root-\u0026gt;right); // 对失衡节点左旋 return right_right_rotation(root); } 插入 AVL 树的插入操作与二叉搜索树类似，但在每次插入后都要检查当前节点是否失衡，若失衡则要进行调整。\navl_node *insert_aux(avl_node *root, const T \u0026amp;value) { if (root == nullptr) { return new avl_node(value); } if (root-\u0026gt;key == value) { root-\u0026gt;count++; } else if (root-\u0026gt;key \u0026gt; value) { root-\u0026gt;left = insert_aux(root-\u0026gt;left, value); // 检查失衡 if (height(root-\u0026gt;left) - height(root-\u0026gt;right) == 2u) { // 根据插入节点的位置判断 LL 型或 LR 型 root = (root-\u0026gt;left-\u0026gt;key \u0026gt; value) ? left_left_rotation(root) : left_right_rotation(root); } } else { root-\u0026gt;right = insert_aux(root-\u0026gt;right, value); // 检查失衡 if (height(root-\u0026gt;left) - height(root-\u0026gt;right) == -2u) { // 根据插入节点的位置判断 RR 型或 RL 型 root = (root-\u0026gt;right-\u0026gt;key \u0026gt; value) ? right_left_rotation(root) : right_right_rotation(root); } } root-\u0026gt;height = std::max(height(root-\u0026gt;left), height(root-\u0026gt;right)) + 1; root-\u0026gt;size = root-\u0026gt;count + (root-\u0026gt;left ? root-\u0026gt;left-\u0026gt;size : 0) + (root-\u0026gt;right ? root-\u0026gt;right-\u0026gt;size : 0); return root; } 删除 AVL 树的删除操作与二叉搜索树类似，但在每次删除后都要检查当前节点是否失衡，若失衡则要进行调整。\navl_node *remove_aux(avl_node *root, const T \u0026amp;value) { if (root == nullptr) { return root; } if (root-\u0026gt;key == value) { if (root-\u0026gt;count \u0026gt; 1) { root-\u0026gt;count--; } else { if (root-\u0026gt;left \u0026amp;\u0026amp; root-\u0026gt;right) { avl_node *successor = min_node(root-\u0026gt;right); root-\u0026gt;key = successor-\u0026gt;key; root-\u0026gt;count = successor-\u0026gt;count; successor-\u0026gt;count = 1; root-\u0026gt;right = remove_aux(root-\u0026gt;right, successor-\u0026gt;key); } else { avl_node *child = root-\u0026gt;left != nullptr ? root-\u0026gt;left : root-\u0026gt;right; delete root; return child; } } } else { avl_node *\u0026amp;child = root-\u0026gt;key \u0026gt; value ? root-\u0026gt;left : root-\u0026gt;right; child = remove_aux(child, value); } // 检查失衡 if (height(root-\u0026gt;left) - height(root-\u0026gt;right) == 2u) { root = (height(root-\u0026gt;left-\u0026gt;left) - height(root-\u0026gt;left-\u0026gt;right) == 1u) ? left_left_rotation(root) : left_right_rotation(root); } else if (height(root-\u0026gt;left) - height(root-\u0026gt;right) == -2u) { root = (height(root-\u0026gt;right-\u0026gt;left) - height(root-\u0026gt;right-\u0026gt;right) == 1u) ? right_left_rotation(root) : right_right_rotation(root); } root-\u0026gt;height = std::max(height(root-\u0026gt;left), height(root-\u0026gt;right)) + 1; root-\u0026gt;size = root-\u0026gt;count + (root-\u0026gt;left ? root-\u0026gt;left-\u0026gt;size : 0) + (root-\u0026gt;right ? root-\u0026gt;right-\u0026gt;size : 0); return root; } 其他操作 AVL 树的其他操作与普通的二叉搜索树相同。\n参考资料 OI Wiki pdai tech ","permalink":"https://tpcad.github.io/posts/algorithm_avltree/","summary":"\u003cp\u003e平衡二叉树是一种平衡的二叉搜索树。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e空树是平衡二叉树\u003c/li\u003e\n\u003cli\u003e左右子树的高度差的绝对值不超过 1\u003c/li\u003e\n\u003cli\u003e左右子树也是平衡二叉树\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAVL 树是一种平衡二叉树，它会在插入或删除节点时调整二叉树使每个节点的左右子树的高度差的绝对值不超过 1。通常把左右子树的差叫做 \u003cstrong\u003e平衡因子\u003c/strong\u003e。即\u003c/p\u003e\n\u003cp\u003e$$\n平衡因子 = 左子树的高度 - 右子树的高度\n$$\u003c/p\u003e\n\u003ch2 id=\"节点定义\"\u003e节点定义\u003c/h2\u003e\n\u003cp\u003eAVL 树的节点与二叉搜索树类似，但多了一个 \u003ccode\u003eheight\u003c/code\u003e 字段，用于保存当前节点的高度。规定空树的高度为 0，非空树的高度等于它的最大层次（其根节点的层次为 1，依次类推）。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003eavl_tree\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ca9ee6\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003eavl_node\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#ca9ee6\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        T key;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003eunsigned\u003c/span\u003e size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003eunsigned\u003c/span\u003e count;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003eunsigned\u003c/span\u003e height;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        avl_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eleft;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        avl_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eright;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        avl_node(\u003cspan style=\"color:#ca9ee6\"\u003econst\u003c/span\u003e T \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003evalue)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e key(value), size(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e), count(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e), height(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e), left(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              right(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    avl_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eroot;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ca9ee6\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    avl_tree() \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e root(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    avl_tree(\u003cspan style=\"color:#ca9ee6\"\u003econst\u003c/span\u003e T \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003evalue) \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e root(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) { root \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003enew\u003c/span\u003e avl_node(value); }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    avl_tree(std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003einitializer_list\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e list) \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e root(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        root \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003enew\u003c/span\u003e avl_node(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003elist.begin());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003efor_each(list.begin() \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e, list.end(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                      [\u003cspan style=\"color:#ca9ee6\"\u003ethis\u003c/span\u003e](\u003cspan style=\"color:#ca9ee6\"\u003eauto\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ex) { \u003cspan style=\"color:#ca9ee6\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e-\u0026gt;\u003c/span\u003einsert(x); });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"平衡\"\u003e平衡\u003c/h2\u003e\n\u003ch3 id=\"旋转\"\u003e旋转\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e旋转\u003c/strong\u003e 是一种将节点变成它的子节点的节点的操作，可以分为 \u003cstrong\u003e左旋\u003c/strong\u003e 和 \u003cstrong\u003e右旋\u003c/strong\u003e。关于旋转方向的定义有很多，甚至有些相互矛盾。这里规定，\u003c/p\u003e","title":"Algorithm_avltree"},{"content":"二叉搜索树（Binary Search Tree），又叫二叉排序树，二叉查找树，是一种高效的数据结构。\n二叉搜索树定义 空树是二叉搜索树 若左子树不空，则左子树上所有节点的值都 小于 根节点的值 若右子树不空，则右子树上所有节点的值都 大于 根节点的值 二叉搜索树的左右子树也是二叉搜索树 节点定义 template \u0026lt;typename T\u0026gt; struct binary_search_tree { private: struct bs_node { public: T key; unsigned int size; unsigned int count; bs_node *left; bs_node *right; bs_node(const T \u0026amp;value) : key(value), size(1), count(1), left(nullptr), right(nullptr) {} }; bs_node *root; public: binary_search_tree() : root(nullptr) {} binary_search_tree(const T \u0026amp;value) : root(nullptr) { root = new bs_node(value); } binary_search_tree(std::initializer_list\u0026lt;T\u0026gt; list) : root(nullptr) { root = new bs_node(*list.begin()); std::for_each(list.begin() + 1, list.end(), [this](auto \u0026amp;\u0026amp;x) { this-\u0026gt;insert(x); }); } 遍历二叉搜索树 根据二叉搜索树的定义，中序遍历得到的序列是升序序列。因为要遍历所有节点，所以时间复杂度为 $O(n)$。\n递归实现的中序遍历：\nvoid inorder_traversal_aux(const bs_node *root, std::vector\u0026lt;T\u0026gt; \u0026amp;result) { if (root == nullptr) { return; } inorder_traversal_aux(root-\u0026gt;left, result); for (auto i = root-\u0026gt;count; i \u0026gt; 0; --i) { result.push_back(root-\u0026gt;key); } inorder_traversal_aux(root-\u0026gt;right, result); } void inorder_traversal(std::vector\u0026lt;T\u0026gt; \u0026amp;result) { inorder_traversal_aux(root, result); } 非递归实现的中序遍历：\nvoid inorder_traversal_non_recursion(std::vector\u0026lt;T\u0026gt; \u0026amp;result) { std::stack\u0026lt;const bs_node *\u0026gt; s; const bs_node *rt = root; while (rt || s.size()) { while (rt) { s.push(rt); // 保存根节点 rt = rt-\u0026gt;left; // 遍历左子树 } rt = s.top(); // 获取保存的根节点 s.pop(); // 弹出根节点 for (auto i = rt-\u0026gt;count; i \u0026gt; 0; --i) { result.push_back(rt-\u0026gt;key); // 访问节点 } rt = rt-\u0026gt;right; // 遍历右子树 } } 搜索元素 根据二叉搜索树的特性，搜索某一个节点只需要搜索一侧子树即可，因此搜索操作的时间复杂度为 $O(h)$，h 为树高。\n递归实现：\nbool exist_aux(const bs_node *root, const T \u0026amp;value) const { if (root == nullptr) { return false; } if (root-\u0026gt;key == value) { return true; } return root-\u0026gt;key \u0026gt; value ? exist_aux(root-\u0026gt;left, value) : exist_aux(root-\u0026gt;right, value); } bool is_exist(const T \u0026amp;value) const { return exist_aux(root, value); } 非递归实现：\nbool is_exist_non_recursion(const T \u0026amp;value) const { const bs_node *rt = root; while (rt != nullptr) { if (rt-\u0026gt;key == value) { return true; } rt = rt-\u0026gt;key \u0026gt; value ? rt-\u0026gt;left : rt-\u0026gt;right; } return false; } 插入元素 与搜索元素类似，插入操作的时间复杂度为 $O(h)$。\n递归实现：\nvoid insert_aux(bs_node *root, const T \u0026amp;value) { if (root == nullptr) { return; } if (root-\u0026gt;key == value) { root-\u0026gt;count++; root-\u0026gt;size++; return; } auto \u0026amp;child = root-\u0026gt;key \u0026gt; value ? root-\u0026gt;left : root-\u0026gt;right; if (child == nullptr) { child = new bs_node(value); } else { insert_aux(child, value); } root-\u0026gt;size = root-\u0026gt;count + (root-\u0026gt;left ? root-\u0026gt;left-\u0026gt;size : 0) + (root-\u0026gt;right ? root-\u0026gt;right-\u0026gt;size : 0); } void insert(const T \u0026amp;value) { insert_aux(root, value); } 非递归实现需要借助栈来保存父节点，以便在插入后回溯修改父节点的 size 字段：\nvoid insert_non_recursion(const T \u0026amp;value) { bs_node *rt = root; std::stack\u0026lt;bs_node *\u0026gt; s; while (rt != nullptr) { if (rt-\u0026gt;key == value) { rt-\u0026gt;count++; break; } s.push(rt); // child 是引用 auto \u0026amp;child = rt-\u0026gt;key \u0026gt; value ? rt-\u0026gt;left : rt-\u0026gt;right; if (child == nullptr) { child = new bs_node(value); break; } rt = child; } // 回溯修改 size 字段 while (s.size()) { rt = s.top(); s.pop(); rt-\u0026gt;size = rt-\u0026gt;count + (rt-\u0026gt;left ? rt-\u0026gt;left-\u0026gt;size : 0) + (rt-\u0026gt;right ? rt-\u0026gt;right-\u0026gt;size : 0); } } 删除元素 对于删除操作，需要分以下情况讨论：\n待删除节点为叶子节点，直接删除即可 待删除节点有一个子节点，将当前节点替换为子节点再删除 待删除节点有两个子节点，将当前节点替换为其直接前驱或直接后继节点再删除 在递归实现中，往往将前两种情况合并，判断某一子树是否为空，若为空则返回另一子树，即使它为空。\nbinary_search_tree *remove(const T \u0026amp;value) { if (this-\u0026gt;key == value) { if (this-\u0026gt;count \u0026gt; 1) { this-\u0026gt;count--; } else { if (this-\u0026gt;left \u0026amp;\u0026amp; this-\u0026gt;right) { // 寻找右子树的最小节点 binary_search_tree *successor = this-\u0026gt;right-\u0026gt;min(); // 替换 this-\u0026gt;key = successor-\u0026gt;key; this-\u0026gt;count = successor-\u0026gt;count; // 删除直接后继节点 successor-\u0026gt;count = 1; this-\u0026gt;right = this-\u0026gt;right-\u0026gt;remove(successor-\u0026gt;key); } else { // 只存在左子树，或右子树，或都不存在 binary_search_tree *temp = (this-\u0026gt;left != nullptr) ? this-\u0026gt;left : this-\u0026gt;right; delete this; return temp; } } } else { auto \u0026amp;child = (this-\u0026gt;key \u0026gt; value) ? this-\u0026gt;left : this-\u0026gt;right; if (child != nullptr) { child = child-\u0026gt;remove(value); } } this-\u0026gt;size = this-\u0026gt;count + (this-\u0026gt;left ? this-\u0026gt;left-\u0026gt;size : 0) + (this-\u0026gt;right ? this-\u0026gt;right-\u0026gt;size : 0); return this; } 非递归实现稍显繁琐，需要记录但删除节点的父节点，寻找直接后继节点时也需要记录其父节点。同时还需要借助栈回溯父节点以修改 size 字段。\n找到待删除节点及其父节点 待删除节点左右节点都存在 寻找直接后继节点及其父节点 替换待删除节点，判断直接后继节点 若直接后继节点 是 待删除节点的子结点，使后继节点的父节点的 右节点 等于后继节点的右节点 若直接后继节点 不是 待删除节点的子结点，使后继节点的父节点的 左节点 等于后继节点的右节点 删除直接后继节点 待删除节点存在至多一个子结点 若待删除节点是根节点，直接删除，并使根节点等于其子结点 若待删除节点不是根节点，用待删除节点的子结点替代待删除节点 删除待删除节点 void remove_non_recursion(const T \u0026amp;value) { bs_node *parent = nullptr; bs_node *current = root; std::stack\u0026lt;bs_node *\u0026gt; s; while (current != nullptr \u0026amp;\u0026amp; current-\u0026gt;key != value) { s.push(current); parent = current; current = current-\u0026gt;key \u0026gt; value ? current-\u0026gt;left : current-\u0026gt;right; } // 元素不存在 if (current == nullptr) { return; } if (current-\u0026gt;count \u0026gt; 1) { current-\u0026gt;count--; } else { // 左右子树存在 if (current-\u0026gt;left \u0026amp;\u0026amp; current-\u0026gt;right) { bs_node *successor_parent = current; bs_node *successor = current-\u0026gt;right; // 寻找直接后继节点 while (successor-\u0026gt;left != nullptr) { s.push(successor); successor_parent = successor; successor = successor-\u0026gt;left; } // 替换 current-\u0026gt;key = successor-\u0026gt;key; current-\u0026gt;count = successor-\u0026gt;count; successor-\u0026gt;count = 1; // 更新后继节点的父节点，后继节点不存在左子树，最多存在一个右子树 if (successor_parent == current) { successor_parent-\u0026gt;right = successor-\u0026gt;right; } else { successor_parent-\u0026gt;left = successor-\u0026gt;right; } delete successor; } else { // 只存在左子树，或右子树，或都不存在 bs_node *child = (current-\u0026gt;left != nullptr) ? current-\u0026gt;left : current-\u0026gt;right; // 当前节点为根节点 if (parent == nullptr) { delete current; root = child; } else { // 更新父节点 if (parent-\u0026gt;left == current) { parent-\u0026gt;left = child; } else { parent-\u0026gt;right = child; } // 删除当前节点 delete current; } } } while (s.size()) { auto node = s.top(); s.pop(); node-\u0026gt;size = node-\u0026gt;count + (node-\u0026gt;left ? node-\u0026gt;left-\u0026gt;size : 0) + (node-\u0026gt;right ? node-\u0026gt;right-\u0026gt;size : 0); } } 直接前驱节点和直接后继节点 一个节点的直接前驱节点是 小于该节点的最大的节点，直接后继节点是 大于该节点的最小的节点。\nstd::expected\u0026lt;const T *, tree_error\u0026gt; predecessor(const T \u0026amp;value) const { std::stack\u0026lt;const bs_node *\u0026gt; s; const bs_node *current = root; const bs_node *prev = nullptr; while (current || s.size()) { while (current) { s.push(current); current = current-\u0026gt;left; } current = s.top(); s.pop(); // 当前节点符合条件，则父节点为直接前驱节点 if (current-\u0026gt;key == value) { return \u0026amp;prev-\u0026gt;key; } prev = current; current = current-\u0026gt;right; } return std::unexpected(tree_error::no_element); } std::expected\u0026lt;const T *, tree_error\u0026gt; successor(const T \u0026amp;value) const { std::stack\u0026lt;const bs_node *\u0026gt; s; const bs_node *current = root; const bs_node *prev = nullptr; while (current || s.size()) { while (current) { s.push(current); current = current-\u0026gt;left; } current = s.top(); s.pop(); // 父节点符合条件，则当前节点为直接后继节点 if (prev != nullptr \u0026amp;\u0026amp; prev-\u0026gt;key == value) { return \u0026amp;current-\u0026gt;key; } prev = current; current = current-\u0026gt;right; } return std::unexpected(tree_error::no_element); } 参考资料 OI Wiki pdai tech ","permalink":"https://tpcad.github.io/posts/algorithm_bstree/","summary":"\u003cp\u003e二叉搜索树（Binary Search Tree），又叫二叉排序树，二叉查找树，是一种高效的数据结构。\u003c/p\u003e\n\u003ch2 id=\"二叉搜索树定义\"\u003e二叉搜索树定义\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e空树是二叉搜索树\u003c/li\u003e\n\u003cli\u003e若左子树不空，则左子树上所有节点的值都 \u003cstrong\u003e小于\u003c/strong\u003e 根节点的值\u003c/li\u003e\n\u003cli\u003e若右子树不空，则右子树上所有节点的值都 \u003cstrong\u003e大于\u003c/strong\u003e 根节点的值\u003c/li\u003e\n\u003cli\u003e二叉搜索树的左右子树也是二叉搜索树\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"节点定义\"\u003e节点定义\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003etemplate\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#ca9ee6\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003ebinary_search_tree\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ca9ee6\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003ebs_node\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#ca9ee6\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        T key;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e count;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        bs_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eleft;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        bs_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eright;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        bs_node(\u003cspan style=\"color:#ca9ee6\"\u003econst\u003c/span\u003e T \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003evalue)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e key(value), size(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e), count(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e), left(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e), right(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    bs_node \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eroot;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ca9ee6\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    binary_search_tree() \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e root(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    binary_search_tree(\u003cspan style=\"color:#ca9ee6\"\u003econst\u003c/span\u003e T \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003evalue) \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e root(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        root \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003enew\u003c/span\u003e bs_node(value);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    binary_search_tree(std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003einitializer_list\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e list) \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e:\u003c/span\u003e root(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        root \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003enew\u003c/span\u003e bs_node(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003elist.begin());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        std\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003efor_each(list.begin() \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e, list.end(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                      [\u003cspan style=\"color:#ca9ee6\"\u003ethis\u003c/span\u003e](\u003cspan style=\"color:#ca9ee6\"\u003eauto\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ex) { \u003cspan style=\"color:#ca9ee6\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e-\u0026gt;\u003c/span\u003einsert(x); });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"遍历二叉搜索树\"\u003e遍历二叉搜索树\u003c/h2\u003e\n\u003cp\u003e根据二叉搜索树的定义，中序遍历得到的序列是升序序列。因为要遍历所有节点，所以时间复杂度为 $O(n)$。\u003c/p\u003e","title":"二叉搜索树"},{"content":"进程 进程的状态 一个进程至少有三种基本状态，即就绪、运行、阻塞状态。\nstateDiagram-v2 Ready --\u0026gt; Running Running --\u0026gt; Ready Running --\u0026gt; Blocked Blocked --\u0026gt; Ready 就绪状态（Ready）：获得时间片后即可运行 运行状态（Running）：运行状态，进程正在占用 CPU 阻塞状态（Blocked）：进程正在等待某一事件发生，即使拥有 CPU 也无法运行 三种状态之间会因为以下原因发生切换：\n就绪状态 -\u0026gt; 运行状态：被调度程序选中，获得时间片，开始运行 运行状态 -\u0026gt; 就绪状态：时间片用完 运行状态 -\u0026gt; 阻塞状态：进程请求某个事件且必须等待，如 I/O 事件 阻塞状态 -\u0026gt; 就绪状态：进程请求的事件发生 除了以上三种状态外，进程还有两种基本的状态：\n创建状态（New）：进程正在被创建时的状态 结束状态（Exit）：进程结束时的状态 此外，当进程被阻塞时，可以将该进程相关的内存换出到磁盘中，这种进程存在但没有占据实际物理内存的状态称为「挂起状态」。挂起状态又可以分为 就绪挂起状态 和 阻塞挂起状态。\n进程控制块 进程控制块（Process Control Block，PCB）是用来进程的数据结构，每个进程对应一个 PCB，PCB 是进程存在的唯一标识。\nPCB 通常包含以下信息：\n进程描述信息： 进程标识符：每个进程都有一个唯一的标识符 用户标识符：进程所属用户 进程控制、管理信息： 进程状态：进程当前状态 进程优先级：进程调度时的优先级 分配的资源 进程虚拟地址空间 进程打开的文件列表 I/O 设备 CPU 信息 寄存器的值，如 eip，esp 线程 线程 是进程当中的一条执行流程。当进程只有一个线程时，可以认为进程就是线程。\n线程与进程十分相似，同样拥有就绪、运行、阻塞等状态，也通过 TCB（Thread Control Block）描述。线程共享进程的数据段、代码段、文件等资源，只独享寄存器、栈等资源。进程是资源分配的基本单位，线程是调度的基本单位。\n线程的实现 用户线程（User Thread）：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理 内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程 轻量级进程（LightWeight Process）：在内核中来支持用户线程 ","permalink":"https://tpcad.github.io/posts/os_process_basic/","summary":"\u003ch2 id=\"进程\"\u003e进程\u003c/h2\u003e\n\u003ch3 id=\"进程的状态\"\u003e进程的状态\u003c/h3\u003e\n\u003cp\u003e一个进程至少有三种基本状态，即就绪、运行、阻塞状态。\u003c/p\u003e\n\u003cpre class=\"mermaid\"\u003estateDiagram-v2\n    Ready --\u0026gt; Running\n    Running --\u0026gt; Ready\n    Running --\u0026gt; Blocked\n    Blocked --\u0026gt; Ready\n\u003c/pre\u003e\n\n\u003col\u003e\n\u003cli\u003e就绪状态（Ready）：获得时间片后即可运行\u003c/li\u003e\n\u003cli\u003e运行状态（Running）：运行状态，进程正在占用 CPU\u003c/li\u003e\n\u003cli\u003e阻塞状态（Blocked）：进程正在等待某一事件发生，即使拥有 CPU 也无法运行\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e三种状态之间会因为以下原因发生切换：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e就绪状态 -\u0026gt; 运行状态\u003c/em\u003e：被调度程序选中，获得时间片，开始运行\u003c/li\u003e\n\u003cli\u003e\u003cem\u003e运行状态 -\u0026gt; 就绪状态\u003c/em\u003e：时间片用完\u003c/li\u003e\n\u003cli\u003e\u003cem\u003e运行状态 -\u0026gt; 阻塞状态\u003c/em\u003e：进程请求某个事件且必须等待，如 I/O 事件\u003c/li\u003e\n\u003cli\u003e\u003cem\u003e阻塞状态 -\u0026gt; 就绪状态\u003c/em\u003e：进程请求的事件发生\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e除了以上三种状态外，进程还有两种基本的状态：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建状态（New）：进程正在被创建时的状态\u003c/li\u003e\n\u003cli\u003e结束状态（Exit）：进程结束时的状态\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e此外，当进程被阻塞时，可以将该进程相关的内存换出到磁盘中，这种进程存在但没有占据实际物理内存的状态称为「挂起状态」。挂起状态又可以分为 \u003cstrong\u003e就绪挂起状态\u003c/strong\u003e 和 \u003cstrong\u003e阻塞挂起状态\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"进程控制块\"\u003e进程控制块\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e进程控制块\u003c/strong\u003e（Process Control Block，PCB）是用来进程的数据结构，每个进程对应一个 PCB，PCB 是进程存在的唯一标识。\u003c/p\u003e\n\u003cp\u003ePCB 通常包含以下信息：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e进程描述信息：\n\u003cul\u003e\n\u003cli\u003e进程标识符：每个进程都有一个唯一的标识符\u003c/li\u003e\n\u003cli\u003e用户标识符：进程所属用户\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e进程控制、管理信息：\n\u003cul\u003e\n\u003cli\u003e进程状态：进程当前状态\u003c/li\u003e\n\u003cli\u003e进程优先级：进程调度时的优先级\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e分配的资源\n\u003cul\u003e\n\u003cli\u003e进程虚拟地址空间\u003c/li\u003e\n\u003cli\u003e进程打开的文件列表\u003c/li\u003e\n\u003cli\u003eI/O 设备\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCPU 信息\n\u003cul\u003e\n\u003cli\u003e寄存器的值，如 \u003ccode\u003eeip\u003c/code\u003e，\u003ccode\u003eesp\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"线程\"\u003e线程\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e线程\u003c/strong\u003e 是进程当中的一条执行流程。当进程只有一个线程时，可以认为进程就是线程。\u003c/p\u003e\n\u003cp\u003e线程与进程十分相似，同样拥有就绪、运行、阻塞等状态，也通过 TCB（Thread Control Block）描述。线程共享进程的数据段、代码段、文件等资源，只独享寄存器、栈等资源。进程是资源分配的基本单位，线程是调度的基本单位。\u003c/p\u003e","title":"进程基础"},{"content":"为了隔离不同进程所使用的地址，操作系统为每个进程分配了一套 虚拟地址。各个进程的虚拟内存互相独立，互不干扰，同时，进程也不允许直接访问物理地址。虚拟内存可以让程序访问超出物理内存大小的地址。在 32 位处理器中，虚拟内存的大小为 4 GB（2^32）。\n分页 分页机制将虚拟内存分为一个个大小固定的单元，称为 页（Page）。同样的，也将物理内存分为一个个 页框（Page Frame）。页和页框的大小相等，通常为 4 KB。\n页表 页表 的作用是把页 映射 为页框。从数学角度说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。\n每一个进程都有自己的页表，页表也存储在内存中，是一个由页表项组成的数组。\n页表项 在 32 位操作系统中，一个页表项的大小为 4 字节。\ntypedef struct page_entry_t { u8 present : 1; // 在内存中 u8 write : 1; // 0 只读，1 可读可写 u8 user : 1; // 1 所有人，0 超级用户 DPL \u0026lt; 3 u8 pwt : 1; // page write through，1 直写模式，0 回写模式 u8 pcd : 1; // page cache disable，禁止该页缓冲 u8 accessed : 1; // 被访问过，用于统计使用频率 u8 dirty : 1; // 脏页，表示该页缓冲被写过 u8 pat : 1; // page attribute table，页大小 4K / 4M u8 global : 1; // 全局，所有进程都会用到了，该页不刷新缓冲 u8 ignored : 3; // 操作系统决定是否使用 u32 index : 20; // 页索引 } _packed page_entry_t; 地址转换 在 32 位操作系统中，虚拟内存大小为 4 GB（$2^{32}$），页面大小通常为 4 KB。由此可知，虚拟内存被划分为 1 M（$2^{20}$） 个页面。因此，32 位的虚拟地址中前 20 位表示页索引，剩下 12 位则表示页内偏移量。利用页索引在页表中查找到对应的页框号后，将其与页内偏移量相加即可得到物理地址。\n不难发现，页内偏移量的位数与页面大小有关，即当页面大小为 $2^k$ B 时，页内偏移量的位数为 k 位。\n因为页表必须覆盖整个虚拟内存，当一个页表项的大小为 4 B 时，那么页表大小则是 4 MB，若此时有 100 个进程，则需要 400 MB 的内存，这是非常大的浪费。\n多级页表 多级页表可以有效地节约内存。下面以二级页表为例。\n在 32 位操作系统中，32 位虚拟地址中，后 12 位是页内偏移地址，前 20 位中，前 10 位作为一级页号，中间 10 位作为二级页号（不一定是 10 位，在实际中也可能是其他的值）。\n在一级页表（或顶级页表）中，页表项存储的是二级页表的地址，而二级页表与单页表的页表项相同，主要存储页框号。\n因此，二级页表的寻址过程为：\n根据虚拟地址前 10 位在顶级页表中查找二级页表的地址 根据虚拟地址中间 10 位在二级页表中查找页框号 将页框号与页内偏移量相加得到物理地址 因为一级页号和二级页号的位数都是 10 位，所以一级页表和每个二级页表都有 $2^{10}$ 项，若每项大小为 4 B，则页表大小为 4 KB。\n若将所有页表都加载到内存中，二级页表所占用的总内存大小为 4 KB（一级页表）+ 4 MB（所有二级页表），反而比单页表还要大。然而，根据局部性原理，对于大部分程序来说，其使用的空间远远不到 4 GB，因此会存在许多空的页表项。对于二级页表，一级页表就已经可以完整地表示 4 GB 的虚拟地址空间，而二级页表可以在需要时才创建。如此一来，实际加载到内存的页表就只有 4 KB 的一级页表和需要用到的二级页表，最坏的情况也是加载所有的二级页表（几乎不可能），因此，二级页表可以有效地节约内存空间。\n无论是单页表还是多级页表，页表都要覆盖全部的虚拟地址空间。如果虚拟地址在页表中没有对应的页表项，计算机就不能工作了。与单页表每个页表项表示 4 KB 内存，需要 100 万个页表项相比，二级页表将页表项进行「压缩」，使一个页表项（一级页表项）可以表示 4 MB，因此只需 1024 个一级页表项就可以表示 4 GB 的虚拟内存空间。\n倒排页表 倒排页表（Inverted Page Table），也叫反置页表。在这种页表中，以页框号作为页表项的索引，页表项记录的主要内容是进程标识符和页表号。因为物理内存往往比虚拟内存要小得多，所以倒排页表的大小会比普通的单页表要小得多。\n倒排页表虽然节约了空间，但却大大增加了检索时间。寻址时，根据进程标识符和页表号检索整个倒排页表（即使页面不在内存中）。当内存容量很大时，页表项的数目还是会非常大。一种方法是采用 散列表 来进行存储。通过进程标识符和页表号计算散列值，当散列表的冲突链的平均长度为 1（即散列表的槽数与页框数相等），可以大大提高检索速度。\n因为倒排页表只记录了已经调入内存的页面的信息，因此还需要为每个进程建立一个外部页表，以记录那些未被调入内存的页面在外存中的位置。\n快表 多级页表和倒排页表解决了页表占用空间过大的问题，但地址转换所需要的时间也大大增加。根据局部性原理，可以将程序最常访问的页表项存储在一个高速缓冲中，当 CPU 寻址时优先检索该缓存。\n这种缓存称为 转换检测缓冲区（Translation Lookaside Buffer，TLB），也称 相联存储器（associate memory）或 快表。\n分段 分段机制将内存分成多个 大小不一，可以重叠 的 段（segment）。\n描述符表 描述符表是一个用于描述内存分布的 数组，数组的元素是 段描述符，一个段描述符描述一个段。x86 处理器中有两种描述符表，分别是全局描述符表（Global Descriptor Table，GDT）和局部描述符表（Local Descriptor Table，LDT）。GDT 描述系统段，包括操作系统本身，一台计算机上只有一个 GDT。LDT 描述程序的段，包括代码，数据，堆栈等，每个进程都有自己的 LDT。\n描述符表的第一项必须是全 0，且不应被使用。\ngdtr 全局描述符表寄存器（gdtr）用于存储 GDT。寄存器大小（32 位系统）是 6 字节。低 2 字节指明 GDT 的大小，也就是说 GDT 最大为 $2^{16}$ 字节。高 4 字节指明 GDT 的地址。\n相应地，LDT 被存储于 ldtr 中。\n段描述符 段描述符是描述符表的元素，用于描述一个内存中的一个段。段描述符主要存储了段的基址、限长以及一些属性位。\n段选择子 段选择子（segment selector）是一个 2 字节大小的数据结构，用于定位段描述符，通常保存在段寄存器中。段选择子的结构如下所示：\n0～1：RPL 2：0 表示全局描述符，1 表示本地描述符 3～15：GDT 索引 从其结构可以看出，索引只有 13 位，也就是说描述符表最多有 $2^{13}$ 个段描述符。\n地址转换 在寻址之前，需要先把段选择子保存到段寄存器中。根据段选择子在 GDT 或 LDT 中找到对应的段描述符，根据其中的段界限字段判断段内偏移量（即给出的虚拟地址）是否有效，若有效，则将段描述符中的段基地址与段内偏移量相加，得到物理地址。\n分段机制的问题 分段机制会带来 外部内存碎片 和 内存交换效率低 的问题。\n分段机制根据段的实际需求分配内存，因此不会出现 内部内存碎片。当内存中的一些段不再使用，被回收后，就会出现多个 不连续 的小物理内存，这就是 外部内存碎片。这会导致新的程序没有足够的空间去装载。\n为了解决外部内存碎片问题，可以把一些段先写入到硬盘，再将其读回内存，使其紧跟在其他段的后面，从而得到更大的连续内存空间。然而，读写硬盘的速度要远远慢于读写内存的速度，所以如果内存交换的是一个很大的程序，就会造成明显卡顿。\n段页式内存管理 分段和分页并不是互不兼容的，它们可以组合起来在同一系统上使用。事实上，x86 处理器上分段和分页机制同时存在。\n段页式内存管理先将程序划分成不同的段，每个段以页为基本单位进行分配。在寻址时，需要先通过描述符表找到段所对应的页表的地址，再通过页表将地址转换为物理地址。\nLinux 的内存管理 Linux 的内存管理以分页为主，最小限度地使用分段。\nLinux 将所有段的基地址设为 0，限长设为最大值。如此一来，逻辑地址就与线性地址相同了。\n其他 局部性原理 CPU 在访问内存时有明显的重复性。具体表现为 时间局部性 和 空间局部性。\n时间局部性：如果一个存储单元被访问，那么不久之后可能再次被访问 空间局部性：如果一个存储单元被访问，那么其附近的内存也将被访问 ","permalink":"https://tpcad.github.io/posts/os_virtual_memory/","summary":"\u003cp\u003e为了隔离不同进程所使用的地址，操作系统为每个进程分配了一套 \u003cstrong\u003e虚拟地址\u003c/strong\u003e。各个进程的虚拟内存互相独立，互不干扰，同时，进程也不允许直接访问物理地址。虚拟内存可以让程序访问超出物理内存大小的地址。在 32 位处理器中，虚拟内存的大小为 \u003ccode\u003e4 GB（2^32）\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"分页\"\u003e分页\u003c/h2\u003e\n\u003cp\u003e分页机制将虚拟内存分为一个个大小固定的单元，称为 \u003cstrong\u003e页（Page）\u003c/strong\u003e。同样的，也将物理内存分为一个个 \u003cstrong\u003e页框（Page Frame）\u003c/strong\u003e。页和页框的大小相等，通常为 \u003cstrong\u003e4 KB\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"页表\"\u003e页表\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e页表\u003c/strong\u003e 的作用是把页 \u003cstrong\u003e映射\u003c/strong\u003e 为页框。从数学角度说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。\u003c/p\u003e\n\u003cp\u003e每一个进程都有自己的页表，页表也存储在内存中，是一个由页表项组成的数组。\u003c/p\u003e\n\u003ch4 id=\"页表项\"\u003e页表项\u003c/h4\u003e\n\u003cp\u003e在 32 位操作系统中，一个页表项的大小为 4 字节。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e78284\"\u003epage_entry_t\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003epresent\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;  \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 在内存中\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003ewrite\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;    \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 0 只读，1 可读可写\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003euser\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;     \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 1 所有人，0 超级用户 DPL \u0026lt; 3\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003epwt\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;      \u003cspan style=\"color:#737994;font-style:italic\"\u003e// page write through，1 直写模式，0 回写模式\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003epcd\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;      \u003cspan style=\"color:#737994;font-style:italic\"\u003e// page cache disable，禁止该页缓冲\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003eaccessed\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e; \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 被访问过，用于统计使用频率\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003edirty\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;    \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 脏页，表示该页缓冲被写过\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003epat\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;      \u003cspan style=\"color:#737994;font-style:italic\"\u003e// page attribute table，页大小 4K / 4M\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003eglobal\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;   \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 全局，所有进程都会用到了，该页不刷新缓冲\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u8 \u003cspan style=\"color:#99d1db\"\u003eignored\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e3\u003c/span\u003e;  \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 操作系统决定是否使用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    u32 \u003cspan style=\"color:#99d1db\"\u003eindex\u003c/span\u003e : \u003cspan style=\"color:#ef9f76\"\u003e20\u003c/span\u003e;  \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 页索引\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e} _packed \u003cspan style=\"color:#e78284\"\u003epage_entry_t\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"地址转换\"\u003e地址转换\u003c/h4\u003e\n\u003cp\u003e在 32 位操作系统中，虚拟内存大小为 4 GB（$2^{32}$），页面大小通常为 4 KB。由此可知，虚拟内存被划分为 1 M（$2^{20}$） 个页面。因此，32 位的虚拟地址中前 20 位表示页索引，剩下 12 位则表示页内偏移量。利用页索引在页表中查找到对应的页框号后，将其与页内偏移量相加即可得到物理地址。\u003c/p\u003e","title":"虚拟内存"},{"content":"转发 指的是函数之间的参数传递。比如下面的代码，函数 foo 向函数 bar 传递了参数 a。\nfoo(int a) { bar(a) } bar(int b) {} 完美转发则是在转发过程中，参数的各种属性都保持不变。比如右值仍是右值，左值仍是左值。\n普通转发的问题 在下面的代码中，函数 pass 接受一个右值引用，并将该参数传递给函数 reference。当向 pass 传入字面量 1 时，最终的输出结果是 lvalue。这是因为虽然向 pass 传入了右值，但在函数体内，变量 x 的值类别变成了左值，即 x 的类型是右值引用，值类别是左值，所以最终会调用 reference(int \u0026amp;y)。\n这就是普通转发存在的问题，在转发过程中可能会改变参数某些属性。\n#include \u0026lt;fmt/core.h\u0026gt; void reference(int \u0026amp;\u0026amp;y) { fmt::println(\u0026#34;rvalue\u0026#34;); } void reference(int \u0026amp;y) { fmt::println(\u0026#34;lvalue\u0026#34;); } void pass(int \u0026amp;\u0026amp;x) { fmt::println(\u0026#34;general pass\u0026#34;); reference(x); } int main(int argc, char *argv[]) { pass(1); return 0; } 实现完美转发 万能引用 在普通函数中，若参数类型为 \u0026amp;\u0026amp;，则函数只能接受右值。\nvoid foo(int \u0026amp;\u0026amp;x) {} int main() { int a = 1; foo(1); // foo(a); 无法编译 } 但在模板函数中，若 \u0026amp;\u0026amp; 与模板参数结合，即 T\u0026amp;\u0026amp;，那么它将不再代表右值引用，而是万能引用。它既能接受左值，又能接受右值。\ntemplate \u0026lt;typename T\u0026gt; void foo(T \u0026amp;\u0026amp;x) { } int main(int argc, char *argv[]) { foo(1); // 传入右值 int a = 0; foo(a); // 传入左值 return 0; } 引用折叠规则 引用折叠规则是在对引用类型进行连续引用时所要遵循的规则。\n函数形参类型 实参参数类型 推导后函数形参类型 T\u0026amp; 左引用 T\u0026amp; T\u0026amp; 右引用 T\u0026amp; T\u0026amp;\u0026amp; 左引用 T\u0026amp; T\u0026amp;\u0026amp; 右引用 T\u0026amp;\u0026amp; 简而言之，当且仅当模板函数的形参与实参都是右引用时，形参才会被推导为右引用。\nstd::forward C++ 使用 std::forward 进行完美转发。std::forward 的实现如下：\n/** * @brief Forward an lvalue. * @return The parameter cast to the specified type. * * This function is used to implement \u0026#34;perfect forwarding\u0026#34;. */ template\u0026lt;typename _Tp\u0026gt; constexpr _Tp\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp; __t) noexcept { return static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t); } /** * @brief Forward an rvalue. * @return The parameter cast to the specified type. * * This function is used to implement \u0026#34;perfect forwarding\u0026#34;. */ template\u0026lt;typename _Tp\u0026gt; constexpr _Tp\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp; __t) noexcept { static_assert(!std::is_lvalue_reference\u0026lt;_Tp\u0026gt;::value, \u0026#34;template argument\u0026#34; \u0026#34; substituting _Tp is an lvalue reference type\u0026#34;); return static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t); } 其中 std::remove_reference 是一个模板类，它的实现如下：\ntemplate\u0026lt;class T\u0026gt; struct remove_reference { typedef T type; }; template\u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026gt; { typedef T type; }; template\u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; { typedef T type; }; 通过 std::remove_reference 将类型的引用去除，得到值类型。std::forward 有两个重载，分别匹配左值引用和右值引用，当匹配左值引用时，根据引用折叠规则，static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t) 返回左值引用，当匹配右值引用时，根据引用折叠规则，static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t) 返回右值引用。\n使用 std::forward #include \u0026lt;fmt/core.h\u0026gt; #include \u0026lt;utility\u0026gt; void reference(int \u0026amp;\u0026amp;x) { fmt::println(\u0026#34;rvalue\u0026#34;); } void reference(int \u0026amp;x) { fmt::println(\u0026#34;lvalue\u0026#34;); } template \u0026lt;typename T\u0026gt; void pass(T \u0026amp;\u0026amp;x) { fmt::println(\u0026#34;general pass\u0026#34;); reference(x); fmt::println(\u0026#34;forward pass\u0026#34;); reference(std::forward\u0026lt;T\u0026gt;(x)); } int main(int argc, char *argv[]) { pass(1); fmt::println(\u0026#34;===\u0026#34;); int a{1}; pass(a); return 0; } // general pass // lvalue // forward pass // rvalue // === // general pass // lvalue // forward pass // lvalue ","permalink":"https://tpcad.github.io/posts/cpp_perfect_forwarding.md/","summary":"\u003cp\u003e\u003cstrong\u003e转发\u003c/strong\u003e 指的是函数之间的参数传递。比如下面的代码，函数 \u003ccode\u003efoo\u003c/code\u003e 向函数 \u003ccode\u003ebar\u003c/code\u003e 传递了参数 \u003ccode\u003ea\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8caaee\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e a) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8caaee\"\u003ebar\u003c/span\u003e(a)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8caaee\"\u003ebar\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e b) {}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e完美转发\u003c/strong\u003e则是在转发过程中，参数的各种属性都保持不变。比如右值仍是右值，左值仍是左值。\u003c/p\u003e\n\u003ch2 id=\"普通转发的问题\"\u003e普通转发的问题\u003c/h2\u003e\n\u003cp\u003e在下面的代码中，函数 \u003ccode\u003epass\u003c/code\u003e 接受一个右值引用，并将该参数传递给函数 \u003ccode\u003ereference\u003c/code\u003e。当向 \u003ccode\u003epass\u003c/code\u003e 传入字面量 \u003ccode\u003e1\u003c/code\u003e 时，最终的输出结果是 \u003ccode\u003elvalue\u003c/code\u003e。这是因为虽然向 \u003ccode\u003epass\u003c/code\u003e 传入了右值，但在函数体内，变量 \u003ccode\u003ex\u003c/code\u003e 的值类别变成了\u003cstrong\u003e左值\u003c/strong\u003e，即 \u003ccode\u003ex\u003c/code\u003e 的类型是右值引用，值类别是左值，所以最终会调用 \u003ccode\u003ereference(int \u0026amp;y)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这就是普通转发存在的问题，在转发过程中可能会改变参数某些属性。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#737994;font-weight:bold;font-style:italic\"\u003e\u0026lt;fmt/core.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003ereference\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ey) { fmt\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#8caaee\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;rvalue\u0026#34;\u003c/span\u003e); }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003ereference\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003ey) { fmt\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#8caaee\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;lvalue\u0026#34;\u003c/span\u003e); }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003epass\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ex) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    fmt\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#8caaee\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;general pass\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8caaee\"\u003ereference\u003c/span\u003e(x);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003emain\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e argc, \u003cspan style=\"color:#e78284\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003eargv[]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8caaee\"\u003epass\u003c/span\u003e(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"实现完美转发\"\u003e实现完美转发\u003c/h2\u003e\n\u003ch3 id=\"万能引用\"\u003e万能引用\u003c/h3\u003e\n\u003cp\u003e在普通函数中，若参数类型为 \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e，则函数只能接受右值。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ex) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8caaee\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#737994;font-style:italic\"\u003e// foo(a); 无法编译\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但在模板函数中，若 \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e 与模板参数结合，即 \u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e，那么它将不再代表右值引用，而是\u003cstrong\u003e万能引用\u003c/strong\u003e。它既能接受左值，又能接受右值。\u003c/p\u003e","title":"How Perfect Forwarding Works"},{"content":"为什么需要 nullptr 在 C 中，NULL 被定义为 (void*)0 或 0。而 C++ 因为不允许直接将 void* 隐式转换到其他类型，所以在没有 nullptr 之前，C++ 的 NULL 就是 0（也可能是 0L）。这导致 0 的二义性。\n0 的二义性给函数重载带来了混乱。考虑下面的代码，如果 NULL 被定义为 0，那么 foo(NULL) 会严格匹配 foo(int)，但如果 NULL 被定义为 0，那么将不存在严格匹配，而 0L 可以同时转换为 int 和 int*，编译器无法知道应该调用哪个函数。\nvoid foo(int){} void foo(int*){} foo(0); // 调用 foo(int) foo(NULL); 为了解决这个问题，C++ 11 引入了 nullptr 关键字，用于区分空指针和 0。\n使用 nullptr nullptr 是一个纯右值，无法被 \u0026amp; 取地址，可以被隐式转换为任意的指针或成员指针类型。\nvoid foo(int){} void foo(int*){} foo(0); // 调用 foo(int) foo(nullptr); // 隐式转换到 int*，调用 foo(int*) nullptr 可以取代 NULL 的所有场景。\nint* ptr = nullptr; if (ptr == nullptr){} 理解 nullptr nullptr 的类型是 nullptr_t。下面是一个可能的实现。\nstruct nullptr_t { // 不能对 nullptr 取地址 void operator\u0026amp;() const = delete; // 隐式转换为任意类型指针 template\u0026lt;class T\u0026gt; inline operator T*() const { return 0; } // 隐式转换为任意类型成员指针 template\u0026lt;class C, class T\u0026gt; inline operator T C::*() const { return 0; } }; nullptr_t nullptr; 从上面的实现可以看出，在隐式转换到其他指针或成员指针类型时，返回的就是 0。所以尽管类型不同，但 nullptr 在数值上等于 0。\nint *p = nullptr; std::cout \u0026lt;\u0026lt; (nullptr == 0) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; (p == 0) \u0026lt;\u0026lt; std::endl; cout \u0026lt;\u0026lt; reinterpret_cast\u0026lt;long\u0026gt;(nullptr) \u0026lt;\u0026lt; endl; nullptr 的类型转换 因为可以隐式转换到任意类型的指针和成员指针，所以可以使用 static_cast 对 nullptr 进行显示转换。\nint *p; p = static_cast\u0026lt;int*\u0026gt;(nullptr); nullptr 不能使用 static_cast 显示转换到 int 等类型，除了 bool。\nstd::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(nullptr) \u0026lt;\u0026lt; std::endl; // not allowed std::cout \u0026lt;\u0026lt; static_cast\u0026lt;bool\u0026gt;(nullptr) \u0026lt;\u0026lt; std::endl; 可以使用 reinterpret_cast 显示转换 nullptr 到整数类型。\nstd::cout \u0026lt;\u0026lt; static_cast\u0026lt;long\u0026gt;(nullptr) \u0026lt;\u0026lt; std::endl; // 大小必须兼容 Reference What Exactly Nullptr Is in C++? C++11nullptr A name for the null pointer: nullptr (revision 4)\n","permalink":"https://tpcad.github.io/posts/cpp_nullptr/","summary":"\u003ch2 id=\"为什么需要-nullptr\"\u003e为什么需要 nullptr\u003c/h2\u003e\n\u003cp\u003e在 C 中，\u003ccode\u003eNULL\u003c/code\u003e 被定义为 \u003ccode\u003e(void*)0\u003c/code\u003e 或 \u003ccode\u003e0\u003c/code\u003e。而 C++ 因为不允许直接将 \u003ccode\u003evoid*\u003c/code\u003e 隐式转换到其他类型，所以在没有 \u003ccode\u003enullptr\u003c/code\u003e 之前，C++ 的 \u003ccode\u003eNULL\u003c/code\u003e 就是 0（也可能是 \u003ccode\u003e0L\u003c/code\u003e）。这导致 0 的二义性。\u003c/p\u003e\n\u003cp\u003e0 的二义性给函数重载带来了混乱。考虑下面的代码，如果 \u003ccode\u003eNULL\u003c/code\u003e 被定义为 \u003ccode\u003e0\u003c/code\u003e，那么 \u003ccode\u003efoo(NULL)\u003c/code\u003e 会严格匹配 \u003ccode\u003efoo(int)\u003c/code\u003e，但如果 \u003ccode\u003eNULL\u003c/code\u003e 被定义为 \u003ccode\u003e0\u003c/code\u003e，那么将不存在严格匹配，而 \u003ccode\u003e0L\u003c/code\u003e 可以同时转换为 \u003ccode\u003eint\u003c/code\u003e 和 \u003ccode\u003eint*\u003c/code\u003e，编译器无法知道应该调用哪个函数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e){}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003e){}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efoo(\u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e); \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 调用 foo(int)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003efoo(\u003cspan style=\"color:#99d1db\"\u003eNULL\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e为了解决这个问题，C++ 11 引入了 \u003ccode\u003enullptr\u003c/code\u003e 关键字，用于区分空指针和 \u003ccode\u003e0\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"使用-nullptr\"\u003e使用 nullptr\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003enullptr\u003c/code\u003e 是一个纯右值，无法被 \u003ccode\u003e\u0026amp;\u003c/code\u003e 取地址，可以被隐式转换为任意的指针或成员指针类型。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e){}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003e){}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efoo(\u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e); \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 调用 foo(int)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003efoo(\u003cspan style=\"color:#ca9ee6\"\u003enullptr\u003c/span\u003e); \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 隐式转换到 int*，调用 foo(int*)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003enullptr\u003c/code\u003e 可以取代 \u003ccode\u003eNULL\u003c/code\u003e 的所有场景。\u003c/p\u003e","title":"How Nullptr Works"},{"content":"Rust Iterator 可迭代对象与迭代器（Iterable and Iterator） 迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：\n记录当前的迭代状态 产生可以访问下一个元素的迭代器 可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 Vec\u0026lt;T\u0026gt; 可以通过 iter 方法获得一个迭代器，但 Vec\u0026lt;T\u0026gt; 本省不是一个迭代器。\n一个可迭代对象通常有三个方法，分别对应三种迭代类型。\niter()，迭代 \u0026amp;T iter_mut()，迭代 \u0026amp;mut T into_iter()，迭代 T Iterator Trait Rust 迭代器的核心是 Iterator trait。Iterator trait 的核心代码看起来像下面这样：\ntrait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; } 关联类型 Item 表明迭代器返回的对象，next 方法表明迭代器如何返回该对象。\n实现 Iterator Trait 遍历 \u0026amp;T 假设有以下结构体，现在需要为 Todos 实现 Iterator trait。\npub struct Todos { pub list: Vec\u0026lt;Todo\u0026gt;, } #[derive(Debug)] pub struct Todo { pub message: String, pub done: bool, } 实现 Iterator trait 的关键是记录当前的迭代状态。Todos 使用一个 Vec\u0026lt;T\u0026gt; 来进行存储，非常适合用索引来记录迭代状态。我们可以为 Todos 添加一个 index 字段来记录迭代状态。但很显然，这并不妥当。当你对 Todos 进行迭代时会修改 index 字段的值，如果想要再次进行迭代，就必须重置 index 字段，因为迭代器不会在迭代结束后重置状态。\n所以我们更倾向于只把 Todos 当作一个可迭代对象，并用一个新的数据结构来记录迭代状态。\n下面是一个名为 TodosIterator 的结构体，它两个字段，todos 是对 Todos 的不可变引用，index 是一个 usize，用于记录当前的迭代状态。接下来将为 TodosIterator 实现 Iterator trait。\npub struct TodosIterator\u0026lt;\u0026#39;a\u0026gt; { todos: \u0026amp;\u0026#39;a Todos, index: usize, } 首先指定关联类型 Item 为 \u0026amp;'a Todo，这表明这个迭代器用于迭代 \u0026amp;T。\n接着实现 next 方法。通过比较当前 index 的值与 Vec 的长度判断是否迭代结束。若否，index 字段加 1，并返回当前索引对应的 Some(\u0026amp;Todo)。\nimpl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.index \u0026lt; self.todos.list.len() { let result = Some(\u0026amp;self.todos.list[self.index]); self.index += 1; result } else { None } } } 现在我们还需要为 Todos 实现一个用于产生迭代器的方法，使其成为可迭代对象。对于迭代 \u0026amp;T 的迭代器，这个方法通常是 iter()。\nimpl Todos { pub fn iter(\u0026amp;self) -\u0026gt; TodosIterator { TodosIterator { todos: self, index: 0, } } } 现在可以通过 iter 方法在 for 循环中迭代 Todos 了。\nfn main() { let todos = Todos { list: vec![ Todo { message: \u0026#34;Hello\u0026#34;.to_string(), done: false, }, Todo { message: \u0026#34;Rust\u0026#34;.to_string(), done: false, }, Todo { message: \u0026#34;World\u0026#34;.to_string(), done: false, }, ], }; for todo in todos.iter() { println!(\u0026#34;{todo:#?}\u0026#34;) } } IntoIterator Trait IntoIterator trait 的核心代码看起来像下面这样。它有一个 into_iter 方法，用于产生一个拥有对象所有权的迭代器。\n关联类型 Item 与 Iterator 的 Item 相同，IntoIter 是一个实现了 Iterator trait 的类型。 方法 into_iter 会获取对象的所有权，并返回 IntoIter。\npub trait IntoIterator { type Item; type IntoIter: Iterator\u0026lt;Item = Self::Item\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter; } Rust 在标准库中为所有实现了 Iterator trait 的类型实现了 IntoIterator。\nimpl\u0026lt;I: Iterator\u0026gt; IntoIterator for I 实现 IntoIterator Trait 遍历 T 因为 IntoIterator 会获取对象的所有权，所以不能继续使用 TodosIterator 来实现。我们使用一个新的结构体来实现。\npub struct TodosIntoIterator { todos: Todos, } 接着为 Todos 实现 IntoIterator。将关联类型 IntoIter 指定为 TodosIntoIterator，并在 into_iter 方法中返回一个 TodosIntoIterator。\nimpl IntoIterator for Todos { type Item = Todo; type IntoIter = TodosIntoIterator; fn into_iter(self) -\u0026gt; Self::IntoIter { TodosIntoIterator { todos: self } } } 因为 IntoIter 是一个实现了 Iterator trait 的类型，所以我们需要为 TodosIntoIterator 实现 Iterator trait。\n因为 TodosIntoIterator 拥有所有权，所以这里在每次迭代中删除 Vec 的第一个元素，这样迭代器总是指向这个元素。同时以 Vec 为空为迭代结束条件。\nimpl Iterator for TodosIntoIterator { type Item = Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.todos.list.is_empty() { return None; } let result = self.todos.list.remove(0); Some(result) } } 如此一来便能在 for 循环中遍历 todos 并获得其所有权。\nfor todo in todos { println!(\u0026#34;{todo:#?}\u0026#34;) } 实现 Iterator Trait 遍历 \u0026amp;mut T 要实现遍历 \u0026amp;mut T 的 Iterator trait 并不容易。\n若仿照 \u0026amp;T 来实现 \u0026amp;mut T，编译器会抱怨生命周期太短。\nimpl Todos { pub fn iter_mut(\u0026amp;mut self) -\u0026gt; TodosMutIterator { TodosMutIterator { todos: self, index: 0, } } } pub struct TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { todos: \u0026amp;\u0026#39;a mut Todos, index: usize, } impl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a mut Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.index \u0026lt; self.todos.list.len() { let result = Some(\u0026amp;mut self.todos.list[self.index]); self.index += 1; result } else { None } } } // error: lifetime may not live long enough // --\u0026gt; src/main.rs:87:13 // | // 81 | impl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { // | -- lifetime `\u0026#39;a` defined here // 82 | type Item = \u0026amp;\u0026#39;a mut Todo; // 83 | fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { // | - let\u0026#39;s call the lifetime of this reference `\u0026#39;1` // ... // 87 | result // | ^^^^^^ method was supposed to return data with lifetime `\u0026#39;a` but it is returning da // ta with lifetime `\u0026#39;1` iter_mut 方法通常用于返回一个可以遍历 \u0026amp;mut T 的迭代器。显然，迭代器只要能访问元素，并记录迭代状态就行了。因此我们可以借助 Vec 来实现 iter_mut 方法。\n创建一个类型为 Vec\u0026lt;\u0026amp;mut Todo\u0026gt; 的 Vec，并获取 Todos 的 Vec 的元素的可变引用，也就是 \u0026amp;mut Todo。最后对新的 Vec 调用方法 into_iter，返回一个可以以可变引用访问元素的迭代器。\n这样虽然不再需要额外的结构体，但每次遍历都需要创建一个新的 Vec。\nimpl Todos { pub fn iter_mut(\u0026amp;mut self) -\u0026gt; std::vec::IntoIter\u0026lt;\u0026amp;mut Todo\u0026gt; { let mut v: Vec\u0026lt;\u0026amp;mut Todo\u0026gt; = vec![]; for todo in self.list.iter_mut() { v.push(todo) } v.into_iter() } } 实现 IntoIterator Trait 遍历 \u0026amp;T 和 \u0026amp;mut T 只需要为对应的类型实现 IntoIterator trait，into_iter 方法就可以根据上下文返回遍历 \u0026amp;T、\u0026amp;mut T 或 T 的迭代器。\nimpl\u0026lt;\u0026#39;a\u0026gt; IntoIterator for \u0026amp;\u0026#39;a Todos { type Item = \u0026amp;\u0026#39;a Todo; type IntoIter = TodosIterator\u0026lt;\u0026#39;a\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter { self.iter() } } impl\u0026lt;\u0026#39;a\u0026gt; IntoIterator for \u0026amp;\u0026#39;a mut Todos { type Item = \u0026amp;\u0026#39;a mut Todo; type IntoIter = std::vec::IntoIter\u0026lt;\u0026amp;\u0026#39;a mut Todo\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter { self.iter_mut() } } 解引用裸指针实现 Iterator Trait 遍历 \u0026amp;mut T 此前编译器抱怨生命周期太短，可以通过解引用裸指针解决。\n这样做的本质是将变量的生命周期变为 'static。将一个值转化为原始指针后，它的生命周期信息会被丢弃，再次引用原始指针则会赋予静态生命周期。静态生命周期存活时间非常长，这样做会带来一些潜在的安全风险。\npub struct TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { todos: \u0026amp;\u0026#39;a mut Todos, index: usize, } impl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a mut Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.index \u0026lt; self.todos.list.len() { // 解引用裸指针 let result = unsafe { \u0026amp;mut *(\u0026amp;mut self.todos.list[self.index] as *mut _) }; self.index += 1; Some(result) } else { None } } } 如下代码所示，变量 a 是一个引用，它会指向 s1 或 s2 所指向的内容，而 s1 和 s2 在离开其作用域后会被清理，因为 a 拥有静态生命周期，所以它在离开作用域后仍能使用，而它所指向的内容已经被释放，这会导致访问到完全随机的数据。\nfn main() { let a; { let mut v1 = vec![2, 3]; let s1 = \u0026amp;mut v1; let mut v2 = vec![1, 8]; let s2 = \u0026amp;mut v2; a = test(s1, s2); } println!(\u0026#34;{a:?}\u0026#34;) } fn test\u0026lt;\u0026#39;a\u0026gt;(s1: \u0026amp;mut Vec\u0026lt;i32\u0026gt;, s2: \u0026amp;mut Vec\u0026lt;i32\u0026gt;) -\u0026gt; \u0026amp;\u0026#39;a mut Vec\u0026lt;i32\u0026gt; { let i = 2; if i == 1 { unsafe { \u0026amp;mut *(s1 as *mut _) } } else { unsafe { \u0026amp;mut *(s2 as *mut _) } } } // 一种可能的结果 // [-502036575, 23992] 参考资料 Effectively Using Iterators In Rust How do I create mutable iterator over struct fields Implementing Iterator and IntoIterator in Rust Does dereferencing a raw pointer back to a reference change the lifetime of the reference? Module std::iter ","permalink":"https://tpcad.github.io/posts/rust_iterator/","summary":"\u003ch1 id=\"rust-iterator\"\u003eRust Iterator\u003c/h1\u003e\n\u003ch2 id=\"可迭代对象与迭代器iterable-and-iterator\"\u003e可迭代对象与迭代器（Iterable and Iterator）\u003c/h2\u003e\n\u003cp\u003e迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e记录当前的迭代状态\u003c/li\u003e\n\u003cli\u003e产生可以访问下一个元素的迭代器\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 \u003ccode\u003eVec\u0026lt;T\u0026gt;\u003c/code\u003e 可以通过 \u003ccode\u003eiter\u003c/code\u003e 方法获得一个迭代器，但 \u003ccode\u003eVec\u0026lt;T\u0026gt;\u003c/code\u003e 本省不是一个迭代器。\u003c/p\u003e\n\u003cp\u003e一个可迭代对象通常有三个方法，分别对应三种迭代类型。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eiter()\u003c/code\u003e，迭代 \u003ccode\u003e\u0026amp;T\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eiter_mut()\u003c/code\u003e，迭代 \u003ccode\u003e\u0026amp;mut T\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einto_iter()\u003c/code\u003e，迭代 \u003ccode\u003eT\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"iterator-trait\"\u003eIterator Trait\u003c/h2\u003e\n\u003cp\u003eRust 迭代器的核心是 \u003ccode\u003eIterator\u003c/code\u003e trait。\u003ccode\u003eIterator\u003c/code\u003e trait 的核心代码看起来像下面这样：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003etrait\u003c/span\u003e \u003cspan style=\"color:#99d1db\"\u003eIterator\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003eItem\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003enext\u003c/span\u003e(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#ca9ee6\"\u003emut\u003c/span\u003e \u003cspan style=\"color:#99d1db\"\u003eself\u003c/span\u003e) -\u0026gt; \u003cspan style=\"color:#99d1db\"\u003eOption\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#99d1db\"\u003eSelf\u003c/span\u003e::Item\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e关联类型 \u003ccode\u003eItem\u003c/code\u003e 表明迭代器返回的对象，\u003ccode\u003enext\u003c/code\u003e 方法表明迭代器如何返回该对象。\u003c/p\u003e\n\u003ch3 id=\"实现-iterator-trait-遍历-t\"\u003e实现 Iterator Trait 遍历 \u0026amp;T\u003c/h3\u003e\n\u003cp\u003e假设有以下结构体，现在需要为 \u003ccode\u003eTodos\u003c/code\u003e 实现 \u003ccode\u003eIterator\u003c/code\u003e trait。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003epub\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003eTodos\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003epub\u003c/span\u003e list: \u003cspan style=\"color:#99d1db\"\u003eVec\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003eTodo\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e#[derive(Debug)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003epub\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003eTodo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003epub\u003c/span\u003e message: \u003cspan style=\"color:#99d1db\"\u003eString\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003epub\u003c/span\u003e done: \u003cspan style=\"color:#e78284\"\u003ebool\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e实现 \u003ccode\u003eIterator\u003c/code\u003e trait 的关键是记录当前的迭代状态。\u003ccode\u003eTodos\u003c/code\u003e 使用一个 \u003ccode\u003eVec\u0026lt;T\u0026gt;\u003c/code\u003e 来进行存储，非常适合用索引来记录迭代状态。我们可以为 \u003ccode\u003eTodos\u003c/code\u003e 添加一个 \u003ccode\u003eindex\u003c/code\u003e 字段来记录迭代状态。但很显然，这并不妥当。当你对 \u003ccode\u003eTodos\u003c/code\u003e 进行迭代时会修改 \u003ccode\u003eindex\u003c/code\u003e 字段的值，如果想要再次进行迭代，就必须重置 \u003ccode\u003eindex\u003c/code\u003e 字段，因为迭代器不会在迭代结束后重置状态。\u003c/p\u003e","title":"Rust Iterator"},{"content":"TCP 首部 --- title: \u0026#34;TCP Packet\u0026#34; --- packet-beta 0-15: \u0026#34;源端口号\u0026#34; 16-31: \u0026#34;目的端口号\u0026#34; 32-63: \u0026#34;序列号\u0026#34; 64-95: \u0026#34;确认应答号\u0026#34; 96-99: \u0026#34;数据偏移量\u0026#34; 100-105: \u0026#34;保留\u0026#34; 106: \u0026#34;URG\u0026#34; 107: \u0026#34;ACK\u0026#34; 108: \u0026#34;PSH\u0026#34; 109: \u0026#34;RST\u0026#34; 110: \u0026#34;SYN\u0026#34; 111: \u0026#34;FIN\u0026#34; 112-127: \u0026#34;窗口\u0026#34; 128-143: \u0026#34;校验和\u0026#34; 144-159: \u0026#34;紧急指针\u0026#34; 160-191: \u0026#34;选项（长度可变）\u0026#34; 序列号：TCP 是面向字节流的，其传输的每一个数据字节都对应一个序列号。序列号的初始值是一个随机数，每发送一次 TCP 报文序列号都会累加一次报文的数据字节数\n确认应答号：下一次期望收到的数据的序列号\n数据偏移量：数据部分的偏移量，也就是首部的长度。单位为 4 字节。因此 TCP 首部最长为 $(2^4-1)*4=60$ 字节。\n控制位：\nACK：该位为 1 时表示确认应答字段有效，除最初建立连接时的 SYN 包外该位必须置 1 RST：该位为 1 时表示 TCP 连接出现异常必须强制断开连接 SYN：该位为 1 时表示希望建立 TCP 连接，并在其序列号字段确定序列号初始值 FIN：该位为 1 时表示今后不会再有数据发送，希望断开 TCP 连接 TCP 连接 三次握手 建立一个 TCP 连接需要经过三次握手过程。\nsequenceDiagram participant Client participant Server Client-\u0026gt;\u0026gt;Server: SYN (SEQ=client_seq) Server--\u0026gt;\u0026gt;Client: SYN-ACK (SEQ=server_seq, ACK=client_seq+1) Client-\u0026gt;\u0026gt;Server: ACK (SEQ=client_seq+1, ACK=server_seq+1) 第一次握手：SYN 报文 客户端将 SYN 字段置为 1，表示希望建立连接，并随机初始化序列号，该报文 不包含数据。之后客户端进入 SYN-SENT 状态。 第二次握手：SYN-ACK 报文 服务端收到客户端的 SYN 报文后，也随机初始化自己的序列号，并将 client_seq+1 作为确认应答号，同时将 SYN 和 ACK 字段置为 1。该报文 不包含数据。之后服务端进入 SYN-RCVD 状态。 第三次握手：ACK 报文 客户端收到服务端的报文后，向服务端发送 ACK 报文。该报文的序列号为 client_seq+1，确认应答号为 server_seq+1，ACK 字段置为 1。该报文 可以包含数据。之后客户端进入 ESTABLISHED 状态。 服务端收到 ACK 报文后也会进入 ESTABLISHED 状态，此时连接成功建立。 四次挥手 关闭一个 TCP 连接需要经过三次挥手过程。\nsequenceDiagram participant Client participant Server Client-\u0026gt;\u0026gt;Server: FIN (SEQ=x) Server--\u0026gt;\u0026gt;Client: ACK (SEQ=y, ACK=x+1) Server-\u0026gt;\u0026gt;Client: Data Server-\u0026gt;\u0026gt;Client: FIN (SEQ=w, ACK=x+1) Client--\u0026gt;\u0026gt;Server: ACK (SEQ=x+1, ACK=w+1) 第一次挥手：客户端 FIN 报文 客户端向服务端发送 FIN 字段为 1 的报文，表示关闭 TCP 连接，客户端进入 FIN_WAIT_1 状态，不再向服务端发送数据。 第二次挥手：服务端 ACK 报文 服务端接收到客户端的 FIN 报文后发送 ACK 报文，服务端进入 CLOSE_WAIT 状态。此时服务端仍能向客户端发送数据。 客户端接收到该 ACK 报文后进入 FIN_WAIT_2 状态。 第三次挥手：服务端 FIN 报文 服务端向客户端发送 FIN 字段为 1 的报文，表示关闭 TCP 连接，服务端进入 LAST_ACK 状态，不再向客户端发送数据。 第四次挥手：服务端 ACK 报文 客户端接收到服务端的 FIN 报文后发送 ACK 报文，客户端进入 TIME_WAIT 状态。客户端在经过 2MSL 时间后，自动进入 CLOSE 状态，完成关闭。 服务端接收到 ACK 报文后进入 CLOSE 状态，完成关闭。 重传 重传 是 TCP 实现可靠传输的方式之一。发送端的数据到达接收端后，接收端会回复一个确认报文，表示已收到。在错综复杂的网络中，数据可能在传输过程中丢失，因此需要重新传输丢失的数据。数据丢失有两种情况：\n数据报文丢失（接收端没有收到数据报文） 确认报文丢失（发送端没有收到确认报文） 超时重传 每一个数据报发送时都会设置一个定时器，若超过指定时间没有收到确认报文，就会重发该数据。这就是 超时重传。\n超时重传的时间通常略大于往返时延（详情见处）。\n若超时重传的数据超时，TCP 采取 超时间隔加倍 策略。也就是说，每遇到一次超时，下一次超时重传的时间都是上次的两倍。\n超时重传存在等待时间过长的问题。\n快速重传 快速重传 可以有效解决 超时重传 时间过长的问题。\n假设发送端向接收端发送 6 个数据报，它们的序列号分别为：Seq1、Seq2、Seq3、Seq4、Seq5。其中序列号为 Seq2 的数据报丢失，接收端收到 Seq1 后回复 ACK 报文，收到 Seq3 及其后的数据报时，因为 Seq2 丢失（接收端没有收到），回复了 3 个相同的 ACK 报文（确认应答号均为 Seq2）。\n收到三个相同的 ACK 报文后，发送端会在定时器过期之前重发对应的数据，这就是 快速重传。\n最后接收端收到了 Seq2，于是 ACK 报文的确认应答号为 Seq6。\n对于上面单个数据报丢失的情况，快速重传的等待时间较短，但若出现多个数据报丢失，后面的数据报必须在前面的数据报被接收后才能触发快速重传，这又会增加重传的等待时间。如果全部重传后面的数据，那么已接收的数据就被浪费了。\nSACK 选择性确认 （Selective Acknowledge，SACK）可以将已收到的数据告诉发送端，从而可以只重传丢失的数据。\nsequenceDiagram participant Sender participant Receiver Sender-\u0026gt;\u0026gt;Receiver: 100~199 Receiver--\u0026gt;\u0026gt;Sender: ACK=200 Sender-\u0026gt;\u0026gt;Receiver: 200~299 (lost) Sender-\u0026gt;\u0026gt;Receiver: 300~399 Receiver--\u0026gt;\u0026gt;Sender: ACK=200, SACK: 300~400 Sender-\u0026gt;\u0026gt;Receiver: 400~499 Receiver--\u0026gt;\u0026gt;Sender: ACK=200, SACK: 300~500 Sender-\u0026gt;\u0026gt;Receiver: 500~599 Receiver--\u0026gt;\u0026gt;Sender: ACK=200, SACK: 300~600 Sender-\u0026gt;\u0026gt;Receiver: 200~299 Receiver--\u0026gt;\u0026gt;Sender: ACK=600 当接收端收到乱序的数据报时（序列号比确认号大）会在 ACK 报文中加上 SACK 选项以告知发送端已接收的部分。发送端在触发快速重传时根据确认号和 SACK 选项得知丢失的数据部分并重传该部分。\nSACK 选项 SACK 选项包含两个选项。\nSACK-Permitted 选项 该选项只能出现在 SYN 报文中，在连接建立时告知对方自己支持 SACK。选项格式如下： --- title: \u0026#34;SACK-Permitted\u0026#34; --- packet-beta 0-8: \u0026#34;Kind=4\u0026#34; 9-15: \u0026#34;Length=2\u0026#34; SACK 选项 该选项通过范围表示已经接收到的数据，不连续的部分就是丢失的数据。 --- title: \u0026#34;SACK\u0026#34; --- packet-beta 0-8: \u0026#34;Padding\u0026#34; 9-15: \u0026#34;Padding\u0026#34; 16-23: \u0026#34;Kind=5\u0026#34; 24-31: \u0026#34;Length=variable\u0026#34; 32-63: \u0026#34;Left Edge of 1st Block\u0026#34; 64-95: \u0026#34;Right Edge of 1st Block\u0026#34; 96-223: \u0026#34;...\u0026#34; 224-255: \u0026#34;Left Edge of 4th Block\u0026#34; 256-287: \u0026#34;Right Edge of 4th Block\u0026#34; D-SACK Duplicate SACK 又称 D-SACK，其主要使用 SACK 来告诉发送方有哪些数据被重复接收了。\n流量控制 在通信过程中，发送方不能无脑地向接收方发送数据，接收方可能无法及时处理数据而丢失数据，从而触发发送方的重传导致浪费网络流量。\n因此，TCP 提供了一种可以让发送方根据接收方的实际接收能力控制发送的数据量的机制，也就是 流量控制。\n累计应答 发送方收到确认报文后就可以认为该确认号之前的数据已全部被接收，即使没有收到前面的数据的确认报文。\n滑动窗口 接收窗口：接收端处理数据的能力，通过 TCP 首部的 Window 字段告知 发送窗口：控制发送端发送数据，约等于 接收窗口 窗口并不是一成不变的，而是会根据当前的应用、系统运行情况，网络状况等动态地变化，变化会通过首部的 Window 字段告知对端。\n发送端的窗口 |30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55| ^ ^ | send window(20 bytes) | ^ ^ |free window(6)| | #1 | #2 | #3 | #4 | #1：已发送且已确认的数据 #2：已发送但未确认的数据 #3：未发送但可发送的数据 #4：未发送且不可发送的数据 当可发送数据全部发送之后，可用窗口变为 0，表示接收端已经达到最大处理能力，不应再向其发送数据。\n|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55| ^ ^ | send window(20 bytes) | | #1 | #2 | #3 | 当收到确认报文后，窗口就会向右 滑动，从而可用窗口不为 0，可以继续发送数据。\n|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55| ^ ^ | send window(20 bytes) | ^ ^ |free | | #1 | #2 | #3 | #4 | 可用窗口的计算公式为：\n可用窗口 = 窗口大小 - (可发送的第一字节 - 已发送未确认的第一字节) 不可发送的第一字节 = 已发送未确认的第一字节 + 窗口大小 接收端的窗口 接收端的窗口相对简单，没有可用窗口的概念。\n|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55| ^ ^ | send window(20 bytes) | | #1 | #2 | #3 | 窗口大小 TCP 首部的 Window 字段只有 16 位，最大表示 65535 字节。窗口缩放选项可以突破这个限制。\nWindow Scale option (WSopt): Kind: 3, Length: 3 +---------+---------+---------+ | Kind=3 |Length=3 |shift.cnt| +---------+---------+---------+ 1 1 1 窗口缩放选项只能在 SYN 报文中确认且必须双方都启用才能生效，缩放因子确认后就不能再更改。之后的报文必须都包含窗口缩放选项。缩放因子最大有效值为 14。窗口大小的计算公式如下：\n$$ Size = Window * 2^{Scale} $$\n窗口关闭 当接收端发送 Window=0 的报文时，发送端就会停止发送数据，直到再次收到窗口值为非 0 的报文。此时若接收端的窗口非 0 报文丢失则可能会造成死锁。为了避免死锁，TCP 在收到零窗口通知时会启动 持续计时器。如果计时器超时，就会发送 窗口探测报文，对方在确认该报文时会给出新的窗口大小。如果新窗口仍为 0 则会重新启动持续计时器。一定次数后若窗口仍为 0，那么 TCP 将强制中断连接。\n糊涂窗口综合征 如果接收端的数据处理速度太慢，会导致发送端的发送窗口越来越小。到最后，只要接收端能够接收数据，发送端都会发送数据，哪怕只有几字节，这就是 糊涂窗口综合征。\n糊涂窗口综合征发生的条件有两个：\n接收端可以通告小窗口 发送端可以发送小数据 于是，避免出现以上两种情况便能避免糊涂窗口综合征。\n针对条件 1，可以让窗口大小小于 min(MSS, 缓存空间/2) 时发送零窗口通知，阻止发送端继续发送数据，等待接收端处理一些数据后再打开窗口。\n针对条件 2，发送端使用 Nagle 算法，只有满足以下 任一 条件时才发送数据：\n窗口大小大于或等于 MSS 并且数据大小大于或等于 MSS 收到之前发送数据的确认报文 if 有数据要发送 { if 可用窗口大小 \u0026gt;= MSS \u0026amp;\u0026amp; 可发送的数据 \u0026gt;= MSS { 立刻发送MSS大小的数据 } else { if 有未确认的数据 { 将数据放入缓存等待接收 ACK } else { 立刻发送数据 } } } 如果接收端可以通告小窗口，那么即使开启 Nagle 算法也无法避免糊涂窗口综合征。因为如果对端确认报文回复得快的话（满足 Nagle 算法条件 2），Nagle 算法就无法等到数据足够多时再进行传输。\n因此，接收端不通告小窗口且发送端开启 Nagle 算法才可以避免糊涂窗口综合征。\n拥塞控制 流量控制可以避免发送端的数据填满接收端的缓存，但并不考虑网络的拥塞状况。当网络拥堵时，如果继续发送大量数据会造成数据包丢失等情况，此时，TCP 会开始重传数据，这样会进一步加剧网络拥堵，从而陷入恶性循环。\n为此，TCP 引入了 拥塞控制，避免发送端的数据填满网络。\n拥塞窗口 拥塞窗口 是发送端维护的一个变量，它会根据网络的拥塞程度动态变化。\n加入拥塞窗口后，发送窗口 的大小为 min(拥塞窗口, 接收窗口)。\n当网络没有出现拥塞时，拥塞窗口会增大，当出现拥塞时，拥塞窗口就会减小。TCP 通过超时重传判断网络是否出现拥塞。\n慢启动 慢启动的核心规则是：每收到一个 ACK，拥塞窗口就会加 1。\n假设拥塞窗口 cwnd 初始值为 1 个 MSS，\n连接建立后，发送端发送 cwnd 字节数据 收到 ACK 后，cwnd 加 1，变为 2 个 MSS，继续发送数据 收到 2 个 ACK 后，cwnd 加 2，变为 4 个 MSS，继续发送数据 …… 由此可见，每一轮 RTT 后，cwnd 变为原来的两倍，在慢启动阶段，拥塞窗口呈指数增长。\n当 cwnd 大于慢开始门限 ssthresh 后，就会进入 拥塞避免 阶段。\n拥塞避免 慢启动的核心规则是：每收到一个 ACK，拥塞窗口就会增加 1/cwnd。\n假设此时拥塞窗口 cwnd 为 8 个 MSS，\n发送端发送 8 个长度为 MSS 的数据报 收到 8个 ACK 后，cwnd 加 1，变为 9 个 MSS，继续发送数据 收到 9 个 ACK 后，cwnd 加 1，变为 10 个 MSS，继续发送数据 …… 由此可见，每一轮 RTT 后，cwnd 加 1，在拥塞避免阶段，拥塞窗口呈线性增长。\n拥塞发生 随着拥塞窗口的增加，拥塞不可避免地发生，TCP 通过是否发生重传来判断拥塞情况。\n超时重传 发生超时重传时，TCP 会先将 ssthresh 设为 cwnd/2，并将 cwnd 重置为初始值，然后进入慢启动。\n快速重传 当发生快速重传时，TCP 会先将 cwnd 设为 cwnd/2，并将 ssthresh 设为 cwnd，然后执行 快速恢复 算法。\n快速恢复算法如下：\ncwnd = ssthresh + 3。3 表示收到的三个重复的 ACK 重传数据报 每收到一个同样的 ACK，cwnd 加 1，每 3 个相同的 ACK 触发一次快速重传 重复 3 直至收到新的 ACK。收到新的 ACK 后将 cwnd 设为 ssthresh 并进入拥塞避免阶段 快速重传是为了尽快将丢失的数据发送给对方，所以在收到相同的 ACK 后 cwnd 会加 1 以加快从对端获得 ACK 的速度。\n","permalink":"https://tpcad.github.io/posts/net_tcp/","summary":"\u003ch2 id=\"tcp-首部\"\u003eTCP 首部\u003c/h2\u003e\n\u003cpre class=\"mermaid\"\u003e---\ntitle: \u0026#34;TCP Packet\u0026#34;\n---\npacket-beta\n0-15: \u0026#34;源端口号\u0026#34;\n16-31: \u0026#34;目的端口号\u0026#34;\n32-63: \u0026#34;序列号\u0026#34;\n64-95: \u0026#34;确认应答号\u0026#34;\n96-99: \u0026#34;数据偏移量\u0026#34;\n100-105: \u0026#34;保留\u0026#34;\n106: \u0026#34;URG\u0026#34;\n107: \u0026#34;ACK\u0026#34;\n108: \u0026#34;PSH\u0026#34;\n109: \u0026#34;RST\u0026#34;\n110: \u0026#34;SYN\u0026#34;\n111: \u0026#34;FIN\u0026#34;\n112-127: \u0026#34;窗口\u0026#34;\n128-143: \u0026#34;校验和\u0026#34;\n144-159: \u0026#34;紧急指针\u0026#34;\n160-191: \u0026#34;选项（长度可变）\u0026#34;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e序列号\u003c/strong\u003e：TCP 是面向字节流的，其传输的每一个数据字节都对应一个序列号。序列号的初始值是一个随机数，每发送一次 TCP 报文序列号都会累加一次报文的数据字节数\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e确认应答号\u003c/strong\u003e：下一次期望收到的数据的序列号\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e数据偏移量\u003c/strong\u003e：数据部分的偏移量，也就是首部的长度。单位为 4 字节。因此 TCP 首部最长为 $(2^4-1)*4=60$ 字节。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e控制位\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eACK\u003c/em\u003e：该位为 1 时表示确认应答字段有效，除最初建立连接时的 \u003ccode\u003eSYN\u003c/code\u003e 包外该位必须置 1\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eRST\u003c/em\u003e：该位为 1 时表示 TCP 连接出现异常必须强制断开连接\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eSYN\u003c/em\u003e：该位为 1 时表示希望建立 TCP 连接，并在其序列号字段确定序列号初始值\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eFIN\u003c/em\u003e：该位为 1 时表示今后不会再有数据发送，希望断开 TCP 连接\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tcp-连接\"\u003eTCP 连接\u003c/h2\u003e\n\u003ch3 id=\"三次握手\"\u003e三次握手\u003c/h3\u003e\n\u003cp\u003e建立一个 TCP 连接需要经过三次握手过程。\u003c/p\u003e","title":"TCP 基础"},{"content":"trait 定义了某个特定类型拥有可能与其他类型共享的功能。\n定义与实现 trait 定义 trait 一个 trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。\ntrait Area { fn area(\u0026amp;self) -\u0026gt; u32; } 为类型实现 trait 使用 impl for 为类型实现 trait。\nimpl Area for Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } impl Area for Circle { fn area(\u0026amp;self) -\u0026gt; u32 { 3 * self.radio * self.radio } } 默认实现 trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String { String::from(\u0026#34;(Read more...)\u0026#34;); } } // 因为有默认实现，所以可以指定一个空 impl 块 impl Summary for Tweet {} trait 作为参数 通过将 trait 作为函数参数，可以使该参数支持任何实现了指定 trait 的类型。\nimpl Trait 语法 fn notify(item: \u0026amp;impl Summary) { println!(\u0026#34;{}\u0026#34;, item.summarize()); } Trait Bound 语法 fn notify\u0026lt;T: Summary\u0026gt;(item: \u0026amp;T) { println!(\u0026#34;{}\u0026#34;, item.summarize()); } // 泛型限制了两个参数必须是相同类型 fn notify\u0026lt;T: Summary\u0026gt;(item1: \u0026amp;T, item2: \u0026amp;T) { // impl Trait 允许两个参数是不同类型 fn notify(item1: \u0026amp;impl Summary, item2: \u0026amp;impl Summary) { 通过 + 指定多个 trait bound fn notify(item: \u0026amp;(impl Summary + Display)) {} fn notify\u0026lt;T: Summary + Display\u0026gt;(item: \u0026amp;T) {} 通过 where 简化 trait bound fn some_function\u0026lt;T, U\u0026gt;(t: \u0026amp;T, u: \u0026amp;U) -\u0026gt; i32 where T: Display + Clone, U: Clone + Debug, { 返回实现了 trait 的类型 fn returns_summarizable() -\u0026gt; impl Summary { 注意，这只适用于返回单一类型的情况。\n使用 trait bound 有条件地实现方法 impl\u0026lt;T\u0026gt; Pair\u0026lt;T\u0026gt; { fn new(x: T, y: T) -\u0026gt; Self { Self { x, y } } } // 只有实现了 Display 和 PartialOrd Trait 的泛型 T 才会拥有这个方法 impl\u0026lt;T: Display + PartialOrd\u0026gt; Pair\u0026lt;T\u0026gt; { fn cmp_display(\u0026amp;self) { if self.x \u0026gt;= self.y { println!(\u0026#34;The largest member is x = {}\u0026#34;, self.x); } else { println!(\u0026#34;The largest member is y = {}\u0026#34;, self.y); } } } 也可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 blanket implementations\n// blanket implementations // 任何实现了 Display trait 的类型都会自动实现 ToString trait impl\u0026lt;T: Display\u0026gt; ToString for T { 孤儿规则 只有在 trait 或类型至少有一个属于当前 crate 时，才能对类型实现该 trait。\n比如，不能在自己的 crate 中为标准库中的类型实现标准库中的 trait。因为它们均不属于当前 crate。\nTrait 对象 泛型虽然很方便，但也有限制。比如，泛型限制了参数只能是同一种类型。\n如下代码所示，Vec 的元素必须是相同类型的。\ntrait Draw { fn draw(\u0026amp;self); } struct Button { name: String, } impl Draw for Button { fn draw(\u0026amp;self) { println!(\u0026#34;Draw button\u0026#34;); } } struct TextField { name: String, } impl Draw for TextField { fn draw(\u0026amp;self) { println!(\u0026#34;Draw text field\u0026#34;); } } fn main() { let vec = vec![ Box::new(Button { name: \u0026#34;button\u0026#34;.to_string(), }), // mismatched types expected `Button`, found `TextField` Box::new(TextField { name: \u0026#34;text field\u0026#34;.to_string(), }), ]; } Trait 对象则允许在运行时替代多种具体类型。\n// 使用 dyn 关键字声明 trait 对象 let vec: Vec\u0026lt;Box\u0026lt;dyn Draw\u0026gt;\u0026gt; = vec![ Box::new(Button { name: \u0026#34;button\u0026#34;.to_string(), }), Box::new(TextField { name: \u0026#34;text field\u0026#34;.to_string(), }), ]; for i in vec { i.draw(); } Rust 使用使用动态分发（Dynamic Dispatch）实现 trait 对象。此时编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。而编译器只能保证类型实现了相应的 trait。\n关联类型 关联类型（associated types）的作用与泛型十分相似，但关联类型限制了我们只能实现一次 trait。\npub trait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; } impl Iterator for Counter { // 只能指定一次 Item 的类型 type Item = u32; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { // --snip-- 默认泛型类型参数 在使用泛型类型参数时，可以为泛型指定一个默认的具体类型。\n// 提供默认的泛型类型参数 trait Add\u0026lt;Rhs=Self\u0026gt; { type Output; fn add(self, rhs: Rhs) -\u0026gt; Self::Output; } // 使用默认泛型类型参数 impl Add for Point { type Output = Point; fn add(self, other: Point) -\u0026gt; Point { Point { x: self.x + other.x, y: self.y + other.y, } } } // 不使用默认泛型类型参数 impl Add\u0026lt;Meters\u0026gt; for Millimeters { type Output = Millimeters; fn add(self, other: Meters) -\u0026gt; Millimeters { Millimeters(self.0 + (other.0 * 1000)) } } 完全限定语法 Rust 不能避免一个 trait 与另一个 trait 拥有同名的方法，也不能阻止为同一类型实现这两个 trait。\ntrait Pilot { fn fly(\u0026amp;self); } trait Wizard { fn fly(\u0026amp;self); } struct Human; // 实现两个有同名方法的 trait impl Pilot for Human { fn fly(\u0026amp;self) { println!(\u0026#34;Pilot fly\u0026#34;); } } impl Wizard for Human { fn fly(\u0026amp;self) { println!(\u0026#34;Wizard fly\u0026#34;); } } // 自身也实现该方法 impl Human { fn fly(\u0026amp;self) { println!(\u0026#34;Flying\u0026#34;); } } fn main() { let human = Human {}; // 默认调用自身实现 human.fly(); Wizard::fly(\u0026amp;human); Pilot::fly(\u0026amp;human); } 关联函数没有 \u0026amp;self 参数，不能使用上面的方法来消除歧义。此时只能使用完全限定语法（fully qualified syntax）。\n// 关联函数而非方法 trait Pilot { fn fly(); } trait Wizard { fn fly(); } struct Human; impl Pilot for Human { fn fly() { println!(\u0026#34;Pilot fly\u0026#34;); } } impl Wizard for Human { fn fly() { println!(\u0026#34;Wizard fly\u0026#34;); } } impl Human { fn fly() { println!(\u0026#34;Flying\u0026#34;); } } fn main() { Human::fly(); // 完全限定语法调用同名关联函数 \u0026lt;Human as Wizard\u0026gt;::fly(); \u0026lt;Human as Pilot\u0026gt;::fly(); } 父 trait 父 trait 可以让类型在一个 trait 的同时也必须实现另一个 trait。\nuse std::fmt; // 父 trait trait OutlinePrint: fmt::Display { fn outline_print(\u0026amp;self) { // 可以使用父 trait 的方法 let output = self.to_string(); let len = output.len(); println!(\u0026#34;{}\u0026#34;, \u0026#34;*\u0026#34;.repeat(len + 4)); println!(\u0026#34;*{}*\u0026#34;, \u0026#34; \u0026#34;.repeat(len + 2)); println!(\u0026#34;* {output} *\u0026#34;); println!(\u0026#34;*{}*\u0026#34;, \u0026#34; \u0026#34;.repeat(len + 2)); println!(\u0026#34;{}\u0026#34;, \u0026#34;*\u0026#34;.repeat(len + 4)); } } Sized Trait **动态大小类型（dynamically sized types）**允许我们处理只用在运行时才知道大小的类型。\n因为动态大小类型只能在运行时确定，所以它的值必须置于某种指针之后。\n比如 trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。所以它必须放在指针之后，\u0026amp;dyn trait 或 Box\u0026lt;dyn trait\u0026gt;。\n为了处理 DST，Rust 提供了 Sized trait 来决定一个类型的大小是否在编译时可知。这个 trait 会自动为所有在编译时就知道大小的类型实现。另外，Rust 会为每一个泛型函数增加 Sized bound。\nfn generic\u0026lt;T\u0026gt;(t: T){} fn generic\u0026lt;T: Sized\u0026gt;(t: T){} Sized trait 还有一个特殊的语法，?Sized。它表示该类型可能是也可能不是 Sized。该语法只能用于 Sized。\n// 参数类型从 T 变成了 \u0026amp;T，因为 DST 必须置于某种指针之后 fn generic\u0026lt;T: ?Sized\u0026gt;(t: \u0026amp;T){} #[derive(Debug)] struct Bar\u0026lt;T: ?Sized\u0026gt;(T); // [i32] 没有实现 Sized trait，所以它的大小在编译时是不可知的 // 如果不使用 ?Sized trait，以下代码将无法编译 fn main() { let sized: Bar\u0026lt;[i32; 8]\u0026gt; = Bar([0; 8]); let dynamic1: Box\u0026lt;Bar\u0026lt;[i32]\u0026gt;\u0026gt; = Box::new(Bar([])); let dynamic2: Box\u0026lt;Bar\u0026lt;[i32]\u0026gt;\u0026gt; = Box::new(sized); println!(\u0026#34;{:#?}\u0026#34;, dynamic1); println!(\u0026#34;{:#?}\u0026#34;, dynamic2); } ","permalink":"https://tpcad.github.io/posts/rust_trait/","summary":"\u003cp\u003etrait 定义了某个特定类型拥有可能与其他类型共享的功能。\u003c/p\u003e\n\u003ch2 id=\"定义与实现-trait\"\u003e定义与实现 trait\u003c/h2\u003e\n\u003ch3 id=\"定义-trait\"\u003e定义 trait\u003c/h3\u003e\n\u003cp\u003e一个 trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003etrait\u003c/span\u003e Area {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003earea\u003c/span\u003e(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#99d1db\"\u003eself\u003c/span\u003e) -\u0026gt; \u003cspan style=\"color:#e78284\"\u003eu32\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"为类型实现-trait\"\u003e为类型实现 trait\u003c/h3\u003e\n\u003cp\u003e使用 \u003ccode\u003eimpl for\u003c/code\u003e 为类型实现 trait。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003eimpl\u003c/span\u003e Area \u003cspan style=\"color:#ca9ee6\"\u003efor\u003c/span\u003e Rectangle {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003earea\u003c/span\u003e(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#99d1db\"\u003eself\u003c/span\u003e) -\u0026gt; \u003cspan style=\"color:#e78284\"\u003eu32\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#99d1db\"\u003eself\u003c/span\u003e.width \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#99d1db\"\u003eself\u003c/span\u003e.height\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003eimpl\u003c/span\u003e Area \u003cspan style=\"color:#ca9ee6\"\u003efor\u003c/span\u003e Circle {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003earea\u003c/span\u003e(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#99d1db\"\u003eself\u003c/span\u003e) -\u0026gt; \u003cspan style=\"color:#e78284\"\u003eu32\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ef9f76\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#99d1db\"\u003eself\u003c/span\u003e.radio \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#99d1db\"\u003eself\u003c/span\u003e.radio\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"默认实现\"\u003e默认实现\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003etrait\u003c/span\u003e Summary {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003esummarize\u003c/span\u003e(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#99d1db\"\u003eself\u003c/span\u003e) -\u0026gt; \u003cspan style=\"color:#99d1db\"\u003eString\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#99d1db\"\u003eString\u003c/span\u003e::from(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;(Read more...)\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 因为有默认实现，所以可以指定一个空 impl 块\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#ca9ee6\"\u003eimpl\u003c/span\u003e Summary \u003cspan style=\"color:#ca9ee6\"\u003efor\u003c/span\u003e Tweet {}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"trait-作为参数\"\u003etrait 作为参数\u003c/h2\u003e\n\u003cp\u003e通过将 trait 作为函数参数，可以使该参数支持任何实现了指定 trait 的类型。\u003c/p\u003e","title":"Rust Traits"},{"content":"线程基础 创建线程 使用 thread::spawn 创建线程，它接受一个 FnOnce 闭包。\nuse std::{thread, time::Duration}; fn main() { let handle = thread::spawn(|| { for i in 0..10 { println!(\u0026#34;{i}: spawned thread echo\u0026#34;); thread::sleep(Duration::from_millis(10)); } }); for i in 0..5 { println!(\u0026#34;{i}: main thread echo\u0026#34;); thread::sleep(Duration::from_millis(10)); } handle.join().unwrap(); } 等待线程结束 使用 join 方法等待线程结束。\nlet handle = thread::spawn(|| { for i in 0..10 { println!(\u0026#34;{i}: spawned thread echo\u0026#34;); thread::sleep(Duration::from_millis(10)); } }); // 对 spawn 的返回值调用 join 方法 handle.join().unwrap(); move 闭包与线程 use std::thread; fn main() { let v = vec![1, 2, 3]; // 使用 move 获取所有权 let handle = thread::spawn(move || { println!(\u0026#34;Here\u0026#39;s a vector: {v:?}\u0026#34;); }); handle.join().unwrap(); } 消息传递 Rust 通过**信道（channel）**实现消息传递。\n信道由两部分组成：一个发送者（transmitter）和接收者（receiver）。当任一方被丢弃时可以认为信道被关闭了。\nRust 的信道实现在 std::sync::mpsc 中。\nmpsc::channel 函数用于创建一个信道。它会返回一个元祖，第一个元素是发送者，第二个元素是接收者。\n发送者调用 send 方法发送消息。它的参数就是要发送的值。它返回一个 Result\u0026lt;(), SendError\u0026lt;T\u0026gt;\u0026gt;。错误通常发生在接收者已经被丢弃时。\n注意，send 方法会获取参数的所有权。\n接受者调用 recv 方法接收消息。该方法会阻塞线程执行直到从信道中获取一个值。若信道已经被关闭，则会返回一个错误。\n另外还有 try_recv 方法可以接收信息。这个方法不会阻塞线程，而是立刻返回一个 Result。\nuse std::{sync::mpsc, thread}; fn main() { // mpsc:;channel 创建一个信道。 let (tx, rx) = mpsc::channel(); thread::spawn(move || { let val = \u0026#34;hello\u0026#34;.to_owned(); // 调用 send 方法发送消息 tx.send(val).unwrap(); }); // 接收者调用 recv 方法接收消息 let rec = rx.recv().unwrap(); println!(\u0026#34;{rec} from spwaned thread\u0026#34;); } 创建多个发送者 可以使用 clone 方法创建多个发送者。同时，将接收者当作一个迭代器不断从信道中获取消息。\nuse std::{sync::mpsc, thread}; fn main() { let (tx, rx) = mpsc::channel(); let tx1 = tx.clone(); thread::spawn(move || { let val = \u0026#34;hello\u0026#34;.to_owned(); tx.send(val).unwrap(); }); thread::spawn(move || { let val = \u0026#34;hello\u0026#34;.to_owned(); tx1.send(val).unwrap(); }); for rec in rx { println!(\u0026#34;{rec} from spwaned thread\u0026#34;); } } 互斥器 互斥器保证在任意时刻，只有一个线程访问某些数据。\n在 Rust 中通过 Mutex\u0026lt;T\u0026gt; 创建一个互斥锁。访问互斥器的数据前需要获取锁。lock 方法返回一个类型为 MutexGuard 的智能指针。在 MutexGuard 离开作用域时，会调用 Drop trait 释放锁。\nuse std::sync::Mutex; fn main() { let m = Mutex::new(5); { let mut num = m.lock().unwrap(); *num = 6; } println!(\u0026#34;m = {m:?}\u0026#34;); } Mutex\u0026lt;T\u0026gt; 并不能直接用于多线程。Arc\u0026lt;T\u0026gt; 是一个类似 Rc\u0026lt;T\u0026gt; 但可用于多线程的智能指针。\nuse std::{ sync::{Arc, Mutex}, thread, }; fn main() { // 将 Mutex\u0026lt;T\u0026gt; 放在 Arc\u0026lt;T\u0026gt; 中 let counter = Arc::new(Mutex::new(0)); let mut handlers = vec![]; for _ in 0..10 { let counter = Arc::clone(\u0026amp;counter); let handler = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; println!(\u0026#34;counter: {num}\u0026#34;); }); handlers.push(handler); } for handler in handlers { handler.join().unwrap(); } // println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); } ","permalink":"https://tpcad.github.io/posts/rust_thread/","summary":"\u003ch2 id=\"线程基础\"\u003e线程基础\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e创建线程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用 \u003ccode\u003ethread::spawn\u003c/code\u003e 创建线程，它接受一个 \u003ccode\u003eFnOnce\u003c/code\u003e 闭包。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003euse\u003c/span\u003e std::{thread, time::Duration};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e78284\"\u003elet\u003c/span\u003e handle \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e thread::spawn(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e||\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ca9ee6\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#ca9ee6\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e..\u003c/span\u003e\u003cspan style=\"color:#ef9f76\"\u003e10\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#8caaee\"\u003eprintln!\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e{i}\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e: spawned thread echo\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            thread::sleep(Duration::from_millis(\u003cspan style=\"color:#ef9f76\"\u003e10\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#ca9ee6\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e..\u003c/span\u003e\u003cspan style=\"color:#ef9f76\"\u003e5\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#8caaee\"\u003eprintln!\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e{i}\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e: main thread echo\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        thread::sleep(Duration::from_millis(\u003cspan style=\"color:#ef9f76\"\u003e10\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    handle.join().unwrap();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e等待线程结束\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用 \u003ccode\u003ejoin\u003c/code\u003e 方法等待线程结束。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003elet\u003c/span\u003e handle \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e thread::spawn(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e||\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#ca9ee6\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e..\u003c/span\u003e\u003cspan style=\"color:#ef9f76\"\u003e10\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#8caaee\"\u003eprintln!\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e{i}\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e: spawned thread echo\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        thread::sleep(Duration::from_millis(\u003cspan style=\"color:#ef9f76\"\u003e10\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 对 spawn 的返回值调用 join 方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003ehandle.join().unwrap();\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003emove 闭包与线程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003euse\u003c/span\u003e std::thread;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e78284\"\u003elet\u003c/span\u003e v \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003evec!\u003c/span\u003e[\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e3\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 使用 move 获取所有权\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#e78284\"\u003elet\u003c/span\u003e handle \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e thread::spawn(\u003cspan style=\"color:#ca9ee6\"\u003emove\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e||\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#8caaee\"\u003eprintln!\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;Here\u0026#39;s a vector: \u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e{v:?}\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    handle.join().unwrap();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"消息传递\"\u003e消息传递\u003c/h2\u003e\n\u003cp\u003eRust 通过**信道（channel）**实现消息传递。\u003c/p\u003e","title":"Thread in Rust"},{"content":"Selection Sort 以升序为例，选择排序的思想是遍历未排序元素，选择其中最小的元素，将其移动到未排序元素开始位置。\n性质 最好时间复杂度：$O(n^2)$ 最坏时间复杂度：$O(n^2)$ 平均时间复杂度：$O(n^2)$ 稳定性：不稳定 演示 // 原数组，所有元素均位于未排序部分 [3, 4, 1, 9, 5, 8, 0] // 第一轮，遍历未排序部分，选择最小的元素（0），移动到未排序部分开始位置 // 有序部分位于数组头部 [0, 4, 3, 9, 5, 8, 1] // 第二轮，遍历未排序部分，选择最小的元素（1），移动到未排序部分开始位置 [0, 1, 4, 9, 5, 8, 3] // 第三轮，遍历未排序部分，选择最小的元素（3），移动到未排序部分开始位置 [0, 1, 3, 9, 5, 8, 4] // ... 示例代码 void selection_sort(int *arr, int len) { for (int i = 0; i \u0026lt; len - 1; ++i) { int min_idx = i; int j = i + 1; for (; j \u0026lt; len; ++j) { if (arr[min_idx] \u0026gt; arr[j]) { min_idx = j; // 记录索引位置 } } if (min_idx != i) { swap(\u0026amp;arr[i], \u0026amp;arr[min_idx]); } } } Bubble Sort 以升序为例，在未排序元素中依次比较相邻两个元素，若乱序则交换两个元素，这样一来较大的元素就会被慢慢移动到末尾有序排列。通常在冒泡排序中设置一个 flag，当没有发生交换操作时，说明数组已经有序，停止遍历。\n性质 最优时间复杂度：$O(n)$（正序） 最坏时间复杂度：$O(n^2)$（逆序） 平均时间复杂度：$O(n^2)$ 稳定性：稳定 演示 假设有数组 3, 4, 1, 9, 5, 8, 0。\n以升序为例，比较索引为 0 的元素和索引为 1 的元素，若前者大于后者，交换二者位置。接着比较索引为 1 的元素和索引为 2 的元素，若前者大于后者，交换二者位置。依次类推，直至最后一组相邻元素。然后再从头开始比较相邻的两个元素，此次不包括最后一个元素。\n// 原数组 [3, 4, 1, 9, 5, 8, 0] // 第一轮，3\u0026lt;4，不交换 [3, 4, 1, 9, 5, 8, 0] // 第一轮，1\u0026lt;4，交换 [3, 1, 4, 9, 5, 8, 0] // 第一轮，4\u0026lt;9，不交换 [3, 1, 4, 9, 5, 8, 0] // 第一轮，5\u0026lt;9，交换 [3, 1, 4, 5, 9, 8, 0] // 第一轮，9\u0026gt;8，交换 [3, 1, 4, 5, 8, 9, 0] // 第一轮，9\u0026gt;0，交换 [3, 1, 4, 5, 8, 0, 9] // 第一轮结束，最大值 9 被交换到数组尾部 [3, 1, 4, 5, 8, 0, 9] // 第二轮，不包括尾部有序部分 [1, 3, 4, 5, 0, 8, 9] // 第三轮，不包括尾部有序部分 [1, 3, 4, 0, 5, 8, 9] // ... 示例代码 fn main() { let mut arr = [1, 2, 6, 3, 7, 3, 9, 4, 0]; let mut flag = true; while flag { flag = false; for j in 0..arr.len() - 1 { if arr[j] \u0026gt; arr[j + 1] { flag = true; arr.swap(j, j + 1) } } } println!(\u0026#34;{:#?}\u0026#34;, arr) } 上面的实现每次都要比较到数组的最后，而每次遍历之后尾部的元素都是有序的，并不需要再进行比较，因此可以记录上次交换操作的位置，下一轮循环就可以在该位置结束，因为后面的元素已经是有序的了。\nfn main() { let mut arr = [1, 2, 6, 3, 7, 3, 9, 4, 0]; let mut unsorted = arr.len() - 1; while unsorted != 0 { let mut u = 0; for j in 0..unsorted { if arr[j] \u0026gt; arr[j + 1] { arr.swap(j, j + 1); u = j; // 记录上次比较操作的位置 } } unsorted = u; } println!(\u0026#34;{:#?}\u0026#34;, arr) } Insertion Sort 以升序为例，插入排序将数组分成未排序和已排序两部分，每次从未排序部分按顺序选择一个元素与已排序部分比较，将其插入到合适位置。\n性质 最优时间复杂度：$O(n)$（正序） 最坏时间复杂度：$O(n^2)$（逆序）， 平均时间复杂度：$O(n^2)$ 稳定性：稳定 演示 // 原数组，视索引为 `0` 的元素为已排序部分，剩下元素为未排序部分。 [3, 1, 4, 9, 5, 8, 0] // 第一轮，选择未排序部分第一个元素，将其插入到已排序部分合适位置 [1, 3, 4, 9, 5, 8, 0] // 第一轮，选择未排序部分第一个元素，将其插入到已排序部分合适位置 [1, 3, 4, 9, 5, 8, 0] 示例代码 void insertion_sort(int a[], int len) { for (auto i = 1; i \u0026lt; len; ++i) { int key = a[i]; int j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt; key) { a[j + 1] = a[j]; --j; } a[j + 1] = key; } } 优化 在将元素插入到已排序部分的操作中，可以使用二分查找法优化，但不会改变时间复杂度。\nTODO: 折半插入排序\nShell Sort 希尔排序，又叫缩小增量排序，是插入排序的一种改良版本。希尔排序充分利用了插入排序的两个优点：\n插入排序在数组几乎有序时效率极高 插入排序在元素数量较少时效率极高 希尔排序依据间距将数组分为若干子序列，并对子序列进行插入排序，然后缩小间距，产生新的子序列，再对新的子序列进行插入排序，如此往复，直至间距为 1，此时再进行插入排序就是对整个数组进行插入排序。\n性质 希尔排序的时间复杂度与间距的选择有关，通常情况下：\n最好时间复杂度：$O(nlog^2n)$ 最坏时间复杂度：$O(n^2)$ 平均时间复杂度：$O(nlog^2n)$ 稳定性：不稳定 演示 // 待排序数组 [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] // 假设间距为 4，可得以下子序列 [3, 23, 9] -\u0026gt; [3, 9, 23] [54, 11, 12] -\u0026gt; [11, 12, 54] [35, 74, 45] -\u0026gt; [35, 45, 74] [87, 2, 53] -\u0026gt; [2, 53, 87] // 对子序列进行插入排序 [3, 11, 35, 9, 2, 12, 45, 53, 23, 54, 74, 87] // 取间距为 1，即插入排序 [2, 3, 9, 11, 12, 23, 35, 45, 53, 54, 74, 87] 示例代码 void shell_sort(int *arr, int len) { int d = 1; while (d \u0026lt; len / 3) { d = d * 3 + 1; } // 直接使用插入排序 while (d \u0026gt;= 1) { // 每个间距一次循环 for (int i = 0; i \u0026lt; d; ++i) { // 间距划分出的子序列数量 for (int j = i + d; j \u0026lt; len; j += d) { // 每个子序列进行插入排序 int key = arr[j]; int k = j - d; while (k \u0026gt;= 0 \u0026amp;\u0026amp; arr[k] \u0026gt; key) { arr[k + d] = arr[k]; k -= d; } arr[k + d] = key; } } d /= 3; } } 如果直接使用类似前文的插入排序算法，需要用到四层循环。而下面的插入排序只需要三层循环，这种形式的插入排序并不会一次性将子序列排序，而是每次只排序一个子序列的一个元素。\nvoid shell_sort(int *arr, int len) { int d = 1; while (d \u0026lt; len / 3) { d = d * 3 + 1; } while (d \u0026gt;= 1) { // i 从间距 d 开始，将前面的排序视为每个子序列已排序部分，每次自增 1， // 每次只排序一个子序列的一个元素，i 每自增 d 次就表示所有子序列都排序 // 了一个元素 for (int i = d; i \u0026lt; len; ++i) { int key = arr[i]; int j = i - d; for (; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key; j -= d) { arr[j + d] = arr[j]; } arr[j + d] = key; } d /= 3; } } Quick Sort 快速排序是一种递归的排序算法，它将数组以某个元素为基准，划分为小于基准和大于基准的两部分，再分别在这两个部分中执行相同操作直至不能再划分。\n性质 最优时间复杂度：$O(n\\log n)$ 最坏时间复杂度：$O(n^2)$ 平均时间复杂度：$O(n\\log n)$ 空间复杂度：$O(\\log n)$（递归调用栈） 稳定性：不稳定 演示 [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] // 以 53 为基准，与 l 比较，小于或等于则 l+1，并继续比较 l， // 大于则将 l 移动到 r，且 r+1，并比较 r，如此往复。 [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] ^l ^r [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] ^l ^r [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 54] ^l ^r [3, 45, 35, 87, 23, 11, 74, 2, 9, 12, 45, 54] ^l ^r [3, 45, 35, 87, 23, 11, 74, 2, 9, 12, 45, 54] ^l ^r [3, 45, 35, 87, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 74, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 9, 2, 9, 74, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 9, 2, 9, 74, 87, 54] ^lr [3, 45, 35, 12, 23, 11, 9, 2, 53, 74, 87, 54] ^lr 示例代码 static int partition(int *arr, int low, int high) { int pivot = arr[low]; while (low \u0026lt; high) { while (low \u0026lt; high \u0026amp;\u0026amp; pivot \u0026lt;= arr[high]) { --high; } arr[low] = arr[high]; while (low \u0026lt; high \u0026amp;\u0026amp; pivot \u0026gt;= arr[low]) { ++low; } arr[high] = arr[low]; } arr[low] = pivot; return low; } static void quick_sort_helper(int *arr, int lhs, int rhs) { if (lhs \u0026lt; rhs) { int pivot = partition(arr, lhs, rhs); quick_sort_helper(arr, lhs, pivot - 1); quick_sort_helper(arr, pivot + 1, rhs); } } void quick_sort(int *arr, const int len) { quick_sort_helper(arr, 0, len - 1); } Merge Sort 归并排序基于分治思想将数组分段排序后合并。分段操作，当只有一个元素时，数组有序，不再分段，当元素大于 1 时，数组被递归地分成有序的两部分；合并操作，借助额外的数组，有序地将两部分数组中最小的元素放入额外数组，再用额外数组覆盖原数组。\n最优时间复杂度：$O(n \\log n)$ 最坏时间复杂度：$O(n \\log n)$ 平均时间复杂度：$O(n \\log n)$ 空间复杂度：$O(n)$ static void merge(int *arr, int l, int r, int len) { int *tmp = (int *)malloc(sizeof(int) * len); if (tmp == NULL) { printf(\u0026#34;Can not allocate memory!\\n\u0026#34;); exit(1); } int mid = (l + r) \u0026gt;\u0026gt; 1; int i = l, j = mid, k = l; // index variable // 合并两个子序列 while (i \u0026lt; mid \u0026amp;\u0026amp; j \u0026lt; r) { if (arr[i] \u0026lt;= arr[j]) { tmp[k++] = arr[i++]; } else { tmp[k++] = arr[j++]; } } // 未结束的子序列 if (j == r) { while (i \u0026lt; mid) { tmp[k++] = arr[i++]; } } else { while (j \u0026lt; r) { tmp[k++] = arr[j++]; } } // 有序序列覆盖原序列 for (k = l; k \u0026lt; r; ++k) { arr[k] = tmp[k]; } free(tmp); } static void merge_sort_helper(int *arr, int l, int r, int len) { if (r - l \u0026lt;= 1) { return; } int mid = (r + l) \u0026gt;\u0026gt; 1; merge_sort_helper(arr, l, mid, len); merge_sort_helper(arr, mid, r, len); merge(arr, l, r, len); } void merge_sort(int *arr, const int len) { merge_sort_helper(arr, 0, len, len); } 归并排序求逆序对数量 逆序对是 i \u0026lt; j 且 $a_i \u0026gt; a_j$ 的有序数对 (i, j)。\n在归并排序进行合并操作时，若出现左子序列元素 a 大于右子序列元素 b，则说明左子序列元素 a 及左子序列剩余元素都大于右子序列元素 b。\n设全局变量 cnt = 0 以记录逆序对个数。在合并操作中添加 cnt += mid - i 即可记录逆序对个数。\nwhile (i \u0026lt; mid \u0026amp;\u0026amp; j \u0026lt; r) { if (arr[i] \u0026lt;= arr[j]) { tmp[k++] = arr[i++]; } else { tmp[k++] = arr[j++]; cnt += mid - i; // 记录逆序对个数 } } Heap Sort 堆排序是一种基于二叉堆的排序算法。二叉堆是一棵完全二叉树。大根堆是指二叉堆的每棵子树的父结点的值都大于其子结点，小根堆则相反。\n堆排序首先要建堆，在建堆过程中会把数组中最大的元素移动到根结点，将根结点与数组最后一个元素交换即可完成一次排序。之后继续将剩余元素建堆、交换，直至完成排序。\n采用向下调整的方法建堆，即选择一个非叶子结点，与其最大子结点交换，若交换后该结点仍为非叶子结点，则继续与其最大子结点交换，直至该结点为叶子结点。\n性质 最优时间复杂度：$O(n\\log n)$ 最坏时间复杂度：$O(n\\log n)$ 平均时间复杂度：$O(n\\log n)$ 稳定性：不稳定 示例代码 void heapify(int *arr, int parent, int len) { int child = (parent \u0026lt;\u0026lt; 1) + 1; // 左子结点索引 while (child \u0026lt; len) { // 判断是否为非叶子结点 // 最大子结点 if (arr[child + 1] \u0026gt; arr[child]) { ++child; } if (arr[parent] \u0026gt;= arr[child]) { break; } else { // 与最大子结点交换 swap(\u0026amp;arr[parent], \u0026amp;arr[child]); // 继续向下调整 parent = child; child = (parent \u0026lt;\u0026lt; 1) + 1; } } } void heap_sort(int *arr, const int len) { // 首次建堆，从最后一个非叶子结点开始向前遍历 for (int i = (len - 1 - 1) \u0026gt;\u0026gt; 2; i \u0026gt;= 0; --i) { heapify(arr, i, len); } for (int i = len - 1; i \u0026gt; 0; --i) { // 交换完成一次排序 swap(\u0026amp;arr[0], \u0026amp;arr[i]); heapify(arr, 0, i - 1); } } 计数排序 计数排序使用一个额外数组记录待排序数组中元素的个数，然后根据该数组将待排序数组的元素排到正确位置。\n最好时间复杂度：$O(n+w)$ 最坏时间复杂度：$O(n+w)$ 平均时间复杂度：$O(n+w)$ 空间复杂度：$O(w)$，其中 w 代表待排序数据的值域大小 稳定性：稳定 示例代码 void counting_sort(int *arr, const int len) { int max = arr[0]; int *aux = (int *)malloc(len * sizeof(int)); // 拷贝数组 for (int i = 0; i \u0026lt; len; ++i) { if (max \u0026lt; arr[i]) { max = arr[i]; // 找到序列最大值 } aux[i] = arr[i]; } int *cnt = (int *)malloc((max + 1) * sizeof(int)); for (int i = 0; i \u0026lt; len; ++i) { // 计数 cnt[arr[i]]++; } // 计算前缀和，使计数数组表示有多少个元素小于或等于（包括自己）其所代表的元素 for (int i = 1; i \u0026lt; max + 1; ++i) { cnt[i] += cnt[i - 1]; } // 排序 for (int i = len - 1; i \u0026gt;= 0; --i) { arr[--cnt[aux[i]]] = aux[i]; } free(cnt); free(aux); } ","permalink":"https://tpcad.github.io/posts/algorithm_sort/","summary":"\u003ch2 id=\"selection-sort\"\u003eSelection Sort\u003c/h2\u003e\n\u003cp\u003e以升序为例，选择排序的思想是遍历未排序元素，选择其中最小的元素，将其移动到未排序元素开始位置。\u003c/p\u003e\n\u003ch3 id=\"性质\"\u003e性质\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e最好时间复杂度：$O(n^2)$\u003c/li\u003e\n\u003cli\u003e最坏时间复杂度：$O(n^2)$\u003c/li\u003e\n\u003cli\u003e平均时间复杂度：$O(n^2)$\u003c/li\u003e\n\u003cli\u003e稳定性：不稳定\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"演示\"\u003e演示\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 原数组，所有元素均位于未排序部分\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ef9f76\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 第一轮，遍历未排序部分，选择最小的元素（0），移动到未排序部分开始位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 有序部分位于数组头部\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 第二轮，遍历未排序部分，选择最小的元素（1），移动到未排序部分开始位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 第三轮，遍历未排序部分，选择最小的元素（3），移动到未排序部分开始位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ef9f76\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// ...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"示例代码\"\u003e示例代码\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e78284\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003eselection_sort\u003c/span\u003e(\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e*\u003c/span\u003earr, \u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e len) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ca9ee6\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003e len \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e; \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e min_idx \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e i;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e78284\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e i \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ca9ee6\"\u003efor\u003c/span\u003e (; j \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003e len; \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e++\u003c/span\u003ej) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ca9ee6\"\u003eif\u003c/span\u003e (arr[min_idx] \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e arr[j]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                min_idx \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e j; \u003cspan style=\"color:#737994;font-style:italic\"\u003e// 记录索引位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ca9ee6\"\u003eif\u003c/span\u003e (min_idx \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e!=\u003c/span\u003e i) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#8caaee\"\u003eswap\u003c/span\u003e(\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003earr[i], \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003earr[min_idx]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"bubble-sort\"\u003eBubble Sort\u003c/h2\u003e\n\u003cp\u003e以升序为例，在未排序元素中依次比较相邻两个元素，若乱序则交换两个元素，这样一来较大的元素就会被慢慢移动到末尾有序排列。通常在冒泡排序中设置一个 \u003ccode\u003eflag\u003c/code\u003e，当没有发生交换操作时，说明数组已经有序，停止遍历。\u003c/p\u003e","title":"Classic Sort Algorithm"},{"content":"Box\u0026lt;T\u0026gt; Box 是最简单的智能指针，它允许你将一个值放在堆上而不是栈上。\nfn main() { let f1 = foo { bar: 32 }; let f2 = Box::new(foo { bar: 11 }); println!(\u0026#34;address on stack: {:p}\u0026#34;, \u0026amp;f1); println!(\u0026#34;address on heap: {:p}\u0026#34;, f2); println!(\u0026#34;address of box(on stack): {:p}\u0026#34;, \u0026amp;f2); } struct foo { bar: i32, } // address on stack: 0x7ffd34540f0c // address on heap: 0x57d39e669ba0 // address of box(on stack): 0x7ffd34540f10 Box 只提供了间接存储和堆分配，除此之外没有其他特殊功能。\n// 利用 Box 实现递归类型 enum List { Cons(i32, Box\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); } Deref Trait 实现 Deref trait 可以重载解引用运算符 *。\nuse std::ops::Deref; fn main() { let a = 4; let b = MyBox::new(a); println!(\u0026#34;{:?}\u0026#34;, *b); assert_eq!(4, *b); } #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } // 为结构体实现 Deref Trait impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target { \u0026amp;self.0 } } 在执行 *y 时，Rust 会将其替换为 *(y.deref())。\nDeref 强制转换 Deref 强制转换（Deref coercions） 将实现了 Deref trait 的类型的引用转换为另一种类型的引用。比如将 \u0026amp;String 转换为 \u0026amp;str。\nDeref 强制转换发生在编译时，因此并没有运行时损耗。\nDeref trait 用于重载不可变引用的解引用运算符，而 DerefMut trait 用于重载可变引用的解引用运算符。\nRust 在发现类型和 trait 满足三种情况时会进行 Deref 强制转换：\n当 T: Deref\u0026lt;Target=U\u0026gt; 时从 \u0026amp;T 到 \u0026amp;U。 当 T: DerefMut\u0026lt;Target=U\u0026gt; 时从 \u0026amp;mut T 到 \u0026amp;mut U。 当 T: Deref\u0026lt;Target=U\u0026gt; 时从 \u0026amp;mut T 到 \u0026amp;U。 Drop Trait Drop trait 允许我们在值要离开作用域时执行一些代码。\nuse std::ops::Deref; fn main() { let a = 4; let b = MyBox::new(a); assert_eq!(4, *b); } #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } // 为结构体实现 Deref Trait impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target { \u0026amp;self.0 } } // 为结构体实现 Drop trait impl\u0026lt;T\u0026gt; Drop for MyBox\u0026lt;T\u0026gt; { fn drop(\u0026amp;mut self) { println!(\u0026#34;Drop MyBox\u0026#34;); } } Rust 不允许直接调用 Drop trait 的 drop 方法。因为 Rust 仍然会在值离开作用域时自动调用，这会导致二次释放的错误。\n若要强制提前清理值，可以使用 std::mem::drop 函数。\nlet b = MyBox::new(24); // std::mem::drop 位于 prelude 中 drop(b); Rc\u0026lt;T\u0026gt; 有时候一个值会有多个所有者。比如图的节点会被多条边连接。\nRc\u0026lt;T\u0026gt; 允许我们在堆上分配一些可以被程序的多个部分读取的内存。Rc\u0026lt;T\u0026gt; 只用于不可变引用且只能用于单线程场景。\nuse std::rc::Rc; #[derive(Debug)] enum List { // 使用 Rc\u0026lt;T\u0026gt; 存储 List Cons(i32, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let a = Rc::new(Cons(24, Rc::new(Cons(25, Rc::new(Nil))))); println!(\u0026#34;{:p}\u0026#34;, a); // Rc 重载了 Deref trait，返回 T if let Cons(_, i) = \u0026amp;*a { println!(\u0026#34;{:p}\u0026#34;, i); if let Cons(_, k) = \u0026amp;**i { println!(\u0026#34;{:p}\u0026#34;, k) } } // 通过 Rc::strong_count(\u0026amp;a) 查看引用计数 println!(\u0026#34;{}\u0026#34;, Rc::strong_count(\u0026amp;a)); // Rc::clone() 增加引用计数，Rc 的 clone 方法的效果与 Rc::clone 相同 let b = Rc::clone(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, Rc::strong_count(\u0026amp;b)); let c = Rc::clone(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, Rc::strong_count(\u0026amp;c)); // 普通的不可变引用，在栈上配分内存 let d = \u0026amp;a; println!(\u0026#34;{:p}\u0026#34;, d); } RefCell\u0026lt;T\u0026gt; **内部可变性（Interior mutability）**是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。\n#[derive(Debug)] enum List { Cons(Rc\u0026lt;RefCell\u0026lt;i32\u0026gt;\u0026gt;, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; use std::cell::RefCell; use std::rc::Rc; fn main() { let value = Rc::new(RefCell::new(5)); let a = Rc::new(Cons(Rc::clone(\u0026amp;value), Rc::new(Nil))); let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(\u0026amp;a)); let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(\u0026amp;a)); // value 本身不可变，但可以通过 RefCell\u0026lt;T\u0026gt; 的 borrow_mut 方法修改其内部的值 // borrow_mut 返回 RefMut\u0026lt;T\u0026gt;，类似 \u0026amp;mut *value.borrow_mut() += 10; println!(\u0026#34;a after = {a:?}\u0026#34;); println!(\u0026#34;b after = {b:?}\u0026#34;); println!(\u0026#34;c after = {c:?}\u0026#34;); if let Cons(i, k) = b { println!(\u0026#34;{:#?}\u0026#34;, i); *i.borrow_mut() += 10; println!(\u0026#34;{:#?}\u0026#34;, i); if let Cons(x, _) = \u0026amp;*k { println!(\u0026#34;{:#?}\u0026#34;, x); *x.borrow_mut() += 10; println!(\u0026#34;{:#?}\u0026#34;, x); } } } Weak\u0026lt;T\u0026gt; use std::cell::RefCell; use std::rc::{Rc, Weak}; #[derive(Debug)] struct Node { value: i32, parent: RefCell\u0026lt;Weak\u0026lt;Node\u0026gt;\u0026gt;, children: RefCell\u0026lt;Vec\u0026lt;Rc\u0026lt;Node\u0026gt;\u0026gt;\u0026gt;, } fn main() { let leaf = Rc::new(Node { value: 3, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![]), }); println!( \u0026#34;leaf strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;leaf), // 查看实例的弱引用计数 Rc::weak_count(\u0026amp;leaf), ); { let branch = Rc::new(Node { value: 5, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![Rc::clone(\u0026amp;leaf)]), }); // 创建弱引用 *leaf.parent.borrow_mut() = Rc::downgrade(\u0026amp;branch); println!( \u0026#34;branch strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;branch), Rc::weak_count(\u0026amp;branch), ); println!( \u0026#34;leaf strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;leaf), Rc::weak_count(\u0026amp;leaf), ); } // upgrade() 方法检查所引用的实例是否还存在，返回 Option println!(\u0026#34;leaf parent = {:?}\u0026#34;, leaf.parent.borrow().upgrade()); println!( \u0026#34;leaf strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;leaf), Rc::weak_count(\u0026amp;leaf), ); } ","permalink":"https://tpcad.github.io/posts/rust_smart_pointer/","summary":"\u003ch2 id=\"boxt\"\u003e\u003ccode\u003eBox\u0026lt;T\u0026gt;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eBox 是最简单的智能指针，它允许你将一个值放在堆上而不是栈上。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e78284\"\u003elet\u003c/span\u003e f1 \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e foo { bar: \u003cspan style=\"color:#ef9f76\"\u003e32\u003c/span\u003e };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e78284\"\u003elet\u003c/span\u003e f2 \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#99d1db\"\u003eBox\u003c/span\u003e::new(foo { bar: \u003cspan style=\"color:#ef9f76\"\u003e11\u003c/span\u003e });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8caaee\"\u003eprintln!\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;address on stack: \u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e{:p}\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003ef1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8caaee\"\u003eprintln!\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;address on heap: \u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e{:p}\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;\u003c/span\u003e, f2);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8caaee\"\u003eprintln!\u003c/span\u003e(\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;address of box(on stack): \u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e{:p}\u003c/span\u003e\u003cspan style=\"color:#a6d189\"\u003e\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026amp;\u003c/span\u003ef2);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003efoo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    bar: \u003cspan style=\"color:#e78284\"\u003ei32\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// address on stack: 0x7ffd34540f0c\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// address on heap: 0x57d39e669ba0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// address of box(on stack): 0x7ffd34540f10\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBox 只提供了间接存储和堆分配，除此之外没有其他特殊功能。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e// 利用 Box 实现递归类型\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#737994;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#ca9ee6\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#e5c890\"\u003eList\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Cons(\u003cspan style=\"color:#e78284\"\u003ei32\u003c/span\u003e, \u003cspan style=\"color:#99d1db\"\u003eBox\u003c/span\u003e\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026lt;\u003c/span\u003eList\u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e\u0026gt;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Nil,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003euse\u003c/span\u003e \u003cspan style=\"color:#ca9ee6\"\u003ecrate\u003c/span\u003e::List::{Cons, Nil};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ca9ee6\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#8caaee\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e78284\"\u003elet\u003c/span\u003e list \u003cspan style=\"color:#99d1db;font-weight:bold\"\u003e=\u003c/span\u003e Cons(\u003cspan style=\"color:#ef9f76\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#99d1db\"\u003eBox\u003c/span\u003e::new(Cons(\u003cspan style=\"color:#ef9f76\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#99d1db\"\u003eBox\u003c/span\u003e::new(Cons(\u003cspan style=\"color:#ef9f76\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#99d1db\"\u003eBox\u003c/span\u003e::new(Nil))))));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"deref-trait\"\u003eDeref Trait\u003c/h2\u003e\n\u003cp\u003e实现 \u003ccode\u003eDeref\u003c/code\u003e trait 可以重载解引用运算符 \u003ccode\u003e*\u003c/code\u003e。\u003c/p\u003e","title":"Rust Smart Pointer"},{"content":"创建 Github 仓库 创建博客源仓库 博客源仓库用于对 Hugo 的配置文件以及 Markdown 源文件进行备份和管理，并配合 Github Action 自动将生成的静态网页推送到 Github Pages 仓库。\n创建 Github Pages 仓库 以 username.github.io 形式命名的特殊仓库，使用 Github Pages 实现部署网站。\n创建博客 hugo new site Blog Hugo 生成的目录结构。\nBlog ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── i18n ├── layouts ├── static └── themes 关联博客源仓库 cd Blog git init git remote add origin git@github.com:TPCAD/tpcad-blog.git 配置 Hugo 主题 为了方便对主题进行自定义和版本控制，我们将 Hugo 主题 fork 到自己的 Github 账户，并以 submodule 的方式将主题添加到我们的博客源仓库。\ngit submodule add https://github.com/TPCAD/hugo-PaperMod.git themes/hugo-PaperMod 关于 PaperMod 主题的配置，见官方文档。\n如果需要同步主题仓库的最新修改，运行如下命令：\ngit submodule update --remote 关联 Github Pages 仓库 Hugo 默认会将生成的静态网页存放在 public 目录。我们可以将 Github Pages 仓库以子模块的方式添加到博客源仓库。\n# 生成静态网页 hugo cd public # 在 public 目录下建立 git 仓库，并关联远程仓库 git init git remote add git@github.com:TPCAD/tpcad.github.io.git # 进行一次 push，因为无法添加空的远程仓库作为子模块 git add . git commit -m \u0026#34;init\u0026#34; git push -u origin master # 回到根目录添加子模块 cd .. git submodule add git@github.com:TPCAD/tpcad.github.io.git public 现在已经可以通过 `username.tpcad.io\u0026rsquo; 访问访问博客了。\n自动发布 借助 Github Action，可以实现在博客源仓库提交后，自动生成静态网页并推送到 Github Pages 仓库。\n访问 Token 因为需要推送到外部仓库，我们要先获取一个访问 Token。\n进入 Github，在 Settings -\u0026gt; Developer Setttings -\u0026gt; Personal access tokens -\u0026gt; Generate new token(classic 创建一个 Token。\nSocpes 选择 repo 和 workfolw 。\n复制该 Token（Token 只会出现一次）到博客源仓库的 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; Repository secrets 创建一个 Repository secrets。\n创建 Github Action 在博客源仓库目录下创建 .github/workflows/deploy.yml。\n配置如下。将 EXTERNAL_REPOSITORY 替换为自己的 Github Pages 仓库。\nname: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: TPCAD/tpcad.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 同步修改后，以后只需要在博客源仓库进行 push 就会自动将内容推送到 Github Pages 仓库中。\n常见问题 Github Pages 仓库没有启用 Github Action 在仓库的 Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Branch 中选择需要分支并保存，即可启用 Github Pages。\n参考资料 Hugo + GitHub Action，搭建你的博客自动发布系统 如何用 GitHub Pages + Hugo 搭建个人博客 ","permalink":"https://tpcad.github.io/posts/build_blog_with_hugo_and_github_action/","summary":"\u003ch2 id=\"创建-github-仓库\"\u003e创建 Github 仓库\u003c/h2\u003e\n\u003ch3 id=\"创建博客源仓库\"\u003e创建博客源仓库\u003c/h3\u003e\n\u003cp\u003e博客源仓库用于对 Hugo 的配置文件以及 Markdown 源文件进行备份和管理，并配合 Github Action 自动将生成的静态网页推送到 Github Pages 仓库。\u003c/p\u003e\n\u003ch3 id=\"创建-github-pages-仓库\"\u003e创建 Github Pages 仓库\u003c/h3\u003e\n\u003cp\u003e以 \u003ccode\u003eusername.github.io\u003c/code\u003e 形式命名的特殊仓库，使用 Github Pages 实现部署网站。\u003c/p\u003e\n\u003ch2 id=\"创建博客\"\u003e创建博客\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehugo new site Blog\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHugo 生成的目录结构。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-language\" data-lang=\"language\"\u003eBlog\n├── archetypes\n│   └── default.md\n├── assets\n├── content\n├── data\n├── hugo.toml\n├── i18n\n├── layouts\n├── static\n└── themes\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"关联博客源仓库\"\u003e关联博客源仓库\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#c6d0f5;background-color:#303446;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#99d1db\"\u003ecd\u003c/span\u003e Blog\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit init\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit remote add origin git@github.com:TPCAD/tpcad-blog.git\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"配置-hugo-主题\"\u003e配置 Hugo 主题\u003c/h3\u003e\n\u003cp\u003e为了方便对主题进行自定义和版本控制，我们将 Hugo 主题 fork 到自己的 Github 账户，并以 submodule 的方式将主题添加到我们的博客源仓库。\u003c/p\u003e","title":"Hugo + Github Action，搭建个人博客"}]