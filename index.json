[{"content":"完美转发 转发指的是函数之间的参数传递。比如下面的代码，函数 foo 向函数 bar 传递了参数 a。\nfoo(int a) { bar(a) } bar(int b) {} 完美转发则是在转发过程中，参数的各种属性都保持不变。比如右值仍是右值，左值仍是左值。\n普通转发的问题 在下面的代码中，函数 pass 接受一个右值引用，并将该参数传递给函数 reference。当向 pass 传入字面量 1 时，最终的输出结果是 lvalue。这是因为虽然向 pass 传入了右值，但在函数体内，变量 x 的值类别变成了左值，即 x 的类型是右值引用，值类别是左值，所以最终会调用 reference(int \u0026amp;y)。\n这就是普通转发存在的问题，在转发过程中可能会改变参数某些属性。\n#include \u0026lt;fmt/core.h\u0026gt; void reference(int \u0026amp;\u0026amp;y) { fmt::println(\u0026#34;rvalue\u0026#34;); } void reference(int \u0026amp;y) { fmt::println(\u0026#34;lvalue\u0026#34;); } void pass(int \u0026amp;\u0026amp;x) { fmt::println(\u0026#34;general pass\u0026#34;); reference(x); } int main(int argc, char *argv[]) { pass(1); return 0; } 实现完美转发 万能引用 在普通函数中，若参数类型为 \u0026amp;\u0026amp;，则函数只能接受右值。\nvoid foo(int \u0026amp;\u0026amp;x) {} int main() { int a = 1; foo(1); // foo(a); 无法编译 } 但在模板函数中，若 \u0026amp;\u0026amp; 与模板参数结合，即 T\u0026amp;\u0026amp;，那么它将不再代表右值引用，而是万能引用。它既能接受左值，又能接受右值。\ntemplate \u0026lt;typename T\u0026gt; void foo(T \u0026amp;\u0026amp;x) { } int main(int argc, char *argv[]) { foo(1); // 传入右值 int a = 0; foo(a); // 传入左值 return 0; } 引用折叠规则 引用折叠规则是在对引用类型进行连续引用时所要遵循的规则。\n函数形参类型 实参参数类型 推导后函数形参类型 T\u0026amp; 左引用 T\u0026amp; T\u0026amp; 右引用 T\u0026amp; T\u0026amp;\u0026amp; 左引用 T\u0026amp; T\u0026amp;\u0026amp; 右引用 T\u0026amp;\u0026amp; 简而言之，当且仅当模板函数的形参与实参都是右引用时，形参才会被推导为右引用。\nstd::forward C++ 使用 std::forward 进行完美转发。std::forward 的实现如下：\n/** * @brief Forward an lvalue. * @return The parameter cast to the specified type. * * This function is used to implement \u0026#34;perfect forwarding\u0026#34;. */ template\u0026lt;typename _Tp\u0026gt; constexpr _Tp\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp; __t) noexcept { return static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t); } /** * @brief Forward an rvalue. * @return The parameter cast to the specified type. * * This function is used to implement \u0026#34;perfect forwarding\u0026#34;. */ template\u0026lt;typename _Tp\u0026gt; constexpr _Tp\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp; __t) noexcept { static_assert(!std::is_lvalue_reference\u0026lt;_Tp\u0026gt;::value, \u0026#34;template argument\u0026#34; \u0026#34; substituting _Tp is an lvalue reference type\u0026#34;); return static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t); } 其中 std::remove_reference 是一个模板类，它的实现如下：\ntemplate\u0026lt;class T\u0026gt; struct remove_reference { typedef T type; }; template\u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026gt; { typedef T type; }; template\u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; { typedef T type; }; 通过 std::remove_reference 将类型的引用去除，得到值类型。std::forward 有两个重载，分别匹配左值引用和右值引用，当匹配左值引用时，根据引用折叠规则，static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t) 返回左值引用，当匹配右值引用时，根据引用折叠规则，static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t) 返回右值引用。\n使用 std::forward #include \u0026lt;fmt/core.h\u0026gt; #include \u0026lt;utility\u0026gt; void reference(int \u0026amp;\u0026amp;x) { fmt::println(\u0026#34;rvalue\u0026#34;); } void reference(int \u0026amp;x) { fmt::println(\u0026#34;lvalue\u0026#34;); } template \u0026lt;typename T\u0026gt; void pass(T \u0026amp;\u0026amp;x) { fmt::println(\u0026#34;general pass\u0026#34;); reference(x); fmt::println(\u0026#34;forward pass\u0026#34;); reference(std::forward\u0026lt;T\u0026gt;(x)); } int main(int argc, char *argv[]) { pass(1); fmt::println(\u0026#34;===\u0026#34;); int a{1}; pass(a); return 0; } // general pass // lvalue // forward pass // rvalue // === // general pass // lvalue // forward pass // lvalue ","permalink":"https://tpcad.github.io/posts/cpp_perfect_forwarding.md/","summary":"\u003ch1 id=\"完美转发\"\u003e完美转发\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e转发\u003c/strong\u003e指的是函数之间的参数传递。比如下面的代码，函数 \u003ccode\u003efoo\u003c/code\u003e 向函数 \u003ccode\u003ebar\u003c/code\u003e 传递了参数 \u003ccode\u003ea\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e(a)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e b) {}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e完美转发\u003c/strong\u003e则是在转发过程中，参数的各种属性都保持不变。比如右值仍是右值，左值仍是左值。\u003c/p\u003e\n\u003ch2 id=\"普通转发的问题\"\u003e普通转发的问题\u003c/h2\u003e\n\u003cp\u003e在下面的代码中，函数 \u003ccode\u003epass\u003c/code\u003e 接受一个右值引用，并将该参数传递给函数 \u003ccode\u003ereference\u003c/code\u003e。当向 \u003ccode\u003epass\u003c/code\u003e 传入字面量 \u003ccode\u003e1\u003c/code\u003e 时，最终的输出结果是 \u003ccode\u003elvalue\u003c/code\u003e。这是因为虽然向 \u003ccode\u003epass\u003c/code\u003e 传入了右值，但在函数体内，变量 \u003ccode\u003ex\u003c/code\u003e 的值类别变成了\u003cstrong\u003e左值\u003c/strong\u003e，即 \u003ccode\u003ex\u003c/code\u003e 的类型是右值引用，值类别是左值，所以最终会调用 \u003ccode\u003ereference(int \u0026amp;y)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这就是普通转发存在的问题，在转发过程中可能会改变参数某些属性。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;fmt/core.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereference\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ey) { fmt\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;rvalue\u0026#34;\u003c/span\u003e); }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereference\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ey) { fmt\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;lvalue\u0026#34;\u003c/span\u003e); }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epass\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ex) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    fmt\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;general pass\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ereference\u003c/span\u003e(x);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e argc, \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eargv[]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003epass\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"实现完美转发\"\u003e实现完美转发\u003c/h2\u003e\n\u003ch3 id=\"万能引用\"\u003e万能引用\u003c/h3\u003e\n\u003cp\u003e在普通函数中，若参数类型为 \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e，则函数只能接受右值。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ex) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// foo(a); 无法编译\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但在模板函数中，若 \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e 与模板参数结合，即 \u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e，那么它将不再代表右值引用，而是\u003cstrong\u003e万能引用\u003c/strong\u003e。它既能接受左值，又能接受右值。\u003c/p\u003e","title":"How Perfect Forwarding Works"},{"content":"Rust Iterator 可迭代对象与迭代器（Iterable and Iterator） 迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：\n记录当前的迭代状态 产生可以访问下一个元素的迭代器 可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 Vec\u0026lt;T\u0026gt; 可以通过 iter 方法获得一个迭代器，但 Vec\u0026lt;T\u0026gt; 本省不是一个迭代器。\n一个可迭代对象通常有三个方法，分别对应三种迭代类型。\niter()，迭代 \u0026amp;T iter_mut()，迭代 \u0026amp;mut T into_iter()，迭代 T Iterator Trait Rust 迭代器的核心是 Iterator trait。Iterator trait 的核心代码看起来像下面这样：\ntrait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; } 关联类型 Item 表明迭代器返回的对象，next 方法表明迭代器如何返回该对象。\n实现 Iterator Trait 遍历 \u0026amp;T 假设有以下结构体，现在需要为 Todos 实现 Iterator trait。\npub struct Todos { pub list: Vec\u0026lt;Todo\u0026gt;, } #[derive(Debug)] pub struct Todo { pub message: String, pub done: bool, } 实现 Iterator trait 的关键是记录当前的迭代状态。Todos 使用一个 Vec\u0026lt;T\u0026gt; 来进行存储，非常适合用索引来记录迭代状态。我们可以为 Todos 添加一个 index 字段来记录迭代状态。但很显然，这并不妥当。当你对 Todos 进行迭代时会修改 index 字段的值，如果想要再次进行迭代，就必须重置 index 字段，因为迭代器不会在迭代结束后重置状态。\n所以我们更倾向于只把 Todos 当作一个可迭代对象，并用一个新的数据结构来记录迭代状态。\n下面是一个名为 TodosIterator 的结构体，它两个字段，todos 是对 Todos 的不可变引用，index 是一个 usize，用于记录当前的迭代状态。接下来将为 TodosIterator 实现 Iterator trait。\npub struct TodosIterator\u0026lt;\u0026#39;a\u0026gt; { todos: \u0026amp;\u0026#39;a Todos, index: usize, } 首先指定关联类型 Item 为 \u0026amp;'a Todo，这表明这个迭代器用于迭代 \u0026amp;T。\n接着实现 next 方法。通过比较当前 index 的值与 Vec 的长度判断是否迭代结束。若否，index 字段加 1，并返回当前索引对应的 Some(\u0026amp;Todo)。\nimpl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.index \u0026lt; self.todos.list.len() { let result = Some(\u0026amp;self.todos.list[self.index]); self.index += 1; result } else { None } } } 现在我们还需要为 Todos 实现一个用于产生迭代器的方法，使其成为可迭代对象。对于迭代 \u0026amp;T 的迭代器，这个方法通常是 iter()。\nimpl Todos { pub fn iter(\u0026amp;self) -\u0026gt; TodosIterator { TodosIterator { todos: self, index: 0, } } } 现在可以通过 iter 方法在 for 循环中迭代 Todos 了。\nfn main() { let todos = Todos { list: vec![ Todo { message: \u0026#34;Hello\u0026#34;.to_string(), done: false, }, Todo { message: \u0026#34;Rust\u0026#34;.to_string(), done: false, }, Todo { message: \u0026#34;World\u0026#34;.to_string(), done: false, }, ], }; for todo in todos.iter() { println!(\u0026#34;{todo:#?}\u0026#34;) } } IntoIterator Trait IntoIterator trait 的核心代码看起来像下面这样。它有一个 into_iter 方法，用于产生一个拥有对象所有权的迭代器。\n关联类型 Item 与 Iterator 的 Item 相同，IntoIter 是一个实现了 Iterator trait 的类型。 方法 into_iter 会获取对象的所有权，并返回 IntoIter。\npub trait IntoIterator { type Item; type IntoIter: Iterator\u0026lt;Item = Self::Item\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter; } Rust 在标准库中为所有实现了 Iterator trait 的类型实现了 IntoIterator。\nimpl\u0026lt;I: Iterator\u0026gt; IntoIterator for I 实现 IntoIterator Trait 遍历 T 因为 IntoIterator 会获取对象的所有权，所以不能继续使用 TodosIterator 来实现。我们使用一个新的结构体来实现。\npub struct TodosIntoIterator { todos: Todos, } 接着为 Todos 实现 IntoIterator。将关联类型 IntoIter 指定为 TodosIntoIterator，并在 into_iter 方法中返回一个 TodosIntoIterator。\nimpl IntoIterator for Todos { type Item = Todo; type IntoIter = TodosIntoIterator; fn into_iter(self) -\u0026gt; Self::IntoIter { TodosIntoIterator { todos: self } } } 因为 IntoIter 是一个实现了 Iterator trait 的类型，所以我们需要为 TodosIntoIterator 实现 Iterator trait。\n因为 TodosIntoIterator 拥有所有权，所以这里在每次迭代中删除 Vec 的第一个元素，这样迭代器总是指向这个元素。同时以 Vec 为空为迭代结束条件。\nimpl Iterator for TodosIntoIterator { type Item = Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.todos.list.is_empty() { return None; } let result = self.todos.list.remove(0); Some(result) } } 如此一来便能在 for 循环中遍历 todos 并获得其所有权。\nfor todo in todos { println!(\u0026#34;{todo:#?}\u0026#34;) } 实现 Iterator Trait 遍历 \u0026amp;mut T 要实现遍历 \u0026amp;mut T 的 Iterator trait 并不容易。\n若仿照 \u0026amp;T 来实现 \u0026amp;mut T，编译器会抱怨生命周期太短。\nimpl Todos { pub fn iter_mut(\u0026amp;mut self) -\u0026gt; TodosMutIterator { TodosMutIterator { todos: self, index: 0, } } } pub struct TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { todos: \u0026amp;\u0026#39;a mut Todos, index: usize, } impl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a mut Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.index \u0026lt; self.todos.list.len() { let result = Some(\u0026amp;mut self.todos.list[self.index]); self.index += 1; result } else { None } } } // error: lifetime may not live long enough // --\u0026gt; src/main.rs:87:13 // | // 81 | impl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { // | -- lifetime `\u0026#39;a` defined here // 82 | type Item = \u0026amp;\u0026#39;a mut Todo; // 83 | fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { // | - let\u0026#39;s call the lifetime of this reference `\u0026#39;1` // ... // 87 | result // | ^^^^^^ method was supposed to return data with lifetime `\u0026#39;a` but it is returning da // ta with lifetime `\u0026#39;1` iter_mut 方法通常用于返回一个可以遍历 \u0026amp;mut T 的迭代器。显然，迭代器只要能访问元素，并记录迭代状态就行了。因此我们可以借助 Vec 来实现 iter_mut 方法。\n创建一个类型为 Vec\u0026lt;\u0026amp;mut Todo\u0026gt; 的 Vec，并获取 Todos 的 Vec 的元素的可变引用，也就是 \u0026amp;mut Todo。最后对新的 Vec 调用方法 into_iter，返回一个可以以可变引用访问元素的迭代器。\n这样虽然不再需要额外的结构体，但每次遍历都需要创建一个新的 Vec。\nimpl Todos { pub fn iter_mut(\u0026amp;mut self) -\u0026gt; std::vec::IntoIter\u0026lt;\u0026amp;mut Todo\u0026gt; { let mut v: Vec\u0026lt;\u0026amp;mut Todo\u0026gt; = vec![]; for todo in self.list.iter_mut() { v.push(todo) } v.into_iter() } } 实现 IntoIterator Trait 遍历 \u0026amp;T 和 \u0026amp;mut T 只需要为对应的类型实现 IntoIterator trait，into_iter 方法就可以根据上下文返回遍历 \u0026amp;T、\u0026amp;mut T 或 T 的迭代器。\nimpl\u0026lt;\u0026#39;a\u0026gt; IntoIterator for \u0026amp;\u0026#39;a Todos { type Item = \u0026amp;\u0026#39;a Todo; type IntoIter = TodosIterator\u0026lt;\u0026#39;a\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter { self.iter() } } impl\u0026lt;\u0026#39;a\u0026gt; IntoIterator for \u0026amp;\u0026#39;a mut Todos { type Item = \u0026amp;\u0026#39;a mut Todo; type IntoIter = std::vec::IntoIter\u0026lt;\u0026amp;\u0026#39;a mut Todo\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter { self.iter_mut() } } 解引用裸指针实现 Iterator Trait 遍历 \u0026amp;mut T 此前编译器抱怨生命周期太短，可以通过解引用裸指针解决。\n这样做的本质是将变量的生命周期变为 'static。将一个值转化为原始指针后，它的生命周期信息会被丢弃，再次引用原始指针则会赋予静态生命周期。静态生命周期存活时间非常长，这样做会带来一些潜在的安全风险。\npub struct TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { todos: \u0026amp;\u0026#39;a mut Todos, index: usize, } impl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a mut Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.index \u0026lt; self.todos.list.len() { // 解引用裸指针 let result = unsafe { \u0026amp;mut *(\u0026amp;mut self.todos.list[self.index] as *mut _) }; self.index += 1; Some(result) } else { None } } } 如下代码所示，变量 a 是一个引用，它会指向 s1 或 s2 所指向的内容，而 s1 和 s2 在离开其作用域后会被清理，因为 a 拥有静态生命周期，所以它在离开作用域后仍能使用，而它所指向的内容已经被释放，这会导致访问到完全随机的数据。\nfn main() { let a; { let mut v1 = vec![2, 3]; let s1 = \u0026amp;mut v1; let mut v2 = vec![1, 8]; let s2 = \u0026amp;mut v2; a = test(s1, s2); } println!(\u0026#34;{a:?}\u0026#34;) } fn test\u0026lt;\u0026#39;a\u0026gt;(s1: \u0026amp;mut Vec\u0026lt;i32\u0026gt;, s2: \u0026amp;mut Vec\u0026lt;i32\u0026gt;) -\u0026gt; \u0026amp;\u0026#39;a mut Vec\u0026lt;i32\u0026gt; { let i = 2; if i == 1 { unsafe { \u0026amp;mut *(s1 as *mut _) } } else { unsafe { \u0026amp;mut *(s2 as *mut _) } } } // 一种可能的结果 // [-502036575, 23992] 参考资料 Effectively Using Iterators In Rust How do I create mutable iterator over struct fields Implementing Iterator and IntoIterator in Rust Does dereferencing a raw pointer back to a reference change the lifetime of the reference? Module std::iter ","permalink":"https://tpcad.github.io/posts/rust_iterator/","summary":"\u003ch1 id=\"rust-iterator\"\u003eRust Iterator\u003c/h1\u003e\n\u003ch2 id=\"可迭代对象与迭代器iterable-and-iterator\"\u003e可迭代对象与迭代器（Iterable and Iterator）\u003c/h2\u003e\n\u003cp\u003e迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e记录当前的迭代状态\u003c/li\u003e\n\u003cli\u003e产生可以访问下一个元素的迭代器\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 \u003ccode\u003eVec\u0026lt;T\u0026gt;\u003c/code\u003e 可以通过 \u003ccode\u003eiter\u003c/code\u003e 方法获得一个迭代器，但 \u003ccode\u003eVec\u0026lt;T\u0026gt;\u003c/code\u003e 本省不是一个迭代器。\u003c/p\u003e\n\u003cp\u003e一个可迭代对象通常有三个方法，分别对应三种迭代类型。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eiter()\u003c/code\u003e，迭代 \u003ccode\u003e\u0026amp;T\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eiter_mut()\u003c/code\u003e，迭代 \u003ccode\u003e\u0026amp;mut T\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einto_iter()\u003c/code\u003e，迭代 \u003ccode\u003eT\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"iterator-trait\"\u003eIterator Trait\u003c/h2\u003e\n\u003cp\u003eRust 迭代器的核心是 \u003ccode\u003eIterator\u003c/code\u003e trait。\u003ccode\u003eIterator\u003c/code\u003e trait 的核心代码看起来像下面这样：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etrait\u003c/span\u003e Iterator {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eItem\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enext\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003emut\u003c/span\u003e self) -\u0026gt; Option\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eSelf::Item\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e关联类型 \u003ccode\u003eItem\u003c/code\u003e 表明迭代器返回的对象，\u003ccode\u003enext\u003c/code\u003e 方法表明迭代器如何返回该对象。\u003c/p\u003e\n\u003ch3 id=\"实现-iterator-trait-遍历-t\"\u003e实现 Iterator Trait 遍历 \u0026amp;T\u003c/h3\u003e\n\u003cp\u003e假设有以下结构体，现在需要为 \u003ccode\u003eTodos\u003c/code\u003e 实现 \u003ccode\u003eIterator\u003c/code\u003e trait。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eTodos\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e list: Vec\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eTodo\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#[derive(Debug)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eTodo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e message: String,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e done: \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e实现 \u003ccode\u003eIterator\u003c/code\u003e trait 的关键是记录当前的迭代状态。\u003ccode\u003eTodos\u003c/code\u003e 使用一个 \u003ccode\u003eVec\u0026lt;T\u0026gt;\u003c/code\u003e 来进行存储，非常适合用索引来记录迭代状态。我们可以为 \u003ccode\u003eTodos\u003c/code\u003e 添加一个 \u003ccode\u003eindex\u003c/code\u003e 字段来记录迭代状态。但很显然，这并不妥当。当你对 \u003ccode\u003eTodos\u003c/code\u003e 进行迭代时会修改 \u003ccode\u003eindex\u003c/code\u003e 字段的值，如果想要再次进行迭代，就必须重置 \u003ccode\u003eindex\u003c/code\u003e 字段，因为迭代器不会在迭代结束后重置状态。\u003c/p\u003e","title":"Rust Iterator"},{"content":"Traits in Rust trait 定义了某个特定类型拥有可能与其他类型共享的功能。\n定义与实现 trait 定义 trait 一个 trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。\ntrait Area { fn area(\u0026amp;self) -\u0026gt; u32; } 为类型实现 trait 使用 impl for 为类型实现 trait。\nimpl Area for Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } impl Area for Circle { fn area(\u0026amp;self) -\u0026gt; u32 { 3 * self.radio * self.radio } } 默认实现 trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String { String::from(\u0026#34;(Read more...)\u0026#34;); } } // 因为有默认实现，所以可以指定一个空 impl 块 impl Summary for Tweet {} trait 作为参数 通过将 trait 作为函数参数，可以使该参数支持任何实现了指定 trait 的类型。\nimpl Trait 语法 fn notify(item: \u0026amp;impl Summary) { println!(\u0026#34;{}\u0026#34;, item.summarize()); } Trait Bound 语法 fn notify\u0026lt;T: Summary\u0026gt;(item: \u0026amp;T) { println!(\u0026#34;{}\u0026#34;, item.summarize()); } // 泛型限制了两个参数必须是相同类型 fn notify\u0026lt;T: Summary\u0026gt;(item1: \u0026amp;T, item2: \u0026amp;T) { // impl Trait 允许两个参数是不同类型 fn notify(item1: \u0026amp;impl Summary, item2: \u0026amp;impl Summary) { 通过 + 指定多个 trait bound fn notify(item: \u0026amp;(impl Summary + Display)) {} fn notify\u0026lt;T: Summary + Display\u0026gt;(item: \u0026amp;T) {} 通过 where 简化 trait bound fn some_function\u0026lt;T, U\u0026gt;(t: \u0026amp;T, u: \u0026amp;U) -\u0026gt; i32 where T: Display + Clone, U: Clone + Debug, { 返回实现了 trait 的类型 fn returns_summarizable() -\u0026gt; impl Summary { 注意，这只适用于返回单一类型的情况。\n使用 trait bound 有条件地实现方法 impl\u0026lt;T\u0026gt; Pair\u0026lt;T\u0026gt; { fn new(x: T, y: T) -\u0026gt; Self { Self { x, y } } } // 只有实现了 Display 和 PartialOrd Trait 的泛型 T 才会拥有这个方法 impl\u0026lt;T: Display + PartialOrd\u0026gt; Pair\u0026lt;T\u0026gt; { fn cmp_display(\u0026amp;self) { if self.x \u0026gt;= self.y { println!(\u0026#34;The largest member is x = {}\u0026#34;, self.x); } else { println!(\u0026#34;The largest member is y = {}\u0026#34;, self.y); } } } 也可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 blanket implementations\n// blanket implementations // 任何实现了 Display trait 的类型都会自动实现 ToString trait impl\u0026lt;T: Display\u0026gt; ToString for T { 孤儿规则 只有在 trait 或类型至少有一个属于当前 crate 时，才能对类型实现该 trait。\n比如，不能在自己的 crate 中为标准库中的类型实现标准库中的 trait。因为它们均不属于当前 crate。\nTrait 对象 泛型虽然很方便，但也有限制。比如，泛型限制了参数只能是同一种类型。\n如下代码所示，Vec 的元素必须是相同类型的。\ntrait Draw { fn draw(\u0026amp;self); } struct Button { name: String, } impl Draw for Button { fn draw(\u0026amp;self) { println!(\u0026#34;Draw button\u0026#34;); } } struct TextField { name: String, } impl Draw for TextField { fn draw(\u0026amp;self) { println!(\u0026#34;Draw text field\u0026#34;); } } fn main() { let vec = vec![ Box::new(Button { name: \u0026#34;button\u0026#34;.to_string(), }), // mismatched types expected `Button`, found `TextField` Box::new(TextField { name: \u0026#34;text field\u0026#34;.to_string(), }), ]; } Trait 对象则允许在运行时替代多种具体类型。\n// 使用 dyn 关键字声明 trait 对象 let vec: Vec\u0026lt;Box\u0026lt;dyn Draw\u0026gt;\u0026gt; = vec![ Box::new(Button { name: \u0026#34;button\u0026#34;.to_string(), }), Box::new(TextField { name: \u0026#34;text field\u0026#34;.to_string(), }), ]; for i in vec { i.draw(); } Rust 使用使用动态分发（Dynamic Dispatch）实现 trait 对象。此时编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。而编译器只能保证类型实现了相应的 trait。\n关联类型 关联类型（associated types）的作用与泛型十分相似，但关联类型限制了我们只能实现一次 trait。\npub trait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; } impl Iterator for Counter { // 只能指定一次 Item 的类型 type Item = u32; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { // --snip-- 默认泛型类型参数 在使用泛型类型参数时，可以为泛型指定一个默认的具体类型。\n// 提供默认的泛型类型参数 trait Add\u0026lt;Rhs=Self\u0026gt; { type Output; fn add(self, rhs: Rhs) -\u0026gt; Self::Output; } // 使用默认泛型类型参数 impl Add for Point { type Output = Point; fn add(self, other: Point) -\u0026gt; Point { Point { x: self.x + other.x, y: self.y + other.y, } } } // 不使用默认泛型类型参数 impl Add\u0026lt;Meters\u0026gt; for Millimeters { type Output = Millimeters; fn add(self, other: Meters) -\u0026gt; Millimeters { Millimeters(self.0 + (other.0 * 1000)) } } 完全限定语法 Rust 不能避免一个 trait 与另一个 trait 拥有同名的方法，也不能阻止为同一类型实现这两个 trait。\ntrait Pilot { fn fly(\u0026amp;self); } trait Wizard { fn fly(\u0026amp;self); } struct Human; // 实现两个有同名方法的 trait impl Pilot for Human { fn fly(\u0026amp;self) { println!(\u0026#34;Pilot fly\u0026#34;); } } impl Wizard for Human { fn fly(\u0026amp;self) { println!(\u0026#34;Wizard fly\u0026#34;); } } // 自身也实现该方法 impl Human { fn fly(\u0026amp;self) { println!(\u0026#34;Flying\u0026#34;); } } fn main() { let human = Human {}; // 默认调用自身实现 human.fly(); Wizard::fly(\u0026amp;human); Pilot::fly(\u0026amp;human); } 关联函数没有 \u0026amp;self 参数，不能使用上面的方法来消除歧义。此时只能使用完全限定语法（fully qualified syntax）。\n// 关联函数而非方法 trait Pilot { fn fly(); } trait Wizard { fn fly(); } struct Human; impl Pilot for Human { fn fly() { println!(\u0026#34;Pilot fly\u0026#34;); } } impl Wizard for Human { fn fly() { println!(\u0026#34;Wizard fly\u0026#34;); } } impl Human { fn fly() { println!(\u0026#34;Flying\u0026#34;); } } fn main() { Human::fly(); // 完全限定语法调用同名关联函数 \u0026lt;Human as Wizard\u0026gt;::fly(); \u0026lt;Human as Pilot\u0026gt;::fly(); } 父 trait 父 trait 可以让类型在一个 trait 的同时也必须实现另一个 trait。\nuse std::fmt; // 父 trait trait OutlinePrint: fmt::Display { fn outline_print(\u0026amp;self) { // 可以使用父 trait 的方法 let output = self.to_string(); let len = output.len(); println!(\u0026#34;{}\u0026#34;, \u0026#34;*\u0026#34;.repeat(len + 4)); println!(\u0026#34;*{}*\u0026#34;, \u0026#34; \u0026#34;.repeat(len + 2)); println!(\u0026#34;* {output} *\u0026#34;); println!(\u0026#34;*{}*\u0026#34;, \u0026#34; \u0026#34;.repeat(len + 2)); println!(\u0026#34;{}\u0026#34;, \u0026#34;*\u0026#34;.repeat(len + 4)); } } Sized Trait **动态大小类型（dynamically sized types）**允许我们处理只用在运行时才知道大小的类型。\n因为动态大小类型只能在运行时确定，所以它的值必须置于某种指针之后。\n比如 trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。所以它必须放在指针之后，\u0026amp;dyn trait 或 Box\u0026lt;dyn trait\u0026gt;。\n为了处理 DST，Rust 提供了 Sized trait 来决定一个类型的大小是否在编译时可知。这个 trait 会自动为所有在编译时就知道大小的类型实现。另外，Rust 会为每一个泛型函数增加 Sized bound。\nfn generic\u0026lt;T\u0026gt;(t: T){} fn generic\u0026lt;T: Sized\u0026gt;(t: T){} Sized trait 还有一个特殊的语法，?Sized。它表示该类型可能是也可能不是 Sized。该语法只能用于 Sized。\n// 参数类型从 T 变成了 \u0026amp;T，因为 DST 必须置于某种指针之后 fn generic\u0026lt;T: ?Sized\u0026gt;(t: \u0026amp;T){} #[derive(Debug)] struct Bar\u0026lt;T: ?Sized\u0026gt;(T); // [i32] 没有实现 Sized trait，所以它的大小在编译时是不可知的 // 如果不使用 ?Sized trait，以下代码将无法编译 fn main() { let sized: Bar\u0026lt;[i32; 8]\u0026gt; = Bar([0; 8]); let dynamic1: Box\u0026lt;Bar\u0026lt;[i32]\u0026gt;\u0026gt; = Box::new(Bar([])); let dynamic2: Box\u0026lt;Bar\u0026lt;[i32]\u0026gt;\u0026gt; = Box::new(sized); println!(\u0026#34;{:#?}\u0026#34;, dynamic1); println!(\u0026#34;{:#?}\u0026#34;, dynamic2); } ","permalink":"https://tpcad.github.io/posts/rust_trait/","summary":"\u003ch1 id=\"traits-in-rust\"\u003eTraits in Rust\u003c/h1\u003e\n\u003cp\u003etrait 定义了某个特定类型拥有可能与其他类型共享的功能。\u003c/p\u003e\n\u003ch2 id=\"定义与实现-trait\"\u003e定义与实现 trait\u003c/h2\u003e\n\u003ch3 id=\"定义-trait\"\u003e定义 trait\u003c/h3\u003e\n\u003cp\u003e一个 trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etrait\u003c/span\u003e Area {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earea\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eself) -\u0026gt; \u003cspan style=\"color:#66d9ef\"\u003eu32\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"为类型实现-trait\"\u003e为类型实现 trait\u003c/h3\u003e\n\u003cp\u003e使用 \u003ccode\u003eimpl for\u003c/code\u003e 为类型实现 trait。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eimpl\u003c/span\u003e Area \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e Rectangle {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earea\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eself) -\u0026gt; \u003cspan style=\"color:#66d9ef\"\u003eu32\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self.width \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e self.height\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eimpl\u003c/span\u003e Area \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e Circle {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earea\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eself) -\u0026gt; \u003cspan style=\"color:#66d9ef\"\u003eu32\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e self.radio \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e self.radio\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"默认实现\"\u003e默认实现\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etrait\u003c/span\u003e Summary {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esummarize\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eself) -\u0026gt; String {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        String::from(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;(Read more...)\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 因为有默认实现，所以可以指定一个空 impl 块\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eimpl\u003c/span\u003e Summary \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e Tweet {}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"trait-作为参数\"\u003etrait 作为参数\u003c/h2\u003e\n\u003cp\u003e通过将 trait 作为函数参数，可以使该参数支持任何实现了指定 trait 的类型。\u003c/p\u003e","title":"Rust Traits"},{"content":"在 Rust 中使用线程 线程基础 创建线程 使用 thread::spawn 创建线程，它接受一个 FnOnce 闭包。\nuse std::{thread, time::Duration}; fn main() { let handle = thread::spawn(|| { for i in 0..10 { println!(\u0026#34;{i}: spawned thread echo\u0026#34;); thread::sleep(Duration::from_millis(10)); } }); for i in 0..5 { println!(\u0026#34;{i}: main thread echo\u0026#34;); thread::sleep(Duration::from_millis(10)); } handle.join().unwrap(); } 等待线程结束 使用 join 方法等待线程结束。\nlet handle = thread::spawn(|| { for i in 0..10 { println!(\u0026#34;{i}: spawned thread echo\u0026#34;); thread::sleep(Duration::from_millis(10)); } }); // 对 spawn 的返回值调用 join 方法 handle.join().unwrap(); move 闭包与线程 use std::thread; fn main() { let v = vec![1, 2, 3]; // 使用 move 获取所有权 let handle = thread::spawn(move || { println!(\u0026#34;Here\u0026#39;s a vector: {v:?}\u0026#34;); }); handle.join().unwrap(); } 消息传递 Rust 通过**信道（channel）**实现消息传递。\n信道由两部分组成：一个发送者（transmitter）和接收者（receiver）。当任一方被丢弃时可以认为信道被关闭了。\nRust 的信道实现在 std::sync::mpsc 中。\nmpsc::channel 函数用于创建一个信道。它会返回一个元祖，第一个元素是发送者，第二个元素是接收者。\n发送者调用 send 方法发送消息。它的参数就是要发送的值。它返回一个 Result\u0026lt;(), SendError\u0026lt;T\u0026gt;\u0026gt;。错误通常发生在接收者已经被丢弃时。\n注意，send 方法会获取参数的所有权。\n接受者调用 recv 方法接收消息。该方法会阻塞线程执行直到从信道中获取一个值。若信道已经被关闭，则会返回一个错误。\n另外还有 try_recv 方法可以接收信息。这个方法不会阻塞线程，而是立刻返回一个 Result。\nuse std::{sync::mpsc, thread}; fn main() { // mpsc:;channel 创建一个信道。 let (tx, rx) = mpsc::channel(); thread::spawn(move || { let val = \u0026#34;hello\u0026#34;.to_owned(); // 调用 send 方法发送消息 tx.send(val).unwrap(); }); // 接收者调用 recv 方法接收消息 let rec = rx.recv().unwrap(); println!(\u0026#34;{rec} from spwaned thread\u0026#34;); } 创建多个发送者 可以使用 clone 方法创建多个发送者。同时，将接收者当作一个迭代器不断从信道中获取消息。\nuse std::{sync::mpsc, thread}; fn main() { let (tx, rx) = mpsc::channel(); let tx1 = tx.clone(); thread::spawn(move || { let val = \u0026#34;hello\u0026#34;.to_owned(); tx.send(val).unwrap(); }); thread::spawn(move || { let val = \u0026#34;hello\u0026#34;.to_owned(); tx1.send(val).unwrap(); }); for rec in rx { println!(\u0026#34;{rec} from spwaned thread\u0026#34;); } } 互斥器 互斥器保证在任意时刻，只有一个线程访问某些数据。\n在 Rust 中通过 Mutex\u0026lt;T\u0026gt; 创建一个互斥锁。访问互斥器的数据前需要获取锁。lock 方法返回一个类型为 MutexGuard 的智能指针。在 MutexGuard 离开作用域时，会调用 Drop trait 释放锁。\nuse std::sync::Mutex; fn main() { let m = Mutex::new(5); { let mut num = m.lock().unwrap(); *num = 6; } println!(\u0026#34;m = {m:?}\u0026#34;); } Mutex\u0026lt;T\u0026gt; 并不能直接用于多线程。Arc\u0026lt;T\u0026gt; 是一个类似 Rc\u0026lt;T\u0026gt; 但可用于多线程的智能指针。\nuse std::{ sync::{Arc, Mutex}, thread, }; fn main() { // 将 Mutex\u0026lt;T\u0026gt; 放在 Arc\u0026lt;T\u0026gt; 中 let counter = Arc::new(Mutex::new(0)); let mut handlers = vec![]; for _ in 0..10 { let counter = Arc::clone(\u0026amp;counter); let handler = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; println!(\u0026#34;counter: {num}\u0026#34;); }); handlers.push(handler); } for handler in handlers { handler.join().unwrap(); } // println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); } ","permalink":"https://tpcad.github.io/posts/rust_thread/","summary":"\u003ch1 id=\"在-rust-中使用线程\"\u003e在 Rust 中使用线程\u003c/h1\u003e\n\u003ch2 id=\"线程基础\"\u003e线程基础\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e创建线程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用 \u003ccode\u003ethread::spawn\u003c/code\u003e 创建线程，它接受一个 \u003ccode\u003eFnOnce\u003c/code\u003e 闭包。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003euse\u003c/span\u003e std::{thread, time::Duration};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e handle \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e thread::spawn(\u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e..\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{i}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e: spawned thread echo\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            thread::sleep(Duration::from_millis(\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e..\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{i}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e: main thread echo\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        thread::sleep(Duration::from_millis(\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    handle.join().unwrap();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e等待线程结束\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用 \u003ccode\u003ejoin\u003c/code\u003e 方法等待线程结束。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e handle \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e thread::spawn(\u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e..\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{i}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e: spawned thread echo\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        thread::sleep(Duration::from_millis(\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 对 spawn 的返回值调用 join 方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003ehandle.join().unwrap();\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003emove 闭包与线程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003euse\u003c/span\u003e std::thread;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e v \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e vec![\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 使用 move 获取所有权\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e handle \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e thread::spawn(\u003cspan style=\"color:#66d9ef\"\u003emove\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Here\u0026#39;s a vector: \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{v:?}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    handle.join().unwrap();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"消息传递\"\u003e消息传递\u003c/h2\u003e\n\u003cp\u003eRust 通过**信道（channel）**实现消息传递。\u003c/p\u003e","title":"Thread in Rust"},{"content":"Selection Sort 以升序为例，选择排序的思想是遍历未排序元素，选择其中最小的元素，将其移动到未排序元素开始位置。因此选择排序的最优时间复杂度、平均时间复杂度、最坏时间复杂度都是 $O(n^2)$。选择排序是一种不稳定的排序算法。\n假设有数组 3, 4, 1, 9, 5, 8, 0。\n以升序为例，选择索引为 0 的元素，将它和其后的每一个元素比较，若所选元素较大，则交换二者位置。再选择索引为 1 的元素，将它和其后的每一个元素比较，若所选元素较大，则交换二者位置。依此类推，直至倒数第二个元素。\n// 第一轮 [0, 4, 3, 9, 5, 8, 1] // 第二轮，从索引为 1 的元素开始 [0, 1, 4, 9, 5, 8, 3] // 第三轮，从索引为 2 的元素开始 [0, 1, 3, 9, 5, 8, 4] // ... void selection_sort(int *arr, int len) { for (int i = 0; i \u0026lt; len - 1; ++i) { int min_idx = i; int j = i + 1; for (; j \u0026lt; len; ++j) { if (arr[min_idx] \u0026gt; arr[j]) { min_idx = j; } } swap(\u0026amp;arr[i], \u0026amp;arr[min_idx]); } } Bubble Sort 以升序为例，在未排序元素中依次比较相邻两个元素，若乱序则交换两个元素，这样一来较大的元素就会被慢慢移动到末尾有序排列。通常在冒泡排序中设置一个 flag，当没有发生比较操作时，说明数组已经有序，停止遍历。冒泡排序的最优时间复杂度为 $O(n)$（正序），最坏时间复杂度为 $O(n^2)$（逆序），平均时间复杂度为 $O(n^2)$。冒泡排序是一种稳定的排序算法。\n假设有数组 3, 4, 1, 9, 5, 8, 0。\n以升序为例，比较索引为 0 的元素和索引为 1 的元素，若前者大于后者，交换二者位置。接着比较索引为 1 的元素和索引为 2 的元素，若前者大于后者，交换二者位置。依次类推，直至最后一组相邻元素。然后再从头开始比较相邻的两个元素，此次不包括最后一个元素。\n// 第一轮 [3, 1, 4, 5, 8, 0, 9] // 第二轮，不包括最后一个元素 [1, 3, 4, 5, 0, 8, 9] // 第三轮，不包括最后两个元素 [1, 3, 4, 0, 5, 8, 9] // ... fn main() { let mut arr = [1, 2, 6, 3, 7, 3, 9, 4, 0]; let mut flag = true; while flag { flag = false; for j in 0..arr.len() - 1 { if arr[j] \u0026gt; arr[j + 1] { flag = true; arr.swap(j, j + 1) } } } println!(\u0026#34;{:#?}\u0026#34;, arr) } 上面的实现每次都要比较到数组的最后，而每次遍历之后尾部的元素都是有序的，并不需要再进行比较，因此可以记录上次交换操作的位置，下一轮循环就可以在该位置结束，因为后面的元素已经是有序的了。\nfn main() { let mut arr = [1, 2, 6, 3, 7, 3, 9, 4, 0]; let mut unsorted = arr.len() - 1; while unsorted != 0 { let mut u = 0; for j in 0..unsorted { if arr[j] \u0026gt; arr[j + 1] { arr.swap(j, j + 1); u = j; // 记录上次比较操作的位置 } } unsorted = u; } println!(\u0026#34;{:#?}\u0026#34;, arr) } Insertion Sort 以升序为例，插入排序将数组分成未排序和已排序两部分，每次从未排序部分按顺序选择一个元素与已排序部分比较，将其插入到合适位置。插入排序的最优时间复杂度为 $O(n)$（正序），最坏时间复杂度为 $O(n^2)$（逆序），平均时间复杂度为 $O(n^2)$。冒泡排序是一种稳定的排序算法。\n假设有数组 3, 1, 4, 9, 5, 8, 0。\n视索引为 0 的元素为已排序部分，剩下元素为未排序部分。选择未排序部分的第一个元素 1 与已排序部分元素倒序比较，插入合适位置。\n// 初始状态 [3, 1, 4, 9, 5, 8, 0] // 第一轮 [1, 3, 4, 9, 5, 8, 0] // 第二轮 [1, 3, 4, 9, 5, 8, 0] void insertion_sort(int a[], int len) { for (auto i = 1; i \u0026lt; len; ++i) { int key = a[i]; int j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt; key) { a[j + 1] = a[j]; --j; } a[j + 1] = key; } } 在将元素插入到已排序部分的操作中，可以使用二分查找法优化，但不会改变时间复杂度。\nTODO: 折半插入排序\nShell Sort 希尔排序，又叫缩小增量排序，是插入排序的一种改良版本。希尔排序充分利用了插入排序的两个优点：\n插入排序在数组几乎有序时效率极高 插入排序在元素数量较少时效率极高 希尔排序依据间距将数组分为若干子序列，并对子序列进行插入排序，然后缩小间距，产生新的子序列，再对新的子序列进行插入排序，如此往复，直至间距为 1，此时再进行插入排序就是对整个数组进行插入排序。\n// 待排序数组 [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] // 假设间距为 4，则可得以下子序列 [3, 23, 9] [54, 11, 12] [35, 74, 45] [87, 2, 53] // 对子序列进行插入排序 [3, 11, 35, 9, 2, 12, 45, 53, 23, 54, 74, 87] // 取间距为 1 [2, 3, 9, 11, 12, 23, 35, 45, 53, 54, 74, 87] 如果直接使用类似前文的插入排序算法，需要用到四层循环。而下面的插入排序只需要三层循环，这种形式的插入排序并不会一次性将子序列排序，而是每次只排序一个子序列的一个元素。\nvoid shell_sort(int *arr, int len) { int d = 1; while (d \u0026lt; len / 3) { d = d * 3 + 1; } while (d \u0026gt;= 1) { // i 从间距 d 开始，将前面的排序视为每个子序列已排序部分，每次自增 1， // 每次只排序一个子序列的一个元素，i 每自增 d 次就表示所有子序列都排序 // 了一个元素 for (int i = d; i \u0026lt; len; ++i) { int key = arr[i]; int j = i - d; for (; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key; j -= d) { arr[j + d] = arr[j]; } arr[j + d] = key; } // 直接使用插入排序 // for (int i = 0; i \u0026lt; d; ++i) { // for (int j = i + d; j \u0026lt; len; j += d) { // int key = arr[j]; // int k = j - d; // while (k \u0026gt;= 0 \u0026amp;\u0026amp; arr[k] \u0026gt; key) { // arr[k + d] = arr[k]; // k -= d; // } // arr[k + d] = key; // } // } d /= 3; } } 希尔排序的时间复杂度与间距的选择有关，最好时间复杂度为 $O(nlog^2n)$，最坏时间复杂度为 $O(n^2)$，平均时间复杂度为 $O(nlog^2n)$。希尔排序是不稳定排序。\nQuick Sort 快速排序是一种递归的排序算法，它将数组以某个元素为基准，划分为小于基准和大于基准的两部分，再分别在这两个部分中执行相同操作直至不能再划分。\n[3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] // 以 53 为基准，与 l 比较，小于或等于则 l+1，并继续比较 l， // 大于则将 l 移动到 r，且 r+1，并比较 r，如此往复。 [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] ^l ^r [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] ^l ^r [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 54] ^l ^r [3, 45, 35, 87, 23, 11, 74, 2, 9, 12, 45, 54] ^l ^r [3, 45, 35, 87, 23, 11, 74, 2, 9, 12, 45, 54] ^l ^r [3, 45, 35, 87, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 74, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 9, 2, 9, 74, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 9, 2, 9, 74, 87, 54] ^lr [3, 45, 35, 12, 23, 11, 9, 2, 53, 74, 87, 54] ^lr static int partition(int *arr, int low, int high) { int pivot = arr[low]; while (low \u0026lt; high) { while (low \u0026lt; high \u0026amp;\u0026amp; pivot \u0026lt;= arr[high]) { --high; } arr[low] = arr[high]; while (low \u0026lt; high \u0026amp;\u0026amp; pivot \u0026gt;= arr[low]) { ++low; } arr[high] = arr[low]; } arr[low] = pivot; return low; } static void quick_sort_helper(int *arr, int lhs, int rhs) { if (lhs \u0026lt; rhs) { int pivot = partition(arr, lhs, rhs); quick_sort_helper(arr, lhs, pivot - 1); quick_sort_helper(arr, pivot + 1, rhs); } } void quick_sort(int *arr, const int len) { quick_sort_helper(arr, 0, len - 1); } 快速排序的最优时间复杂度和平均时间复杂度为 $O(n\\log n)$，最坏时间复杂度为 $O(n^2)$，平均时间复杂度为 $O(n\\log n)$。因为快速排序是递归的，需要额外的调用栈，因此快速排序的空间复杂度为 $O(\\log n)$。快速排序是不稳定的排序算法。\nMerge Sort 归并排序基于分治思想将数组分段排序后合并。分段操作，当只有一个元素时，数组有序，不再分段，当元素大于 1 时，数组被递归地分成有序的两部分；合并操作，借助额外的数组，有序地将两部分数组中最小的元素放入额外数组，再用额外数组覆盖原数组。时间复杂度在最优、最坏与平均情况下均为 $O(n \\log n)$，空间复杂度为 $O(n)$。\nstatic void merge(int *arr, int l, int r, int len) { int *tmp = (int *)malloc(sizeof(int) * len); if (tmp == NULL) { printf(\u0026#34;Can not allocate memory!\\n\u0026#34;); exit(1); } int mid = (l + r) \u0026gt;\u0026gt; 1; int i = l, j = mid, k = l; // index variable while (i \u0026lt; mid \u0026amp;\u0026amp; j \u0026lt; r) { if (arr[i] \u0026lt;= arr[j]) { tmp[k++] = arr[i++]; } else { tmp[k++] = arr[j++]; } } if (j == r) { while (i \u0026lt; mid) { tmp[k++] = arr[i++]; } } else { while (j \u0026lt; r) { tmp[k++] = arr[j++]; } } for (k = l; k \u0026lt; r; ++k) { arr[k] = tmp[k]; } free(tmp); } static void merge_sort_helper(int *arr, int l, int r, int len) { if (r - l \u0026lt;= 1) { return; } int mid = (r + l) \u0026gt;\u0026gt; 1; merge_sort_helper(arr, l, mid, len); merge_sort_helper(arr, mid, r, len); merge(arr, l, r, len); } void merge_sort(int *arr, const int len) { merge_sort_helper(arr, 0, len, len); } 归并排序求逆序对数量 逆序对是 i \u0026lt; j 且 $a_i \u0026gt; a_j$ 的有序数对 (i, j)。\n在归并排序进行合并操作时，若出现左子序列元素 a 大于右子序列元素 b，则说明左子序列元素 a 及左子序列剩余元素都大于右子序列元素 b。\n设全局变量 cnt = 0 以记录逆序对个数。在合并操作中添加 cnt += mid - i 即可记录逆序对个数。\nwhile (i \u0026lt; mid \u0026amp;\u0026amp; j \u0026lt; r) { if (arr[i] \u0026lt;= arr[j]) { tmp[k++] = arr[i++]; } else { tmp[k++] = arr[j++]; cnt += mid - i; // 记录逆序对个数 } } Heap Sort Heap\n","permalink":"https://tpcad.github.io/posts/sort_algorithm/","summary":"\u003ch2 id=\"selection-sort\"\u003eSelection Sort\u003c/h2\u003e\n\u003cp\u003e以升序为例，选择排序的思想是遍历未排序元素，选择其中最小的元素，将其移动到未排序元素开始位置。因此选择排序的最优时间复杂度、平均时间复杂度、最坏时间复杂度都是 $O(n^2)$。选择排序是一种不稳定的排序算法。\u003c/p\u003e\n\u003cp\u003e假设有数组 \u003ccode\u003e3, 4, 1, 9, 5, 8, 0\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e以升序为例，选择索引为 0 的元素，将它和其后的每一个元素比较，若所选元素较大，则交换二者位置。再选择索引为 1 的元素，将它和其后的每一个元素比较，若所选元素较大，则交换二者位置。依此类推，直至倒数第二个元素。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 第一轮\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 第二轮，从索引为 1 的元素开始\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 第三轮，从索引为 2 的元素开始\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// ...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eselection_sort\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003earr, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e len) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e len \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e min_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e i;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (; j \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e len; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ej) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (arr[min_idx] \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e arr[j]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                min_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e j;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eswap\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003earr[i], \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003earr[min_idx]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"bubble-sort\"\u003eBubble Sort\u003c/h2\u003e\n\u003cp\u003e以升序为例，在未排序元素中依次比较相邻两个元素，若乱序则交换两个元素，这样一来较大的元素就会被慢慢移动到末尾有序排列。通常在冒泡排序中设置一个 \u003ccode\u003eflag\u003c/code\u003e，当没有发生比较操作时，说明数组已经有序，停止遍历。冒泡排序的最优时间复杂度为 $O(n)$（正序），最坏时间复杂度为 $O(n^2)$（逆序），平均时间复杂度为 $O(n^2)$。冒泡排序是一种稳定的排序算法。\u003c/p\u003e","title":"Classic Sort Algorithm"},{"content":"Smart Pointer in Rust Box Box 是最简单的智能指针，它允许你将一个值放在堆上而不是栈上。\nfn main() { let f1 = foo { bar: 32 }; let f2 = Box::new(foo { bar: 11 }); println!(\u0026#34;address on stack: {:p}\u0026#34;, \u0026amp;f1); println!(\u0026#34;address on heap: {:p}\u0026#34;, f2); println!(\u0026#34;address of box(on stack): {:p}\u0026#34;, \u0026amp;f2); } struct foo { bar: i32, } // address on stack: 0x7ffd34540f0c // address on heap: 0x57d39e669ba0 // address of box(on stack): 0x7ffd34540f10 Box 只提供了间接存储和堆分配，除此之外没有其他特殊功能。\n// 利用 Box 实现递归类型 enum List { Cons(i32, Box\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); } Deref Trait 实现 Deref trait 可以重载解引用运算符 *。\nuse std::ops::Deref; fn main() { let a = 4; let b = MyBox::new(a); println!(\u0026#34;{:?}\u0026#34;, *b); assert_eq!(4, *b); } #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } // 为结构体实现 Deref Trait impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target { \u0026amp;self.0 } } 在执行 *y 时，Rust 会将其替换为 *(y.deref())。\nDeref 强制转换 Deref 强制转换（Deref coercions） 将实现了 Deref trait 的类型的引用转换为另一种类型的引用。比如将 \u0026amp;String 转换为 \u0026amp;str。\nDeref 强制转换发生在编译时，因此并没有运行时损耗。\nDeref trait 用于重载不可变引用的解引用运算符，而 DerefMut trait 用于重载可变引用的解引用运算符。\nRust 在发现类型和 trait 满足三种情况时会进行 Deref 强制转换：\n当 T: Deref\u0026lt;Target=U\u0026gt; 时从 \u0026amp;T 到 \u0026amp;U。 当 T: DerefMut\u0026lt;Target=U\u0026gt; 时从 \u0026amp;mut T 到 \u0026amp;mut U。 当 T: Deref\u0026lt;Target=U\u0026gt; 时从 \u0026amp;mut T 到 \u0026amp;U。 Drop Trait Drop trait 允许我们在值要离开作用域时执行一些代码。\nuse std::ops::Deref; fn main() { let a = 4; let b = MyBox::new(a); assert_eq!(4, *b); } #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } // 为结构体实现 Deref Trait impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target { \u0026amp;self.0 } } // 为结构体实现 Drop trait impl\u0026lt;T\u0026gt; Drop for MyBox\u0026lt;T\u0026gt; { fn drop(\u0026amp;mut self) { println!(\u0026#34;Drop MyBox\u0026#34;); } } Rust 不允许直接调用 Drop trait 的 drop 方法。因为 Rust 仍然会在值离开作用域时自动调用，这会导致二次释放的错误。\n若要强制提前清理值，可以使用 std::mem::drop 函数。\nlet b = MyBox::new(24); // std::mem::drop 位于 prelude 中 drop(b); Rc 有时候一个值会有多个所有者。比如图的节点会被多条边连接。\nRc\u0026lt;T\u0026gt; 允许我们在堆上分配一些可以被程序的多个部分读取的内存。Rc\u0026lt;T\u0026gt; 只用于不可变引用且只能用于单线程场景。\nuse std::rc::Rc; #[derive(Debug)] enum List { // 使用 Rc\u0026lt;T\u0026gt; 存储 List Cons(i32, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let a = Rc::new(Cons(24, Rc::new(Cons(25, Rc::new(Nil))))); println!(\u0026#34;{:p}\u0026#34;, a); // Rc 重载了 Deref trait，返回 T if let Cons(_, i) = \u0026amp;*a { println!(\u0026#34;{:p}\u0026#34;, i); if let Cons(_, k) = \u0026amp;**i { println!(\u0026#34;{:p}\u0026#34;, k) } } // 通过 Rc::strong_count(\u0026amp;a) 查看引用计数 println!(\u0026#34;{}\u0026#34;, Rc::strong_count(\u0026amp;a)); // Rc::clone() 增加引用计数，Rc 的 clone 方法的效果与 Rc::clone 相同 let b = Rc::clone(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, Rc::strong_count(\u0026amp;b)); let c = Rc::clone(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, Rc::strong_count(\u0026amp;c)); // 普通的不可变引用，在栈上配分内存 let d = \u0026amp;a; println!(\u0026#34;{:p}\u0026#34;, d); } RefCell **内部可变性（Interior mutability）**是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。\n#[derive(Debug)] enum List { Cons(Rc\u0026lt;RefCell\u0026lt;i32\u0026gt;\u0026gt;, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; use std::cell::RefCell; use std::rc::Rc; fn main() { let value = Rc::new(RefCell::new(5)); let a = Rc::new(Cons(Rc::clone(\u0026amp;value), Rc::new(Nil))); let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(\u0026amp;a)); let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(\u0026amp;a)); // value 本身不可变，但可以通过 RefCell\u0026lt;T\u0026gt; 的 borrow_mut 方法修改其内部的值 // borrow_mut 返回 RefMut\u0026lt;T\u0026gt;，类似 \u0026amp;mut *value.borrow_mut() += 10; println!(\u0026#34;a after = {a:?}\u0026#34;); println!(\u0026#34;b after = {b:?}\u0026#34;); println!(\u0026#34;c after = {c:?}\u0026#34;); if let Cons(i, k) = b { println!(\u0026#34;{:#?}\u0026#34;, i); *i.borrow_mut() += 10; println!(\u0026#34;{:#?}\u0026#34;, i); if let Cons(x, _) = \u0026amp;*k { println!(\u0026#34;{:#?}\u0026#34;, x); *x.borrow_mut() += 10; println!(\u0026#34;{:#?}\u0026#34;, x); } } } Weak use std::cell::RefCell; use std::rc::{Rc, Weak}; #[derive(Debug)] struct Node { value: i32, parent: RefCell\u0026lt;Weak\u0026lt;Node\u0026gt;\u0026gt;, children: RefCell\u0026lt;Vec\u0026lt;Rc\u0026lt;Node\u0026gt;\u0026gt;\u0026gt;, } fn main() { let leaf = Rc::new(Node { value: 3, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![]), }); println!( \u0026#34;leaf strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;leaf), // 查看实例的弱引用计数 Rc::weak_count(\u0026amp;leaf), ); { let branch = Rc::new(Node { value: 5, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![Rc::clone(\u0026amp;leaf)]), }); // 创建弱引用 *leaf.parent.borrow_mut() = Rc::downgrade(\u0026amp;branch); println!( \u0026#34;branch strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;branch), Rc::weak_count(\u0026amp;branch), ); println!( \u0026#34;leaf strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;leaf), Rc::weak_count(\u0026amp;leaf), ); } // upgrade() 方法检查所引用的实例是否还存在，返回 Option println!(\u0026#34;leaf parent = {:?}\u0026#34;, leaf.parent.borrow().upgrade()); println!( \u0026#34;leaf strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;leaf), Rc::weak_count(\u0026amp;leaf), ); } ","permalink":"https://tpcad.github.io/posts/rust_smart_pointer/","summary":"\u003ch1 id=\"smart-pointer-in-rust\"\u003eSmart Pointer in Rust\u003c/h1\u003e\n\u003ch2 id=\"boxt\"\u003eBox\u003c!-- raw HTML omitted --\u003e\u003c/h2\u003e\n\u003cp\u003eBox 是最简单的智能指针，它允许你将一个值放在堆上而不是栈上。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e f1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e foo { bar: \u003cspan style=\"color:#ae81ff\"\u003e32\u003c/span\u003e };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e f2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Box::new(foo { bar: \u003cspan style=\"color:#ae81ff\"\u003e11\u003c/span\u003e });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;address on stack: \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{:p}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ef1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;address on heap: \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{:p}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, f2);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;address of box(on stack): \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{:p}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ef2);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    bar: \u003cspan style=\"color:#66d9ef\"\u003ei32\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// address on stack: 0x7ffd34540f0c\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// address on heap: 0x57d39e669ba0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// address of box(on stack): 0x7ffd34540f10\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBox 只提供了间接存储和堆分配，除此之外没有其他特殊功能。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 利用 Box 实现递归类型\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eList\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Cons(\u003cspan style=\"color:#66d9ef\"\u003ei32\u003c/span\u003e, Box\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eList\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Nil,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003euse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ecrate\u003c/span\u003e::List::{Cons, Nil};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e list \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Cons(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, Box::new(Cons(\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, Box::new(Cons(\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, Box::new(Nil))))));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"deref-trait\"\u003eDeref Trait\u003c/h2\u003e\n\u003cp\u003e实现 \u003ccode\u003eDeref\u003c/code\u003e trait 可以重载解引用运算符 \u003ccode\u003e*\u003c/code\u003e。\u003c/p\u003e","title":"Rust Smart Pointer"},{"content":"Hugo + Github Action，搭建个人博客 创建 Github 仓库 创建博客源仓库 博客源仓库用于对 Hugo 的配置文件以及 Markdown 源文件进行备份和管理，并配合 Github Action 自动将生成的静态网页推送到 Github Pages 仓库。\n创建 Github Pages 仓库 以 username.github.io 形式命名的特殊仓库，使用 Github Pages 实现部署网站。\n创建博客 hugo new site Blog Hugo 生成的目录结构。\nBlog ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── i18n ├── layouts ├── static └── themes 关联博客源仓库 cd Blog git init git remote add origin git@github.com:TPCAD/tpcad-blog.git 配置 Hugo 主题 为了方便对主题进行自定义和版本控制，我们将 Hugo 主题 fork 到自己的 Github 账户，并以 submodule 的方式将主题添加到我们的博客源仓库。\ngit submodule add https://github.com/TPCAD/hugo-PaperMod.git themes/hugo-PaperMod 关于 PaperMod 主题的配置，见官方文档。\n如果需要同步主题仓库的最新修改，运行如下命令：\ngit submodule update --remote 关联 Github Pages 仓库 Hugo 默认会将生成的静态网页存放在 public 目录。我们可以将 Github Pages 仓库以子模块的方式添加到博客源仓库。\n# 生成静态网页 hugo cd public # 在 public 目录下建立 git 仓库，并关联远程仓库 git init git remote add git@github.com:TPCAD/tpcad.github.io.git # 进行一次 push，因为无法添加空的远程仓库作为子模块 git add . git commit -m \u0026#34;init\u0026#34; git push -u origin master # 回到根目录添加子模块 cd .. git submodule add git@github.com:TPCAD/tpcad.github.io.git public 现在已经可以通过 `username.tpcad.io\u0026rsquo; 访问访问博客了。\n自动发布 借助 Github Action，可以实现在博客源仓库提交后，自动生成静态网页并推送到 Github Pages 仓库。\n访问 Token 因为需要推送到外部仓库，我们要先获取一个访问 Token。\n进入 Github，在 Settings -\u0026gt; Developer Setttings -\u0026gt; Personal access tokens -\u0026gt; Generate new token(classic 创建一个 Token。\nSocpes 选择 repo 和 workfolw 。\n复制该 Token（Token 只会出现一次）到博客源仓库的 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; Repository secrets 创建一个 Repository secrets。\n创建 Github Action 在博客源仓库目录下创建 .github/workflows/deploy.yml。\n配置如下。将 EXTERNAL_REPOSITORY 替换为自己的 Github Pages 仓库。\nname: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: TPCAD/tpcad.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 同步修改后，以后只需要在博客源仓库进行 push 就会自动将内容推送到 Github Pages 仓库中。\n常见问题 Github Pages 仓库没有启用 Github Action 在仓库的 Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Branch 中选择需要分支并保存，即可启用 Github Pages。\n参考资料 Hugo + GitHub Action，搭建你的博客自动发布系统 如何用 GitHub Pages + Hugo 搭建个人博客 ","permalink":"https://tpcad.github.io/posts/build_blog_with_hugo_and_github_action/","summary":"\u003ch1 id=\"hugo--github-action搭建个人博客\"\u003eHugo + Github Action，搭建个人博客\u003c/h1\u003e\n\u003ch2 id=\"创建-github-仓库\"\u003e创建 Github 仓库\u003c/h2\u003e\n\u003ch3 id=\"创建博客源仓库\"\u003e创建博客源仓库\u003c/h3\u003e\n\u003cp\u003e博客源仓库用于对 Hugo 的配置文件以及 Markdown 源文件进行备份和管理，并配合 Github Action 自动将生成的静态网页推送到 Github Pages 仓库。\u003c/p\u003e\n\u003ch3 id=\"创建-github-pages-仓库\"\u003e创建 Github Pages 仓库\u003c/h3\u003e\n\u003cp\u003e以 \u003ccode\u003eusername.github.io\u003c/code\u003e 形式命名的特殊仓库，使用 Github Pages 实现部署网站。\u003c/p\u003e\n\u003ch2 id=\"创建博客\"\u003e创建博客\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehugo new site Blog\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHugo 生成的目录结构。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-language\" data-lang=\"language\"\u003eBlog\n├── archetypes\n│   └── default.md\n├── assets\n├── content\n├── data\n├── hugo.toml\n├── i18n\n├── layouts\n├── static\n└── themes\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"关联博客源仓库\"\u003e关联博客源仓库\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecd Blog\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit init\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit remote add origin git@github.com:TPCAD/tpcad-blog.git\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"配置-hugo-主题\"\u003e配置 Hugo 主题\u003c/h3\u003e\n\u003cp\u003e为了方便对主题进行自定义和版本控制，我们将 Hugo 主题 fork 到自己的 Github 账户，并以 submodule 的方式将主题添加到我们的博客源仓库。\u003c/p\u003e","title":"Hugo + Github Action，搭建个人博客"}]