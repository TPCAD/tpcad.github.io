[{"content":"进程 进程的状态 一个进程至少有三种基本状态，即就绪、运行、阻塞状态。\nstateDiagram-v2 Ready --\u0026gt; Running Running --\u0026gt; Ready Running --\u0026gt; Blocked Blocked --\u0026gt; Ready 就绪状态（Ready）：获得时间片后即可运行 运行状态（Running）：运行状态，进程正在占用 CPU 阻塞状态（Blocked）：进程正在等待某一事件发生，即使拥有 CPU 也无法运行 三种状态之间会因为以下原因发生切换：\n就绪状态 -\u0026gt; 运行状态：被调度程序选中，获得时间片，开始运行 运行状态 -\u0026gt; 就绪状态：时间片用完 运行状态 -\u0026gt; 阻塞状态：进程请求某个事件且必须等待，如 I/O 事件 阻塞状态 -\u0026gt; 就绪状态：进程请求的事件发生 除了以上三种状态外，进程还有两种基本的状态：\n创建状态（New）：进程正在被创建时的状态 结束状态（Exit）：进程结束时的状态 此外，当进程被阻塞时，可以将该进程相关的内存换出到磁盘中，这种进程存在但没有占据实际物理内存的状态称为「挂起状态」。挂起状态又可以分为 就绪挂起状态 和 阻塞挂起状态。\n进程控制块 进程控制块（Process Control Block，PCB）是用来进程的数据结构，每个进程对应一个 PCB，PCB 是进程存在的唯一标识。\nPCB 通常包含以下信息：\n进程描述信息： 进程标识符：每个进程都有一个唯一的标识符 用户标识符：进程所属用户 进程控制、管理信息： 进程状态：进程当前状态 进程优先级：进程调度时的优先级 分配的资源 进程虚拟地址空间 进程打开的文件列表 I/O 设备 CPU 信息 寄存器的值，如 eip，esp 线程 线程 是进程当中的一条执行流程。当进程只有一个线程时，可以认为进程就是线程。\n线程与进程十分相似，同样拥有就绪、运行、阻塞等状态，也通过 TCB（Thread Control Block）描述。线程共享进程的数据段、代码段、文件等资源，只独享寄存器、栈等资源。进程是资源分配的基本单位，线程是调度的基本单位。\n线程的实现 用户线程（User Thread）：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理 内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程 轻量级进程（LightWeight Process）：在内核中来支持用户线程 ","permalink":"https://tpcad.github.io/posts/os_process_basic/","summary":"\u003ch2 id=\"进程\"\u003e进程\u003c/h2\u003e\n\u003ch3 id=\"进程的状态\"\u003e进程的状态\u003c/h3\u003e\n\u003cp\u003e一个进程至少有三种基本状态，即就绪、运行、阻塞状态。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003estateDiagram-v2\n    Ready --\u0026gt; Running\n    Running --\u0026gt; Ready\n    Running --\u0026gt; Blocked\n    Blocked --\u0026gt; Ready\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e就绪状态（Ready）：获得时间片后即可运行\u003c/li\u003e\n\u003cli\u003e运行状态（Running）：运行状态，进程正在占用 CPU\u003c/li\u003e\n\u003cli\u003e阻塞状态（Blocked）：进程正在等待某一事件发生，即使拥有 CPU 也无法运行\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e三种状态之间会因为以下原因发生切换：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e就绪状态 -\u0026gt; 运行状态\u003c/em\u003e：被调度程序选中，获得时间片，开始运行\u003c/li\u003e\n\u003cli\u003e\u003cem\u003e运行状态 -\u0026gt; 就绪状态\u003c/em\u003e：时间片用完\u003c/li\u003e\n\u003cli\u003e\u003cem\u003e运行状态 -\u0026gt; 阻塞状态\u003c/em\u003e：进程请求某个事件且必须等待，如 I/O 事件\u003c/li\u003e\n\u003cli\u003e\u003cem\u003e阻塞状态 -\u0026gt; 就绪状态\u003c/em\u003e：进程请求的事件发生\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e除了以上三种状态外，进程还有两种基本的状态：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建状态（New）：进程正在被创建时的状态\u003c/li\u003e\n\u003cli\u003e结束状态（Exit）：进程结束时的状态\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e此外，当进程被阻塞时，可以将该进程相关的内存换出到磁盘中，这种进程存在但没有占据实际物理内存的状态称为「挂起状态」。挂起状态又可以分为 \u003cstrong\u003e就绪挂起状态\u003c/strong\u003e 和 \u003cstrong\u003e阻塞挂起状态\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"进程控制块\"\u003e进程控制块\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e进程控制块\u003c/strong\u003e（Process Control Block，PCB）是用来进程的数据结构，每个进程对应一个 PCB，PCB 是进程存在的唯一标识。\u003c/p\u003e\n\u003cp\u003ePCB 通常包含以下信息：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e进程描述信息：\n\u003cul\u003e\n\u003cli\u003e进程标识符：每个进程都有一个唯一的标识符\u003c/li\u003e\n\u003cli\u003e用户标识符：进程所属用户\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e进程控制、管理信息：\n\u003cul\u003e\n\u003cli\u003e进程状态：进程当前状态\u003c/li\u003e\n\u003cli\u003e进程优先级：进程调度时的优先级\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e分配的资源\n\u003cul\u003e\n\u003cli\u003e进程虚拟地址空间\u003c/li\u003e\n\u003cli\u003e进程打开的文件列表\u003c/li\u003e\n\u003cli\u003eI/O 设备\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCPU 信息\n\u003cul\u003e\n\u003cli\u003e寄存器的值，如 \u003ccode\u003eeip\u003c/code\u003e，\u003ccode\u003eesp\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"线程\"\u003e线程\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e线程\u003c/strong\u003e 是进程当中的一条执行流程。当进程只有一个线程时，可以认为进程就是线程。\u003c/p\u003e","title":"进程基础"},{"content":"为了隔离不同进程所使用的地址，操作系统为每个进程分配了一套 虚拟地址。各个进程的虚拟内存互相独立，互不干扰，同时，进程也不允许直接访问物理地址。虚拟内存可以让程序访问超出物理内存大小的地址。在 32 位处理器中，虚拟内存的大小为 4 GB（2^32）。\n分页 分页机制将虚拟内存分为一个个大小固定的单元，称为 页（Page）。同样的，也将物理内存分为一个个 页框（Page Frame）。页和页框的大小相等，通常为 4 KB。\n页表 页表 的作用是把页 映射 为页框。从数学角度说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。\n每一个进程都有自己的页表，页表也存储在内存中，是一个由页表项组成的数组。\n页表项 在 32 位操作系统中，一个页表项的大小为 4 字节。\ntypedef struct page_entry_t { u8 present : 1; // 在内存中 u8 write : 1; // 0 只读，1 可读可写 u8 user : 1; // 1 所有人，0 超级用户 DPL \u0026lt; 3 u8 pwt : 1; // page write through，1 直写模式，0 回写模式 u8 pcd : 1; // page cache disable，禁止该页缓冲 u8 accessed : 1; // 被访问过，用于统计使用频率 u8 dirty : 1; // 脏页，表示该页缓冲被写过 u8 pat : 1; // page attribute table，页大小 4K / 4M u8 global : 1; // 全局，所有进程都会用到了，该页不刷新缓冲 u8 ignored : 3; // 操作系统决定是否使用 u32 index : 20; // 页索引 } _packed page_entry_t; 地址转换 在 32 位操作系统中，虚拟内存大小为 4 GB（$2^{32}$），页面大小通常为 4 KB。由此可知，虚拟内存被划分为 1 M（$2^{20}$） 个页面。因此，32 位的虚拟地址中前 20 位表示页索引，剩下 12 位则表示页内偏移量。利用页索引在页表中查找到对应的页框号后，将其与页内偏移量相加即可得到物理地址。\n不难发现，页内偏移量的位数与页面大小有关，即当页面大小为 $2^k$ B 时，页内偏移量的位数为 k 位。\n因为页表必须覆盖整个虚拟内存，当一个页表项的大小为 4 B 时，那么页表大小则是 4 MB，若此时有 100 个进程，则需要 400 MB 的内存，这是非常大的浪费。\n多级页表 多级页表可以有效地节约内存。下面以二级页表为例。\n在 32 位操作系统中，32 位虚拟地址中，后 12 位是页内偏移地址，前 20 位中，前 10 位作为一级页号，中间 10 位作为二级页号（不一定是 10 位，在实际中也可能是其他的值）。\n在一级页表（或顶级页表）中，页表项存储的是二级页表的地址，而二级页表与单页表的页表项相同，主要存储页框号。\n因此，二级页表的寻址过程为：\n根据虚拟地址前 10 位在顶级页表中查找二级页表的地址 根据虚拟地址中间 10 位在二级页表中查找页框号 将页框号与页内偏移量相加得到物理地址 因为一级页号和二级页号的位数都是 10 位，所以一级页表和每个二级页表都有 $2^{10}$ 项，若每项大小为 4 B，则页表大小为 4 KB。\n若将所有页表都加载到内存中，二级页表所占用的总内存大小为 4 KB（一级页表）+ 4 MB（所有二级页表），反而比单页表还要大。然而，根据局部性原理，对于大部分程序来说，其使用的空间远远不到 4 GB，因此会存在许多空的页表项。对于二级页表，一级页表就已经可以完整地表示 4 GB 的虚拟地址空间，而二级页表可以在需要时才创建。如此一来，实际加载到内存的页表就只有 4 KB 的一级页表和需要用到的二级页表，最坏的情况也是加载所有的二级页表（几乎不可能），因此，二级页表可以有效地节约内存空间。\n无论是单页表还是多级页表，页表都要覆盖全部的虚拟地址空间。如果虚拟地址在页表中没有对应的页表项，计算机就不能工作了。与单页表每个页表项表示 4 KB 内存，需要 100 万个页表项相比，二级页表将页表项进行「压缩」，使一个页表项（一级页表项）可以表示 4 MB，因此只需 1024 个一级页表项就可以表示 4 GB 的虚拟内存空间。\n倒排页表 倒排页表（Inverted Page Table），也叫反置页表。在这种页表中，以页框号作为页表项的索引，页表项记录的主要内容是进程标识符和页表号。因为物理内存往往比虚拟内存要小得多，所以倒排页表的大小会比普通的单页表要小得多。\n倒排页表虽然节约了空间，但却大大增加了检索时间。寻址时，根据进程标识符和页表号检索整个倒排页表（即使页面不在内存中）。当内存容量很大时，页表项的数目还是会非常大。一种方法是采用 散列表 来进行存储。通过进程标识符和页表号计算散列值，当散列表的冲突链的平均长度为 1（即散列表的槽数与页框数相等），可以大大提高检索速度。\n因为倒排页表只记录了已经调入内存的页面的信息，因此还需要为每个进程建立一个外部页表，以记录那些未被调入内存的页面在外存中的位置。\n快表 多级页表和倒排页表解决了页表占用空间过大的问题，但地址转换所需要的时间也大大增加。根据局部性原理，可以将程序最常访问的页表项存储在一个高速缓冲中，当 CPU 寻址时优先检索该缓存。\n这种缓存称为 转换检测缓冲区（Translation Lookaside Buffer，TLB），也称 相联存储器（associate memory）或 快表。\n分段 分段机制将内存分成多个 大小不一，可以重叠 的 段（segment）。\n描述符表 描述符表是一个用于描述内存分布的 数组，数组的元素是 段描述符，一个段描述符描述一个段。x86 处理器中有两种描述符表，分别是全局描述符表（Global Descriptor Table，GDT）和局部描述符表（Local Descriptor Table，LDT）。GDT 描述系统段，包括操作系统本身，一台计算机上只有一个 GDT。LDT 描述程序的段，包括代码，数据，堆栈等，每个进程都有自己的 LDT。\n描述符表的第一项必须是全 0，且不应被使用。\ngdtr 全局描述符表寄存器（gdtr）用于存储 GDT。寄存器大小（32 位系统）是 6 字节。低 2 字节指明 GDT 的大小，也就是说 GDT 最大为 $2^{16}$ 字节。高 4 字节指明 GDT 的地址。\n相应地，LDT 被存储于 ldtr 中。\n段描述符 段描述符是描述符表的元素，用于描述一个内存中的一个段。段描述符主要存储了段的基址、限长以及一些属性位。\n段选择子 段选择子（segment selector）是一个 2 字节大小的数据结构，用于定位段描述符，通常保存在段寄存器中。段选择子的结构如下所示：\n0～1：RPL 2：0 表示全局描述符，1 表示本地描述符 3～15：GDT 索引 从其结构可以看出，索引只有 13 位，也就是说描述符表最多有 $2^{13}$ 个段描述符。\n地址转换 在寻址之前，需要先把段选择子保存到段寄存器中。根据段选择子在 GDT 或 LDT 中找到对应的段描述符，根据其中的段界限字段判断段内偏移量（即给出的虚拟地址）是否有效，若有效，则将段描述符中的段基地址与段内偏移量相加，得到物理地址。\n分段机制的问题 分段机制会带来 外部内存碎片 和 内存交换效率低 的问题。\n分段机制根据段的实际需求分配内存，因此不会出现 内部内存碎片。当内存中的一些段不再使用，被回收后，就会出现多个 不连续 的小物理内存，这就是 外部内存碎片。这会导致新的程序没有足够的空间去装载。\n为了解决外部内存碎片问题，可以把一些段先写入到硬盘，再将其读回内存，使其紧跟在其他段的后面，从而得到更大的连续内存空间。然而，读写硬盘的速度要远远慢于读写内存的速度，所以如果内存交换的是一个很大的程序，就会造成明显卡顿。\n段页式内存管理 分段和分页并不是互不兼容的，它们可以组合起来在同一系统上使用。事实上，x86 处理器上分段和分页机制同时存在。\n段页式内存管理先将程序划分成不同的段，每个段以页为基本单位进行分配。在寻址时，需要先通过描述符表找到段所对应的页表的地址，再通过页表将地址转换为物理地址。\nLinux 的内存管理 Linux 的内存管理以分页为主，最小限度地使用分段。\nLinux 将所有段的基地址设为 0，限长设为最大值。如此一来，逻辑地址就与线性地址相同了。\n其他 局部性原理 CPU 在访问内存时有明显的重复性。具体表现为 时间局部性 和 空间局部性。\n时间局部性：如果一个存储单元被访问，那么不久之后可能再次被访问 空间局部性：如果一个存储单元被访问，那么其附近的内存也将被访问 ","permalink":"https://tpcad.github.io/posts/os_virtual_memory/","summary":"\u003cp\u003e为了隔离不同进程所使用的地址，操作系统为每个进程分配了一套 \u003cstrong\u003e虚拟地址\u003c/strong\u003e。各个进程的虚拟内存互相独立，互不干扰，同时，进程也不允许直接访问物理地址。虚拟内存可以让程序访问超出物理内存大小的地址。在 32 位处理器中，虚拟内存的大小为 \u003ccode\u003e4 GB（2^32）\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"分页\"\u003e分页\u003c/h2\u003e\n\u003cp\u003e分页机制将虚拟内存分为一个个大小固定的单元，称为 \u003cstrong\u003e页（Page）\u003c/strong\u003e。同样的，也将物理内存分为一个个 \u003cstrong\u003e页框（Page Frame）\u003c/strong\u003e。页和页框的大小相等，通常为 \u003cstrong\u003e4 KB\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"页表\"\u003e页表\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e页表\u003c/strong\u003e 的作用是把页 \u003cstrong\u003e映射\u003c/strong\u003e 为页框。从数学角度说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。\u003c/p\u003e\n\u003cp\u003e每一个进程都有自己的页表，页表也存储在内存中，是一个由页表项组成的数组。\u003c/p\u003e\n\u003ch4 id=\"页表项\"\u003e页表项\u003c/h4\u003e\n\u003cp\u003e在 32 位操作系统中，一个页表项的大小为 4 字节。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003epage_entry_t\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    u8 present : \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;  \u003cspan style=\"color:#75715e\"\u003e// 在内存中\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u8 write : \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;    \u003cspan style=\"color:#75715e\"\u003e// 0 只读，1 可读可写\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u8 user : \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;     \u003cspan style=\"color:#75715e\"\u003e// 1 所有人，0 超级用户 DPL \u0026lt; 3\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u8 pwt : \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;      \u003cspan style=\"color:#75715e\"\u003e// page write through，1 直写模式，0 回写模式\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u8 pcd : \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;      \u003cspan style=\"color:#75715e\"\u003e// page cache disable，禁止该页缓冲\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u8 accessed : \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// 被访问过，用于统计使用频率\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u8 dirty : \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;    \u003cspan style=\"color:#75715e\"\u003e// 脏页，表示该页缓冲被写过\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u8 pat : \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;      \u003cspan style=\"color:#75715e\"\u003e// page attribute table，页大小 4K / 4M\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u8 global : \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;   \u003cspan style=\"color:#75715e\"\u003e// 全局，所有进程都会用到了，该页不刷新缓冲\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u8 ignored : \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e;  \u003cspan style=\"color:#75715e\"\u003e// 操作系统决定是否使用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    u32 index : \u003cspan style=\"color:#ae81ff\"\u003e20\u003c/span\u003e;  \u003cspan style=\"color:#75715e\"\u003e// 页索引\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e} _packed \u003cspan style=\"color:#66d9ef\"\u003epage_entry_t\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"地址转换\"\u003e地址转换\u003c/h4\u003e\n\u003cp\u003e在 32 位操作系统中，虚拟内存大小为 4 GB（$2^{32}$），页面大小通常为 4 KB。由此可知，虚拟内存被划分为 1 M（$2^{20}$） 个页面。因此，32 位的虚拟地址中前 20 位表示页索引，剩下 12 位则表示页内偏移量。利用页索引在页表中查找到对应的页框号后，将其与页内偏移量相加即可得到物理地址。\u003c/p\u003e","title":"虚拟内存"},{"content":"转发 指的是函数之间的参数传递。比如下面的代码，函数 foo 向函数 bar 传递了参数 a。\nfoo(int a) { bar(a) } bar(int b) {} 完美转发则是在转发过程中，参数的各种属性都保持不变。比如右值仍是右值，左值仍是左值。\n普通转发的问题 在下面的代码中，函数 pass 接受一个右值引用，并将该参数传递给函数 reference。当向 pass 传入字面量 1 时，最终的输出结果是 lvalue。这是因为虽然向 pass 传入了右值，但在函数体内，变量 x 的值类别变成了左值，即 x 的类型是右值引用，值类别是左值，所以最终会调用 reference(int \u0026amp;y)。\n这就是普通转发存在的问题，在转发过程中可能会改变参数某些属性。\n#include \u0026lt;fmt/core.h\u0026gt; void reference(int \u0026amp;\u0026amp;y) { fmt::println(\u0026#34;rvalue\u0026#34;); } void reference(int \u0026amp;y) { fmt::println(\u0026#34;lvalue\u0026#34;); } void pass(int \u0026amp;\u0026amp;x) { fmt::println(\u0026#34;general pass\u0026#34;); reference(x); } int main(int argc, char *argv[]) { pass(1); return 0; } 实现完美转发 万能引用 在普通函数中，若参数类型为 \u0026amp;\u0026amp;，则函数只能接受右值。\nvoid foo(int \u0026amp;\u0026amp;x) {} int main() { int a = 1; foo(1); // foo(a); 无法编译 } 但在模板函数中，若 \u0026amp;\u0026amp; 与模板参数结合，即 T\u0026amp;\u0026amp;，那么它将不再代表右值引用，而是万能引用。它既能接受左值，又能接受右值。\ntemplate \u0026lt;typename T\u0026gt; void foo(T \u0026amp;\u0026amp;x) { } int main(int argc, char *argv[]) { foo(1); // 传入右值 int a = 0; foo(a); // 传入左值 return 0; } 引用折叠规则 引用折叠规则是在对引用类型进行连续引用时所要遵循的规则。\n函数形参类型 实参参数类型 推导后函数形参类型 T\u0026amp; 左引用 T\u0026amp; T\u0026amp; 右引用 T\u0026amp; T\u0026amp;\u0026amp; 左引用 T\u0026amp; T\u0026amp;\u0026amp; 右引用 T\u0026amp;\u0026amp; 简而言之，当且仅当模板函数的形参与实参都是右引用时，形参才会被推导为右引用。\nstd::forward C++ 使用 std::forward 进行完美转发。std::forward 的实现如下：\n/** * @brief Forward an lvalue. * @return The parameter cast to the specified type. * * This function is used to implement \u0026#34;perfect forwarding\u0026#34;. */ template\u0026lt;typename _Tp\u0026gt; constexpr _Tp\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp; __t) noexcept { return static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t); } /** * @brief Forward an rvalue. * @return The parameter cast to the specified type. * * This function is used to implement \u0026#34;perfect forwarding\u0026#34;. */ template\u0026lt;typename _Tp\u0026gt; constexpr _Tp\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp; __t) noexcept { static_assert(!std::is_lvalue_reference\u0026lt;_Tp\u0026gt;::value, \u0026#34;template argument\u0026#34; \u0026#34; substituting _Tp is an lvalue reference type\u0026#34;); return static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t); } 其中 std::remove_reference 是一个模板类，它的实现如下：\ntemplate\u0026lt;class T\u0026gt; struct remove_reference { typedef T type; }; template\u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026gt; { typedef T type; }; template\u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; { typedef T type; }; 通过 std::remove_reference 将类型的引用去除，得到值类型。std::forward 有两个重载，分别匹配左值引用和右值引用，当匹配左值引用时，根据引用折叠规则，static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t) 返回左值引用，当匹配右值引用时，根据引用折叠规则，static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t) 返回右值引用。\n使用 std::forward #include \u0026lt;fmt/core.h\u0026gt; #include \u0026lt;utility\u0026gt; void reference(int \u0026amp;\u0026amp;x) { fmt::println(\u0026#34;rvalue\u0026#34;); } void reference(int \u0026amp;x) { fmt::println(\u0026#34;lvalue\u0026#34;); } template \u0026lt;typename T\u0026gt; void pass(T \u0026amp;\u0026amp;x) { fmt::println(\u0026#34;general pass\u0026#34;); reference(x); fmt::println(\u0026#34;forward pass\u0026#34;); reference(std::forward\u0026lt;T\u0026gt;(x)); } int main(int argc, char *argv[]) { pass(1); fmt::println(\u0026#34;===\u0026#34;); int a{1}; pass(a); return 0; } // general pass // lvalue // forward pass // rvalue // === // general pass // lvalue // forward pass // lvalue ","permalink":"https://tpcad.github.io/posts/cpp_perfect_forwarding.md/","summary":"\u003cp\u003e\u003cstrong\u003e转发\u003c/strong\u003e 指的是函数之间的参数传递。比如下面的代码，函数 \u003ccode\u003efoo\u003c/code\u003e 向函数 \u003ccode\u003ebar\u003c/code\u003e 传递了参数 \u003ccode\u003ea\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e(a)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e b) {}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e完美转发\u003c/strong\u003e则是在转发过程中，参数的各种属性都保持不变。比如右值仍是右值，左值仍是左值。\u003c/p\u003e\n\u003ch2 id=\"普通转发的问题\"\u003e普通转发的问题\u003c/h2\u003e\n\u003cp\u003e在下面的代码中，函数 \u003ccode\u003epass\u003c/code\u003e 接受一个右值引用，并将该参数传递给函数 \u003ccode\u003ereference\u003c/code\u003e。当向 \u003ccode\u003epass\u003c/code\u003e 传入字面量 \u003ccode\u003e1\u003c/code\u003e 时，最终的输出结果是 \u003ccode\u003elvalue\u003c/code\u003e。这是因为虽然向 \u003ccode\u003epass\u003c/code\u003e 传入了右值，但在函数体内，变量 \u003ccode\u003ex\u003c/code\u003e 的值类别变成了\u003cstrong\u003e左值\u003c/strong\u003e，即 \u003ccode\u003ex\u003c/code\u003e 的类型是右值引用，值类别是左值，所以最终会调用 \u003ccode\u003ereference(int \u0026amp;y)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这就是普通转发存在的问题，在转发过程中可能会改变参数某些属性。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;fmt/core.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereference\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ey) { fmt\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;rvalue\u0026#34;\u003c/span\u003e); }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereference\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ey) { fmt\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;lvalue\u0026#34;\u003c/span\u003e); }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epass\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ex) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    fmt\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;general pass\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ereference\u003c/span\u003e(x);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e argc, \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eargv[]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003epass\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"实现完美转发\"\u003e实现完美转发\u003c/h2\u003e\n\u003ch3 id=\"万能引用\"\u003e万能引用\u003c/h3\u003e\n\u003cp\u003e在普通函数中，若参数类型为 \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e，则函数只能接受右值。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003ex) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// foo(a); 无法编译\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但在模板函数中，若 \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e 与模板参数结合，即 \u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e，那么它将不再代表右值引用，而是\u003cstrong\u003e万能引用\u003c/strong\u003e。它既能接受左值，又能接受右值。\u003c/p\u003e","title":"How Perfect Forwarding Works"},{"content":"为什么需要 nullptr 在 C 中，NULL 被定义为 (void*)0 或 0。而 C++ 因为不允许直接将 void* 隐式转换到其他类型，所以在没有 nullptr 之前，C++ 的 NULL 就是 0（也可能是 0L）。这导致 0 的二义性。\n0 的二义性给函数重载带来了混乱。考虑下面的代码，如果 NULL 被定义为 0，那么 foo(NULL) 会严格匹配 foo(int)，但如果 NULL 被定义为 0，那么将不存在严格匹配，而 0L 可以同时转换为 int 和 int*，编译器无法知道应该调用哪个函数。\nvoid foo(int){} void foo(int*){} foo(0); // 调用 foo(int) foo(NULL); 为了解决这个问题，C++ 11 引入了 nullptr 关键字，用于区分空指针和 0。\n使用 nullptr nullptr 是一个纯右值，无法被 \u0026amp; 取地址，可以被隐式转换为任意的指针或成员指针类型。\nvoid foo(int){} void foo(int*){} foo(0); // 调用 foo(int) foo(nullptr); // 隐式转换到 int*，调用 foo(int*) nullptr 可以取代 NULL 的所有场景。\nint* ptr = nullptr; if (ptr == nullptr){} 理解 nullptr nullptr 的类型是 nullptr_t。下面是一个可能的实现。\nstruct nullptr_t { // 不能对 nullptr 取地址 void operator\u0026amp;() const = delete; // 隐式转换为任意类型指针 template\u0026lt;class T\u0026gt; inline operator T*() const { return 0; } // 隐式转换为任意类型成员指针 template\u0026lt;class C, class T\u0026gt; inline operator T C::*() const { return 0; } }; nullptr_t nullptr; 从上面的实现可以看出，在隐式转换到其他指针或成员指针类型时，返回的就是 0。所以尽管类型不同，但 nullptr 在数值上等于 0。\nint *p = nullptr; std::cout \u0026lt;\u0026lt; (nullptr == 0) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; (p == 0) \u0026lt;\u0026lt; std::endl; cout \u0026lt;\u0026lt; reinterpret_cast\u0026lt;long\u0026gt;(nullptr) \u0026lt;\u0026lt; endl; nullptr 的类型转换 因为可以隐式转换到任意类型的指针和成员指针，所以可以使用 static_cast 对 nullptr 进行显示转换。\nint *p; p = static_cast\u0026lt;int*\u0026gt;(nullptr); nullptr 不能使用 static_cast 显示转换到 int 等类型，除了 bool。\nstd::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(nullptr) \u0026lt;\u0026lt; std::endl; // not allowed std::cout \u0026lt;\u0026lt; static_cast\u0026lt;bool\u0026gt;(nullptr) \u0026lt;\u0026lt; std::endl; 可以使用 reinterpret_cast 显示转换 nullptr 到整数类型。\nstd::cout \u0026lt;\u0026lt; static_cast\u0026lt;long\u0026gt;(nullptr) \u0026lt;\u0026lt; std::endl; // 大小必须兼容 Reference What Exactly Nullptr Is in C++? C++11nullptr A name for the null pointer: nullptr (revision 4)\n","permalink":"https://tpcad.github.io/posts/cpp_nullptr/","summary":"\u003ch2 id=\"为什么需要-nullptr\"\u003e为什么需要 nullptr\u003c/h2\u003e\n\u003cp\u003e在 C 中，\u003ccode\u003eNULL\u003c/code\u003e 被定义为 \u003ccode\u003e(void*)0\u003c/code\u003e 或 \u003ccode\u003e0\u003c/code\u003e。而 C++ 因为不允许直接将 \u003ccode\u003evoid*\u003c/code\u003e 隐式转换到其他类型，所以在没有 \u003ccode\u003enullptr\u003c/code\u003e 之前，C++ 的 \u003ccode\u003eNULL\u003c/code\u003e 就是 0（也可能是 \u003ccode\u003e0L\u003c/code\u003e）。这导致 0 的二义性。\u003c/p\u003e\n\u003cp\u003e0 的二义性给函数重载带来了混乱。考虑下面的代码，如果 \u003ccode\u003eNULL\u003c/code\u003e 被定义为 \u003ccode\u003e0\u003c/code\u003e，那么 \u003ccode\u003efoo(NULL)\u003c/code\u003e 会严格匹配 \u003ccode\u003efoo(int)\u003c/code\u003e，但如果 \u003ccode\u003eNULL\u003c/code\u003e 被定义为 \u003ccode\u003e0\u003c/code\u003e，那么将不存在严格匹配，而 \u003ccode\u003e0L\u003c/code\u003e 可以同时转换为 \u003ccode\u003eint\u003c/code\u003e 和 \u003ccode\u003eint*\u003c/code\u003e，编译器无法知道应该调用哪个函数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e){}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e){}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efoo(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 调用 foo(int)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003efoo(NULL);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e为了解决这个问题，C++ 11 引入了 \u003ccode\u003enullptr\u003c/code\u003e 关键字，用于区分空指针和 \u003ccode\u003e0\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"使用-nullptr\"\u003e使用 nullptr\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003enullptr\u003c/code\u003e 是一个纯右值，无法被 \u003ccode\u003e\u0026amp;\u003c/code\u003e 取地址，可以被隐式转换为任意的指针或成员指针类型。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e){}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e){}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efoo(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 调用 foo(int)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003efoo(\u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 隐式转换到 int*，调用 foo(int*)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003enullptr\u003c/code\u003e 可以取代 \u003ccode\u003eNULL\u003c/code\u003e 的所有场景。\u003c/p\u003e","title":"How Nullptr Works"},{"content":"Rust Iterator 可迭代对象与迭代器（Iterable and Iterator） 迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：\n记录当前的迭代状态 产生可以访问下一个元素的迭代器 可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 Vec\u0026lt;T\u0026gt; 可以通过 iter 方法获得一个迭代器，但 Vec\u0026lt;T\u0026gt; 本省不是一个迭代器。\n一个可迭代对象通常有三个方法，分别对应三种迭代类型。\niter()，迭代 \u0026amp;T iter_mut()，迭代 \u0026amp;mut T into_iter()，迭代 T Iterator Trait Rust 迭代器的核心是 Iterator trait。Iterator trait 的核心代码看起来像下面这样：\ntrait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; } 关联类型 Item 表明迭代器返回的对象，next 方法表明迭代器如何返回该对象。\n实现 Iterator Trait 遍历 \u0026amp;T 假设有以下结构体，现在需要为 Todos 实现 Iterator trait。\npub struct Todos { pub list: Vec\u0026lt;Todo\u0026gt;, } #[derive(Debug)] pub struct Todo { pub message: String, pub done: bool, } 实现 Iterator trait 的关键是记录当前的迭代状态。Todos 使用一个 Vec\u0026lt;T\u0026gt; 来进行存储，非常适合用索引来记录迭代状态。我们可以为 Todos 添加一个 index 字段来记录迭代状态。但很显然，这并不妥当。当你对 Todos 进行迭代时会修改 index 字段的值，如果想要再次进行迭代，就必须重置 index 字段，因为迭代器不会在迭代结束后重置状态。\n所以我们更倾向于只把 Todos 当作一个可迭代对象，并用一个新的数据结构来记录迭代状态。\n下面是一个名为 TodosIterator 的结构体，它两个字段，todos 是对 Todos 的不可变引用，index 是一个 usize，用于记录当前的迭代状态。接下来将为 TodosIterator 实现 Iterator trait。\npub struct TodosIterator\u0026lt;\u0026#39;a\u0026gt; { todos: \u0026amp;\u0026#39;a Todos, index: usize, } 首先指定关联类型 Item 为 \u0026amp;'a Todo，这表明这个迭代器用于迭代 \u0026amp;T。\n接着实现 next 方法。通过比较当前 index 的值与 Vec 的长度判断是否迭代结束。若否，index 字段加 1，并返回当前索引对应的 Some(\u0026amp;Todo)。\nimpl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.index \u0026lt; self.todos.list.len() { let result = Some(\u0026amp;self.todos.list[self.index]); self.index += 1; result } else { None } } } 现在我们还需要为 Todos 实现一个用于产生迭代器的方法，使其成为可迭代对象。对于迭代 \u0026amp;T 的迭代器，这个方法通常是 iter()。\nimpl Todos { pub fn iter(\u0026amp;self) -\u0026gt; TodosIterator { TodosIterator { todos: self, index: 0, } } } 现在可以通过 iter 方法在 for 循环中迭代 Todos 了。\nfn main() { let todos = Todos { list: vec![ Todo { message: \u0026#34;Hello\u0026#34;.to_string(), done: false, }, Todo { message: \u0026#34;Rust\u0026#34;.to_string(), done: false, }, Todo { message: \u0026#34;World\u0026#34;.to_string(), done: false, }, ], }; for todo in todos.iter() { println!(\u0026#34;{todo:#?}\u0026#34;) } } IntoIterator Trait IntoIterator trait 的核心代码看起来像下面这样。它有一个 into_iter 方法，用于产生一个拥有对象所有权的迭代器。\n关联类型 Item 与 Iterator 的 Item 相同，IntoIter 是一个实现了 Iterator trait 的类型。 方法 into_iter 会获取对象的所有权，并返回 IntoIter。\npub trait IntoIterator { type Item; type IntoIter: Iterator\u0026lt;Item = Self::Item\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter; } Rust 在标准库中为所有实现了 Iterator trait 的类型实现了 IntoIterator。\nimpl\u0026lt;I: Iterator\u0026gt; IntoIterator for I 实现 IntoIterator Trait 遍历 T 因为 IntoIterator 会获取对象的所有权，所以不能继续使用 TodosIterator 来实现。我们使用一个新的结构体来实现。\npub struct TodosIntoIterator { todos: Todos, } 接着为 Todos 实现 IntoIterator。将关联类型 IntoIter 指定为 TodosIntoIterator，并在 into_iter 方法中返回一个 TodosIntoIterator。\nimpl IntoIterator for Todos { type Item = Todo; type IntoIter = TodosIntoIterator; fn into_iter(self) -\u0026gt; Self::IntoIter { TodosIntoIterator { todos: self } } } 因为 IntoIter 是一个实现了 Iterator trait 的类型，所以我们需要为 TodosIntoIterator 实现 Iterator trait。\n因为 TodosIntoIterator 拥有所有权，所以这里在每次迭代中删除 Vec 的第一个元素，这样迭代器总是指向这个元素。同时以 Vec 为空为迭代结束条件。\nimpl Iterator for TodosIntoIterator { type Item = Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.todos.list.is_empty() { return None; } let result = self.todos.list.remove(0); Some(result) } } 如此一来便能在 for 循环中遍历 todos 并获得其所有权。\nfor todo in todos { println!(\u0026#34;{todo:#?}\u0026#34;) } 实现 Iterator Trait 遍历 \u0026amp;mut T 要实现遍历 \u0026amp;mut T 的 Iterator trait 并不容易。\n若仿照 \u0026amp;T 来实现 \u0026amp;mut T，编译器会抱怨生命周期太短。\nimpl Todos { pub fn iter_mut(\u0026amp;mut self) -\u0026gt; TodosMutIterator { TodosMutIterator { todos: self, index: 0, } } } pub struct TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { todos: \u0026amp;\u0026#39;a mut Todos, index: usize, } impl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a mut Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.index \u0026lt; self.todos.list.len() { let result = Some(\u0026amp;mut self.todos.list[self.index]); self.index += 1; result } else { None } } } // error: lifetime may not live long enough // --\u0026gt; src/main.rs:87:13 // | // 81 | impl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { // | -- lifetime `\u0026#39;a` defined here // 82 | type Item = \u0026amp;\u0026#39;a mut Todo; // 83 | fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { // | - let\u0026#39;s call the lifetime of this reference `\u0026#39;1` // ... // 87 | result // | ^^^^^^ method was supposed to return data with lifetime `\u0026#39;a` but it is returning da // ta with lifetime `\u0026#39;1` iter_mut 方法通常用于返回一个可以遍历 \u0026amp;mut T 的迭代器。显然，迭代器只要能访问元素，并记录迭代状态就行了。因此我们可以借助 Vec 来实现 iter_mut 方法。\n创建一个类型为 Vec\u0026lt;\u0026amp;mut Todo\u0026gt; 的 Vec，并获取 Todos 的 Vec 的元素的可变引用，也就是 \u0026amp;mut Todo。最后对新的 Vec 调用方法 into_iter，返回一个可以以可变引用访问元素的迭代器。\n这样虽然不再需要额外的结构体，但每次遍历都需要创建一个新的 Vec。\nimpl Todos { pub fn iter_mut(\u0026amp;mut self) -\u0026gt; std::vec::IntoIter\u0026lt;\u0026amp;mut Todo\u0026gt; { let mut v: Vec\u0026lt;\u0026amp;mut Todo\u0026gt; = vec![]; for todo in self.list.iter_mut() { v.push(todo) } v.into_iter() } } 实现 IntoIterator Trait 遍历 \u0026amp;T 和 \u0026amp;mut T 只需要为对应的类型实现 IntoIterator trait，into_iter 方法就可以根据上下文返回遍历 \u0026amp;T、\u0026amp;mut T 或 T 的迭代器。\nimpl\u0026lt;\u0026#39;a\u0026gt; IntoIterator for \u0026amp;\u0026#39;a Todos { type Item = \u0026amp;\u0026#39;a Todo; type IntoIter = TodosIterator\u0026lt;\u0026#39;a\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter { self.iter() } } impl\u0026lt;\u0026#39;a\u0026gt; IntoIterator for \u0026amp;\u0026#39;a mut Todos { type Item = \u0026amp;\u0026#39;a mut Todo; type IntoIter = std::vec::IntoIter\u0026lt;\u0026amp;\u0026#39;a mut Todo\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter { self.iter_mut() } } 解引用裸指针实现 Iterator Trait 遍历 \u0026amp;mut T 此前编译器抱怨生命周期太短，可以通过解引用裸指针解决。\n这样做的本质是将变量的生命周期变为 'static。将一个值转化为原始指针后，它的生命周期信息会被丢弃，再次引用原始指针则会赋予静态生命周期。静态生命周期存活时间非常长，这样做会带来一些潜在的安全风险。\npub struct TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { todos: \u0026amp;\u0026#39;a mut Todos, index: usize, } impl\u0026lt;\u0026#39;a\u0026gt; Iterator for TodosMutIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a mut Todo; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.index \u0026lt; self.todos.list.len() { // 解引用裸指针 let result = unsafe { \u0026amp;mut *(\u0026amp;mut self.todos.list[self.index] as *mut _) }; self.index += 1; Some(result) } else { None } } } 如下代码所示，变量 a 是一个引用，它会指向 s1 或 s2 所指向的内容，而 s1 和 s2 在离开其作用域后会被清理，因为 a 拥有静态生命周期，所以它在离开作用域后仍能使用，而它所指向的内容已经被释放，这会导致访问到完全随机的数据。\nfn main() { let a; { let mut v1 = vec![2, 3]; let s1 = \u0026amp;mut v1; let mut v2 = vec![1, 8]; let s2 = \u0026amp;mut v2; a = test(s1, s2); } println!(\u0026#34;{a:?}\u0026#34;) } fn test\u0026lt;\u0026#39;a\u0026gt;(s1: \u0026amp;mut Vec\u0026lt;i32\u0026gt;, s2: \u0026amp;mut Vec\u0026lt;i32\u0026gt;) -\u0026gt; \u0026amp;\u0026#39;a mut Vec\u0026lt;i32\u0026gt; { let i = 2; if i == 1 { unsafe { \u0026amp;mut *(s1 as *mut _) } } else { unsafe { \u0026amp;mut *(s2 as *mut _) } } } // 一种可能的结果 // [-502036575, 23992] 参考资料 Effectively Using Iterators In Rust How do I create mutable iterator over struct fields Implementing Iterator and IntoIterator in Rust Does dereferencing a raw pointer back to a reference change the lifetime of the reference? Module std::iter ","permalink":"https://tpcad.github.io/posts/rust_iterator/","summary":"\u003ch1 id=\"rust-iterator\"\u003eRust Iterator\u003c/h1\u003e\n\u003ch2 id=\"可迭代对象与迭代器iterable-and-iterator\"\u003e可迭代对象与迭代器（Iterable and Iterator）\u003c/h2\u003e\n\u003cp\u003e迭代器（Iterator）是一种可以让你方便地遍历序列中每一个元素的工具。迭代器有两个重要的功能：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e记录当前的迭代状态\u003c/li\u003e\n\u003cli\u003e产生可以访问下一个元素的迭代器\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可迭代对象（Iterable）是一种可以产生迭代器的对象。比如 \u003ccode\u003eVec\u0026lt;T\u0026gt;\u003c/code\u003e 可以通过 \u003ccode\u003eiter\u003c/code\u003e 方法获得一个迭代器，但 \u003ccode\u003eVec\u0026lt;T\u0026gt;\u003c/code\u003e 本省不是一个迭代器。\u003c/p\u003e\n\u003cp\u003e一个可迭代对象通常有三个方法，分别对应三种迭代类型。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eiter()\u003c/code\u003e，迭代 \u003ccode\u003e\u0026amp;T\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eiter_mut()\u003c/code\u003e，迭代 \u003ccode\u003e\u0026amp;mut T\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einto_iter()\u003c/code\u003e，迭代 \u003ccode\u003eT\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"iterator-trait\"\u003eIterator Trait\u003c/h2\u003e\n\u003cp\u003eRust 迭代器的核心是 \u003ccode\u003eIterator\u003c/code\u003e trait。\u003ccode\u003eIterator\u003c/code\u003e trait 的核心代码看起来像下面这样：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etrait\u003c/span\u003e Iterator {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eItem\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enext\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003emut\u003c/span\u003e self) -\u0026gt; Option\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eSelf::Item\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e关联类型 \u003ccode\u003eItem\u003c/code\u003e 表明迭代器返回的对象，\u003ccode\u003enext\u003c/code\u003e 方法表明迭代器如何返回该对象。\u003c/p\u003e\n\u003ch3 id=\"实现-iterator-trait-遍历-t\"\u003e实现 Iterator Trait 遍历 \u0026amp;T\u003c/h3\u003e\n\u003cp\u003e假设有以下结构体，现在需要为 \u003ccode\u003eTodos\u003c/code\u003e 实现 \u003ccode\u003eIterator\u003c/code\u003e trait。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eTodos\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e list: Vec\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eTodo\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#[derive(Debug)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eTodo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e message: String,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epub\u003c/span\u003e done: \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e实现 \u003ccode\u003eIterator\u003c/code\u003e trait 的关键是记录当前的迭代状态。\u003ccode\u003eTodos\u003c/code\u003e 使用一个 \u003ccode\u003eVec\u0026lt;T\u0026gt;\u003c/code\u003e 来进行存储，非常适合用索引来记录迭代状态。我们可以为 \u003ccode\u003eTodos\u003c/code\u003e 添加一个 \u003ccode\u003eindex\u003c/code\u003e 字段来记录迭代状态。但很显然，这并不妥当。当你对 \u003ccode\u003eTodos\u003c/code\u003e 进行迭代时会修改 \u003ccode\u003eindex\u003c/code\u003e 字段的值，如果想要再次进行迭代，就必须重置 \u003ccode\u003eindex\u003c/code\u003e 字段，因为迭代器不会在迭代结束后重置状态。\u003c/p\u003e","title":"Rust Iterator"},{"content":"TCP 首部 --- title: \u0026#34;TCP Packet\u0026#34; --- packet-beta 0-15: \u0026#34;源端口号\u0026#34; 16-31: \u0026#34;目的端口号\u0026#34; 32-63: \u0026#34;序列号\u0026#34; 64-95: \u0026#34;确认应答号\u0026#34; 96-99: \u0026#34;数据偏移量\u0026#34; 100-105: \u0026#34;保留\u0026#34; 106: \u0026#34;URG\u0026#34; 107: \u0026#34;ACK\u0026#34; 108: \u0026#34;PSH\u0026#34; 109: \u0026#34;RST\u0026#34; 110: \u0026#34;SYN\u0026#34; 111: \u0026#34;FIN\u0026#34; 112-127: \u0026#34;窗口\u0026#34; 128-143: \u0026#34;校验和\u0026#34; 144-159: \u0026#34;紧急指针\u0026#34; 160-191: \u0026#34;选项（长度可变）\u0026#34; 序列号：TCP 是面向字节流的，其传输的每一个数据字节都对应一个序列号。序列号的初始值是一个随机数，每发送一次 TCP 报文序列号都会累加一次报文的数据字节数\n确认应答号：下一次期望收到的数据的序列号\n数据偏移量：数据部分的偏移量，也就是首部的长度。单位为 4 字节。因此 TCP 首部最长为 $(2^4-1)*4=60$ 字节。\n控制位：\nACK：该位为 1 时表示确认应答字段有效，除最初建立连接时的 SYN 包外该位必须置 1 RST：该位为 1 时表示 TCP 连接出现异常必须强制断开连接 SYN：该位为 1 时表示希望建立 TCP 连接，并在其序列号字段确定序列号初始值 FIN：该位为 1 时表示今后不会再有数据发送，希望断开 TCP 连接 TCP 连接 三次握手 建立一个 TCP 连接需要经过三次握手过程。\nsequenceDiagram participant Client participant Server Client-\u0026gt;\u0026gt;Server: SYN (SEQ=client_seq) Server--\u0026gt;\u0026gt;Client: SYN-ACK (SEQ=server_seq, ACK=client_seq+1) Client-\u0026gt;\u0026gt;Server: ACK (SEQ=client_seq+1, ACK=server_seq+1) 第一次握手：SYN 报文 客户端将 SYN 字段置为 1，表示希望建立连接，并随机初始化序列号，该报文 不包含数据。之后客户端进入 SYN-SENT 状态。 第二次握手：SYN-ACK 报文 服务端收到客户端的 SYN 报文后，也随机初始化自己的序列号，并将 client_seq+1 作为确认应答号，同时将 SYN 和 ACK 字段置为 1。该报文 不包含数据。之后服务端进入 SYN-RCVD 状态。 第三次握手：ACK 报文 客户端收到服务端的报文后，向服务端发送 ACK 报文。该报文的序列号为 client_seq+1，确认应答号为 server_seq+1，ACK 字段置为 1。该报文 可以包含数据。之后客户端进入 ESTABLISHED 状态。 服务端收到 ACK 报文后也会进入 ESTABLISHED 状态，此时连接成功建立。 四次挥手 关闭一个 TCP 连接需要经过三次挥手过程。\nsequenceDiagram participant Client participant Server Client-\u0026gt;\u0026gt;Server: FIN (SEQ=x) Server--\u0026gt;\u0026gt;Client: ACK (SEQ=y, ACK=x+1) Server-\u0026gt;\u0026gt;Client: Data Server-\u0026gt;\u0026gt;Client: FIN (SEQ=w, ACK=x+1) Client--\u0026gt;\u0026gt;Server: ACK (SEQ=x+1, ACK=w+1) 第一次挥手：客户端 FIN 报文 客户端向服务端发送 FIN 字段为 1 的报文，表示关闭 TCP 连接，客户端进入 FIN_WAIT_1 状态，不再向服务端发送数据。 第二次挥手：服务端 ACK 报文 服务端接收到客户端的 FIN 报文后发送 ACK 报文，服务端进入 CLOSE_WAIT 状态。此时服务端仍能向客户端发送数据。 客户端接收到该 ACK 报文后进入 FIN_WAIT_2 状态。 第三次挥手：服务端 FIN 报文 服务端向客户端发送 FIN 字段为 1 的报文，表示关闭 TCP 连接，服务端进入 LAST_ACK 状态，不再向客户端发送数据。 第四次挥手：服务端 ACK 报文 客户端接收到服务端的 FIN 报文后发送 ACK 报文，客户端进入 TIME_WAIT 状态。客户端在经过 2MSL 时间后，自动进入 CLOSE 状态，完成关闭。 服务端接收到 ACK 报文后进入 CLOSE 状态，完成关闭。 重传 重传 是 TCP 实现可靠传输的方式之一。发送端的数据到达接收端后，接收端会回复一个确认报文，表示已收到。在错综复杂的网络中，数据可能在传输过程中丢失，因此需要重新传输丢失的数据。数据丢失有两种情况：\n数据报文丢失（接收端没有收到数据报文） 确认报文丢失（发送端没有收到确认报文） 超时重传 每一个数据报发送时都会设置一个定时器，若超过指定时间没有收到确认报文，就会重发该数据。这就是 超时重传。\n超时重传的时间通常略大于往返时延（详情见处）。\n若超时重传的数据超时，TCP 采取 超时间隔加倍 策略。也就是说，每遇到一次超时，下一次超时重传的时间都是上次的两倍。\n超时重传存在等待时间过长的问题。\n快速重传 快速重传 可以有效解决 超时重传 时间过长的问题。\n假设发送端向接收端发送 6 个数据报，它们的序列号分别为：Seq1、Seq2、Seq3、Seq4、Seq5。其中序列号为 Seq2 的数据报丢失，接收端收到 Seq1 后回复 ACK 报文，收到 Seq3 及其后的数据报时，因为 Seq2 丢失（接收端没有收到），回复了 3 个相同的 ACK 报文（确认应答号均为 Seq2）。\n收到三个相同的 ACK 报文后，发送端会在定时器过期之前重发对应的数据，这就是 快速重传。\n最后接收端收到了 Seq2，于是 ACK 报文的确认应答号为 Seq6。\n对于上面单个数据报丢失的情况，快速重传的等待时间较短，但若出现多个数据报丢失，后面的数据报必须在前面的数据报被接收后才能触发快速重传，这又会增加重传的等待时间。如果全部重传后面的数据，那么已接收的数据就被浪费了。\nSACK 选择性确认 （Selective Acknowledge，SACK）可以将已收到的数据告诉发送端，从而可以只重传丢失的数据。\nsequenceDiagram participant Sender participant Receiver Sender-\u0026gt;\u0026gt;Receiver: 100~199 Receiver--\u0026gt;\u0026gt;Sender: ACK=200 Sender-\u0026gt;\u0026gt;Receiver: 200~299 (lost) Sender-\u0026gt;\u0026gt;Receiver: 300~399 Receiver--\u0026gt;\u0026gt;Sender: ACK=200, SACK: 300~400 Sender-\u0026gt;\u0026gt;Receiver: 400~499 Receiver--\u0026gt;\u0026gt;Sender: ACK=200, SACK: 300~500 Sender-\u0026gt;\u0026gt;Receiver: 500~599 Receiver--\u0026gt;\u0026gt;Sender: ACK=200, SACK: 300~600 Sender-\u0026gt;\u0026gt;Receiver: 200~299 Receiver--\u0026gt;\u0026gt;Sender: ACK=600 当接收端收到乱序的数据报时（序列号比确认号大）会在 ACK 报文中加上 SACK 选项以告知发送端已接收的部分。发送端在触发快速重传时根据确认号和 SACK 选项得知丢失的数据部分并重传该部分。\nSACK 选项 SACK 选项包含两个选项。\nSACK-Permitted 选项 该选项只能出现在 SYN 报文中，在连接建立时告知对方自己支持 SACK。选项格式如下： --- title: \u0026#34;SACK-Permitted\u0026#34; --- packet-beta 0-8: \u0026#34;Kind=4\u0026#34; 9-15: \u0026#34;Length=2\u0026#34; SACK 选项 该选项通过范围表示已经接收到的数据，不连续的部分就是丢失的数据。 --- title: \u0026#34;SACK\u0026#34; --- packet-beta 0-8: \u0026#34;Padding\u0026#34; 9-15: \u0026#34;Padding\u0026#34; 16-23: \u0026#34;Kind=5\u0026#34; 24-31: \u0026#34;Length=variable\u0026#34; 32-63: \u0026#34;Left Edge of 1st Block\u0026#34; 64-95: \u0026#34;Right Edge of 1st Block\u0026#34; 96-223: \u0026#34;...\u0026#34; 224-255: \u0026#34;Left Edge of 4th Block\u0026#34; 256-287: \u0026#34;Right Edge of 4th Block\u0026#34; D-SACK Duplicate SACK 又称 D-SACK，其主要使用 SACK 来告诉发送方有哪些数据被重复接收了。\n流量控制 在通信过程中，发送方不能无脑地向接收方发送数据，接收方可能无法及时处理数据而丢失数据，从而触发发送方的重传导致浪费网络流量。\n因此，TCP 提供了一种可以让发送方根据接收方的实际接收能力控制发送的数据量的机制，也就是 流量控制。\n累计应答 发送方收到确认报文后就可以认为该确认号之前的数据已全部被接收，即使没有收到前面的数据的确认报文。\n滑动窗口 接收窗口：接收端处理数据的能力，通过 TCP 首部的 Window 字段告知 发送窗口：控制发送端发送数据，约等于 接收窗口 窗口并不是一成不变的，而是会根据当前的应用、系统运行情况，网络状况等动态地变化，变化会通过首部的 Window 字段告知对端。\n发送端的窗口 |30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55| ^ ^ | send window(20 bytes) | ^ ^ |free window(6)| | #1 | #2 | #3 | #4 | #1：已发送且已确认的数据 #2：已发送但未确认的数据 #3：未发送但可发送的数据 #4：未发送且不可发送的数据 当可发送数据全部发送之后，可用窗口变为 0，表示接收端已经达到最大处理能力，不应再向其发送数据。\n|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55| ^ ^ | send window(20 bytes) | | #1 | #2 | #3 | 当收到确认报文后，窗口就会向右 滑动，从而可用窗口不为 0，可以继续发送数据。\n|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55| ^ ^ | send window(20 bytes) | ^ ^ |free | | #1 | #2 | #3 | #4 | 可用窗口的计算公式为：\n可用窗口 = 窗口大小 - (可发送的第一字节 - 已发送未确认的第一字节) 不可发送的第一字节 = 已发送未确认的第一字节 + 窗口大小 接收端的窗口 接收端的窗口相对简单，没有可用窗口的概念。\n|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55| ^ ^ | send window(20 bytes) | | #1 | #2 | #3 | 窗口大小 TCP 首部的 Window 字段只有 16 位，最大表示 65535 字节。窗口缩放选项可以突破这个限制。\nWindow Scale option (WSopt): Kind: 3, Length: 3 +---------+---------+---------+ | Kind=3 |Length=3 |shift.cnt| +---------+---------+---------+ 1 1 1 窗口缩放选项只能在 SYN 报文中确认且必须双方都启用才能生效，缩放因子确认后就不能再更改。之后的报文必须都包含窗口缩放选项。缩放因子最大有效值为 14。窗口大小的计算公式如下：\n$$ Size = Window * 2^{Scale} $$\n窗口关闭 当接收端发送 Window=0 的报文时，发送端就会停止发送数据，直到再次收到窗口值为非 0 的报文。此时若接收端的窗口非 0 报文丢失则可能会造成死锁。为了避免死锁，TCP 在收到零窗口通知时会启动 持续计时器。如果计时器超时，就会发送 窗口探测报文，对方在确认该报文时会给出新的窗口大小。如果新窗口仍为 0 则会重新启动持续计时器。一定次数后若窗口仍为 0，那么 TCP 将强制中断连接。\n糊涂窗口综合征 如果接收端的数据处理速度太慢，会导致发送端的发送窗口越来越小。到最后，只要接收端能够接收数据，发送端都会发送数据，哪怕只有几字节，这就是 糊涂窗口综合征。\n糊涂窗口综合征发生的条件有两个：\n接收端可以通告小窗口 发送端可以发送小数据 于是，避免出现以上两种情况便能避免糊涂窗口综合征。\n针对条件 1，可以让窗口大小小于 min(MSS, 缓存空间/2) 时发送零窗口通知，阻止发送端继续发送数据，等待接收端处理一些数据后再打开窗口。\n针对条件 2，发送端使用 Nagle 算法，只有满足以下 任一 条件时才发送数据：\n窗口大小大于或等于 MSS 并且数据大小大于或等于 MSS 收到之前发送数据的确认报文 if 有数据要发送 { if 可用窗口大小 \u0026gt;= MSS \u0026amp;\u0026amp; 可发送的数据 \u0026gt;= MSS { 立刻发送MSS大小的数据 } else { if 有未确认的数据 { 将数据放入缓存等待接收 ACK } else { 立刻发送数据 } } } 如果接收端可以通告小窗口，那么即使开启 Nagle 算法也无法避免糊涂窗口综合征。因为如果对端确认报文回复得快的话（满足 Nagle 算法条件 2），Nagle 算法就无法等到数据足够多时再进行传输。\n因此，接收端不通告小窗口且发送端开启 Nagle 算法才可以避免糊涂窗口综合征。\n拥塞控制 流量控制可以避免发送端的数据填满接收端的缓存，但并不考虑网络的拥塞状况。当网络拥堵时，如果继续发送大量数据会造成数据包丢失等情况，此时，TCP 会开始重传数据，这样会进一步加剧网络拥堵，从而陷入恶性循环。\n为此，TCP 引入了 拥塞控制，避免发送端的数据填满网络。\n拥塞窗口 拥塞窗口 是发送端维护的一个变量，它会根据网络的拥塞程度动态变化。\n加入拥塞窗口后，发送窗口 的大小为 min(拥塞窗口, 接收窗口)。\n当网络没有出现拥塞时，拥塞窗口会增大，当出现拥塞时，拥塞窗口就会减小。TCP 通过超时重传判断网络是否出现拥塞。\n慢启动 慢启动的核心规则是：每收到一个 ACK，拥塞窗口就会加 1。\n假设拥塞窗口 cwnd 初始值为 1 个 MSS，\n连接建立后，发送端发送 cwnd 字节数据 收到 ACK 后，cwnd 加 1，变为 2 个 MSS，继续发送数据 收到 2 个 ACK 后，cwnd 加 2，变为 4 个 MSS，继续发送数据 …… 由此可见，每一轮 RTT 后，cwnd 变为原来的两倍，在慢启动阶段，拥塞窗口呈指数增长。\n当 cwnd 大于慢开始门限 ssthresh 后，就会进入 拥塞避免 阶段。\n拥塞避免 慢启动的核心规则是：每收到一个 ACK，拥塞窗口就会增加 1/cwnd。\n假设此时拥塞窗口 cwnd 为 8 个 MSS，\n发送端发送 8 个长度为 MSS 的数据报 收到 8个 ACK 后，cwnd 加 1，变为 9 个 MSS，继续发送数据 收到 9 个 ACK 后，cwnd 加 1，变为 10 个 MSS，继续发送数据 …… 由此可见，每一轮 RTT 后，cwnd 加 1，在拥塞避免阶段，拥塞窗口呈线性增长。\n拥塞发生 随着拥塞窗口的增加，拥塞不可避免地发生，TCP 通过是否发生重传来判断拥塞情况。\n超时重传 发生超时重传时，TCP 会先将 ssthresh 设为 cwnd/2，并将 cwnd 重置为初始值，然后进入慢启动。\n快速重传 当发生快速重传时，TCP 会先将 cwnd 设为 cwnd/2，并将 ssthresh 设为 cwnd，然后执行 快速恢复 算法。\n快速恢复算法如下：\ncwnd = ssthresh + 3。3 表示收到的三个重复的 ACK 重传数据报 每收到一个同样的 ACK，cwnd 加 1，每 3 个相同的 ACK 触发一次快速重传 重复 3 直至收到新的 ACK。收到新的 ACK 后将 cwnd 设为 ssthresh 并进入拥塞避免阶段 快速重传是为了尽快将丢失的数据发送给对方，所以在收到相同的 ACK 后 cwnd 会加 1 以加快从对端获得 ACK 的速度。\n","permalink":"https://tpcad.github.io/posts/net_tcp/","summary":"\u003ch2 id=\"tcp-首部\"\u003eTCP 首部\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003e---\ntitle: \u0026#34;TCP Packet\u0026#34;\n---\npacket-beta\n0-15: \u0026#34;源端口号\u0026#34;\n16-31: \u0026#34;目的端口号\u0026#34;\n32-63: \u0026#34;序列号\u0026#34;\n64-95: \u0026#34;确认应答号\u0026#34;\n96-99: \u0026#34;数据偏移量\u0026#34;\n100-105: \u0026#34;保留\u0026#34;\n106: \u0026#34;URG\u0026#34;\n107: \u0026#34;ACK\u0026#34;\n108: \u0026#34;PSH\u0026#34;\n109: \u0026#34;RST\u0026#34;\n110: \u0026#34;SYN\u0026#34;\n111: \u0026#34;FIN\u0026#34;\n112-127: \u0026#34;窗口\u0026#34;\n128-143: \u0026#34;校验和\u0026#34;\n144-159: \u0026#34;紧急指针\u0026#34;\n160-191: \u0026#34;选项（长度可变）\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e序列号\u003c/strong\u003e：TCP 是面向字节流的，其传输的每一个数据字节都对应一个序列号。序列号的初始值是一个随机数，每发送一次 TCP 报文序列号都会累加一次报文的数据字节数\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e确认应答号\u003c/strong\u003e：下一次期望收到的数据的序列号\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e数据偏移量\u003c/strong\u003e：数据部分的偏移量，也就是首部的长度。单位为 4 字节。因此 TCP 首部最长为 $(2^4-1)*4=60$ 字节。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e控制位\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eACK\u003c/em\u003e：该位为 1 时表示确认应答字段有效，除最初建立连接时的 \u003ccode\u003eSYN\u003c/code\u003e 包外该位必须置 1\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eRST\u003c/em\u003e：该位为 1 时表示 TCP 连接出现异常必须强制断开连接\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eSYN\u003c/em\u003e：该位为 1 时表示希望建立 TCP 连接，并在其序列号字段确定序列号初始值\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eFIN\u003c/em\u003e：该位为 1 时表示今后不会再有数据发送，希望断开 TCP 连接\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tcp-连接\"\u003eTCP 连接\u003c/h2\u003e\n\u003ch3 id=\"三次握手\"\u003e三次握手\u003c/h3\u003e\n\u003cp\u003e建立一个 TCP 连接需要经过三次握手过程。\u003c/p\u003e","title":"TCP 基础"},{"content":"Traits in Rust trait 定义了某个特定类型拥有可能与其他类型共享的功能。\n定义与实现 trait 定义 trait 一个 trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。\ntrait Area { fn area(\u0026amp;self) -\u0026gt; u32; } 为类型实现 trait 使用 impl for 为类型实现 trait。\nimpl Area for Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } impl Area for Circle { fn area(\u0026amp;self) -\u0026gt; u32 { 3 * self.radio * self.radio } } 默认实现 trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String { String::from(\u0026#34;(Read more...)\u0026#34;); } } // 因为有默认实现，所以可以指定一个空 impl 块 impl Summary for Tweet {} trait 作为参数 通过将 trait 作为函数参数，可以使该参数支持任何实现了指定 trait 的类型。\nimpl Trait 语法 fn notify(item: \u0026amp;impl Summary) { println!(\u0026#34;{}\u0026#34;, item.summarize()); } Trait Bound 语法 fn notify\u0026lt;T: Summary\u0026gt;(item: \u0026amp;T) { println!(\u0026#34;{}\u0026#34;, item.summarize()); } // 泛型限制了两个参数必须是相同类型 fn notify\u0026lt;T: Summary\u0026gt;(item1: \u0026amp;T, item2: \u0026amp;T) { // impl Trait 允许两个参数是不同类型 fn notify(item1: \u0026amp;impl Summary, item2: \u0026amp;impl Summary) { 通过 + 指定多个 trait bound fn notify(item: \u0026amp;(impl Summary + Display)) {} fn notify\u0026lt;T: Summary + Display\u0026gt;(item: \u0026amp;T) {} 通过 where 简化 trait bound fn some_function\u0026lt;T, U\u0026gt;(t: \u0026amp;T, u: \u0026amp;U) -\u0026gt; i32 where T: Display + Clone, U: Clone + Debug, { 返回实现了 trait 的类型 fn returns_summarizable() -\u0026gt; impl Summary { 注意，这只适用于返回单一类型的情况。\n使用 trait bound 有条件地实现方法 impl\u0026lt;T\u0026gt; Pair\u0026lt;T\u0026gt; { fn new(x: T, y: T) -\u0026gt; Self { Self { x, y } } } // 只有实现了 Display 和 PartialOrd Trait 的泛型 T 才会拥有这个方法 impl\u0026lt;T: Display + PartialOrd\u0026gt; Pair\u0026lt;T\u0026gt; { fn cmp_display(\u0026amp;self) { if self.x \u0026gt;= self.y { println!(\u0026#34;The largest member is x = {}\u0026#34;, self.x); } else { println!(\u0026#34;The largest member is y = {}\u0026#34;, self.y); } } } 也可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 blanket implementations\n// blanket implementations // 任何实现了 Display trait 的类型都会自动实现 ToString trait impl\u0026lt;T: Display\u0026gt; ToString for T { 孤儿规则 只有在 trait 或类型至少有一个属于当前 crate 时，才能对类型实现该 trait。\n比如，不能在自己的 crate 中为标准库中的类型实现标准库中的 trait。因为它们均不属于当前 crate。\nTrait 对象 泛型虽然很方便，但也有限制。比如，泛型限制了参数只能是同一种类型。\n如下代码所示，Vec 的元素必须是相同类型的。\ntrait Draw { fn draw(\u0026amp;self); } struct Button { name: String, } impl Draw for Button { fn draw(\u0026amp;self) { println!(\u0026#34;Draw button\u0026#34;); } } struct TextField { name: String, } impl Draw for TextField { fn draw(\u0026amp;self) { println!(\u0026#34;Draw text field\u0026#34;); } } fn main() { let vec = vec![ Box::new(Button { name: \u0026#34;button\u0026#34;.to_string(), }), // mismatched types expected `Button`, found `TextField` Box::new(TextField { name: \u0026#34;text field\u0026#34;.to_string(), }), ]; } Trait 对象则允许在运行时替代多种具体类型。\n// 使用 dyn 关键字声明 trait 对象 let vec: Vec\u0026lt;Box\u0026lt;dyn Draw\u0026gt;\u0026gt; = vec![ Box::new(Button { name: \u0026#34;button\u0026#34;.to_string(), }), Box::new(TextField { name: \u0026#34;text field\u0026#34;.to_string(), }), ]; for i in vec { i.draw(); } Rust 使用使用动态分发（Dynamic Dispatch）实现 trait 对象。此时编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。而编译器只能保证类型实现了相应的 trait。\n关联类型 关联类型（associated types）的作用与泛型十分相似，但关联类型限制了我们只能实现一次 trait。\npub trait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; } impl Iterator for Counter { // 只能指定一次 Item 的类型 type Item = u32; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { // --snip-- 默认泛型类型参数 在使用泛型类型参数时，可以为泛型指定一个默认的具体类型。\n// 提供默认的泛型类型参数 trait Add\u0026lt;Rhs=Self\u0026gt; { type Output; fn add(self, rhs: Rhs) -\u0026gt; Self::Output; } // 使用默认泛型类型参数 impl Add for Point { type Output = Point; fn add(self, other: Point) -\u0026gt; Point { Point { x: self.x + other.x, y: self.y + other.y, } } } // 不使用默认泛型类型参数 impl Add\u0026lt;Meters\u0026gt; for Millimeters { type Output = Millimeters; fn add(self, other: Meters) -\u0026gt; Millimeters { Millimeters(self.0 + (other.0 * 1000)) } } 完全限定语法 Rust 不能避免一个 trait 与另一个 trait 拥有同名的方法，也不能阻止为同一类型实现这两个 trait。\ntrait Pilot { fn fly(\u0026amp;self); } trait Wizard { fn fly(\u0026amp;self); } struct Human; // 实现两个有同名方法的 trait impl Pilot for Human { fn fly(\u0026amp;self) { println!(\u0026#34;Pilot fly\u0026#34;); } } impl Wizard for Human { fn fly(\u0026amp;self) { println!(\u0026#34;Wizard fly\u0026#34;); } } // 自身也实现该方法 impl Human { fn fly(\u0026amp;self) { println!(\u0026#34;Flying\u0026#34;); } } fn main() { let human = Human {}; // 默认调用自身实现 human.fly(); Wizard::fly(\u0026amp;human); Pilot::fly(\u0026amp;human); } 关联函数没有 \u0026amp;self 参数，不能使用上面的方法来消除歧义。此时只能使用完全限定语法（fully qualified syntax）。\n// 关联函数而非方法 trait Pilot { fn fly(); } trait Wizard { fn fly(); } struct Human; impl Pilot for Human { fn fly() { println!(\u0026#34;Pilot fly\u0026#34;); } } impl Wizard for Human { fn fly() { println!(\u0026#34;Wizard fly\u0026#34;); } } impl Human { fn fly() { println!(\u0026#34;Flying\u0026#34;); } } fn main() { Human::fly(); // 完全限定语法调用同名关联函数 \u0026lt;Human as Wizard\u0026gt;::fly(); \u0026lt;Human as Pilot\u0026gt;::fly(); } 父 trait 父 trait 可以让类型在一个 trait 的同时也必须实现另一个 trait。\nuse std::fmt; // 父 trait trait OutlinePrint: fmt::Display { fn outline_print(\u0026amp;self) { // 可以使用父 trait 的方法 let output = self.to_string(); let len = output.len(); println!(\u0026#34;{}\u0026#34;, \u0026#34;*\u0026#34;.repeat(len + 4)); println!(\u0026#34;*{}*\u0026#34;, \u0026#34; \u0026#34;.repeat(len + 2)); println!(\u0026#34;* {output} *\u0026#34;); println!(\u0026#34;*{}*\u0026#34;, \u0026#34; \u0026#34;.repeat(len + 2)); println!(\u0026#34;{}\u0026#34;, \u0026#34;*\u0026#34;.repeat(len + 4)); } } Sized Trait **动态大小类型（dynamically sized types）**允许我们处理只用在运行时才知道大小的类型。\n因为动态大小类型只能在运行时确定，所以它的值必须置于某种指针之后。\n比如 trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。所以它必须放在指针之后，\u0026amp;dyn trait 或 Box\u0026lt;dyn trait\u0026gt;。\n为了处理 DST，Rust 提供了 Sized trait 来决定一个类型的大小是否在编译时可知。这个 trait 会自动为所有在编译时就知道大小的类型实现。另外，Rust 会为每一个泛型函数增加 Sized bound。\nfn generic\u0026lt;T\u0026gt;(t: T){} fn generic\u0026lt;T: Sized\u0026gt;(t: T){} Sized trait 还有一个特殊的语法，?Sized。它表示该类型可能是也可能不是 Sized。该语法只能用于 Sized。\n// 参数类型从 T 变成了 \u0026amp;T，因为 DST 必须置于某种指针之后 fn generic\u0026lt;T: ?Sized\u0026gt;(t: \u0026amp;T){} #[derive(Debug)] struct Bar\u0026lt;T: ?Sized\u0026gt;(T); // [i32] 没有实现 Sized trait，所以它的大小在编译时是不可知的 // 如果不使用 ?Sized trait，以下代码将无法编译 fn main() { let sized: Bar\u0026lt;[i32; 8]\u0026gt; = Bar([0; 8]); let dynamic1: Box\u0026lt;Bar\u0026lt;[i32]\u0026gt;\u0026gt; = Box::new(Bar([])); let dynamic2: Box\u0026lt;Bar\u0026lt;[i32]\u0026gt;\u0026gt; = Box::new(sized); println!(\u0026#34;{:#?}\u0026#34;, dynamic1); println!(\u0026#34;{:#?}\u0026#34;, dynamic2); } ","permalink":"https://tpcad.github.io/posts/rust_trait/","summary":"\u003ch1 id=\"traits-in-rust\"\u003eTraits in Rust\u003c/h1\u003e\n\u003cp\u003etrait 定义了某个特定类型拥有可能与其他类型共享的功能。\u003c/p\u003e\n\u003ch2 id=\"定义与实现-trait\"\u003e定义与实现 trait\u003c/h2\u003e\n\u003ch3 id=\"定义-trait\"\u003e定义 trait\u003c/h3\u003e\n\u003cp\u003e一个 trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etrait\u003c/span\u003e Area {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earea\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eself) -\u0026gt; \u003cspan style=\"color:#66d9ef\"\u003eu32\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"为类型实现-trait\"\u003e为类型实现 trait\u003c/h3\u003e\n\u003cp\u003e使用 \u003ccode\u003eimpl for\u003c/code\u003e 为类型实现 trait。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eimpl\u003c/span\u003e Area \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e Rectangle {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earea\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eself) -\u0026gt; \u003cspan style=\"color:#66d9ef\"\u003eu32\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self.width \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e self.height\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eimpl\u003c/span\u003e Area \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e Circle {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earea\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eself) -\u0026gt; \u003cspan style=\"color:#66d9ef\"\u003eu32\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e self.radio \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e self.radio\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"默认实现\"\u003e默认实现\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etrait\u003c/span\u003e Summary {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esummarize\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eself) -\u0026gt; String {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        String::from(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;(Read more...)\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 因为有默认实现，所以可以指定一个空 impl 块\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eimpl\u003c/span\u003e Summary \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e Tweet {}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"trait-作为参数\"\u003etrait 作为参数\u003c/h2\u003e\n\u003cp\u003e通过将 trait 作为函数参数，可以使该参数支持任何实现了指定 trait 的类型。\u003c/p\u003e","title":"Rust Traits"},{"content":"线程基础 创建线程 使用 thread::spawn 创建线程，它接受一个 FnOnce 闭包。\nuse std::{thread, time::Duration}; fn main() { let handle = thread::spawn(|| { for i in 0..10 { println!(\u0026#34;{i}: spawned thread echo\u0026#34;); thread::sleep(Duration::from_millis(10)); } }); for i in 0..5 { println!(\u0026#34;{i}: main thread echo\u0026#34;); thread::sleep(Duration::from_millis(10)); } handle.join().unwrap(); } 等待线程结束 使用 join 方法等待线程结束。\nlet handle = thread::spawn(|| { for i in 0..10 { println!(\u0026#34;{i}: spawned thread echo\u0026#34;); thread::sleep(Duration::from_millis(10)); } }); // 对 spawn 的返回值调用 join 方法 handle.join().unwrap(); move 闭包与线程 use std::thread; fn main() { let v = vec![1, 2, 3]; // 使用 move 获取所有权 let handle = thread::spawn(move || { println!(\u0026#34;Here\u0026#39;s a vector: {v:?}\u0026#34;); }); handle.join().unwrap(); } 消息传递 Rust 通过**信道（channel）**实现消息传递。\n信道由两部分组成：一个发送者（transmitter）和接收者（receiver）。当任一方被丢弃时可以认为信道被关闭了。\nRust 的信道实现在 std::sync::mpsc 中。\nmpsc::channel 函数用于创建一个信道。它会返回一个元祖，第一个元素是发送者，第二个元素是接收者。\n发送者调用 send 方法发送消息。它的参数就是要发送的值。它返回一个 Result\u0026lt;(), SendError\u0026lt;T\u0026gt;\u0026gt;。错误通常发生在接收者已经被丢弃时。\n注意，send 方法会获取参数的所有权。\n接受者调用 recv 方法接收消息。该方法会阻塞线程执行直到从信道中获取一个值。若信道已经被关闭，则会返回一个错误。\n另外还有 try_recv 方法可以接收信息。这个方法不会阻塞线程，而是立刻返回一个 Result。\nuse std::{sync::mpsc, thread}; fn main() { // mpsc:;channel 创建一个信道。 let (tx, rx) = mpsc::channel(); thread::spawn(move || { let val = \u0026#34;hello\u0026#34;.to_owned(); // 调用 send 方法发送消息 tx.send(val).unwrap(); }); // 接收者调用 recv 方法接收消息 let rec = rx.recv().unwrap(); println!(\u0026#34;{rec} from spwaned thread\u0026#34;); } 创建多个发送者 可以使用 clone 方法创建多个发送者。同时，将接收者当作一个迭代器不断从信道中获取消息。\nuse std::{sync::mpsc, thread}; fn main() { let (tx, rx) = mpsc::channel(); let tx1 = tx.clone(); thread::spawn(move || { let val = \u0026#34;hello\u0026#34;.to_owned(); tx.send(val).unwrap(); }); thread::spawn(move || { let val = \u0026#34;hello\u0026#34;.to_owned(); tx1.send(val).unwrap(); }); for rec in rx { println!(\u0026#34;{rec} from spwaned thread\u0026#34;); } } 互斥器 互斥器保证在任意时刻，只有一个线程访问某些数据。\n在 Rust 中通过 Mutex\u0026lt;T\u0026gt; 创建一个互斥锁。访问互斥器的数据前需要获取锁。lock 方法返回一个类型为 MutexGuard 的智能指针。在 MutexGuard 离开作用域时，会调用 Drop trait 释放锁。\nuse std::sync::Mutex; fn main() { let m = Mutex::new(5); { let mut num = m.lock().unwrap(); *num = 6; } println!(\u0026#34;m = {m:?}\u0026#34;); } Mutex\u0026lt;T\u0026gt; 并不能直接用于多线程。Arc\u0026lt;T\u0026gt; 是一个类似 Rc\u0026lt;T\u0026gt; 但可用于多线程的智能指针。\nuse std::{ sync::{Arc, Mutex}, thread, }; fn main() { // 将 Mutex\u0026lt;T\u0026gt; 放在 Arc\u0026lt;T\u0026gt; 中 let counter = Arc::new(Mutex::new(0)); let mut handlers = vec![]; for _ in 0..10 { let counter = Arc::clone(\u0026amp;counter); let handler = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; println!(\u0026#34;counter: {num}\u0026#34;); }); handlers.push(handler); } for handler in handlers { handler.join().unwrap(); } // println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); } ","permalink":"https://tpcad.github.io/posts/rust_thread/","summary":"\u003ch2 id=\"线程基础\"\u003e线程基础\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e创建线程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用 \u003ccode\u003ethread::spawn\u003c/code\u003e 创建线程，它接受一个 \u003ccode\u003eFnOnce\u003c/code\u003e 闭包。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003euse\u003c/span\u003e std::{thread, time::Duration};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e handle \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e thread::spawn(\u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e..\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{i}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e: spawned thread echo\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            thread::sleep(Duration::from_millis(\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e..\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{i}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e: main thread echo\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        thread::sleep(Duration::from_millis(\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    handle.join().unwrap();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e等待线程结束\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用 \u003ccode\u003ejoin\u003c/code\u003e 方法等待线程结束。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e handle \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e thread::spawn(\u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#66d9ef\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e..\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{i}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e: spawned thread echo\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        thread::sleep(Duration::from_millis(\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 对 spawn 的返回值调用 join 方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003ehandle.join().unwrap();\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003emove 闭包与线程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003euse\u003c/span\u003e std::thread;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e v \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e vec![\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 使用 move 获取所有权\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e handle \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e thread::spawn(\u003cspan style=\"color:#66d9ef\"\u003emove\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Here\u0026#39;s a vector: \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{v:?}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    handle.join().unwrap();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"消息传递\"\u003e消息传递\u003c/h2\u003e\n\u003cp\u003eRust 通过**信道（channel）**实现消息传递。\u003c/p\u003e","title":"Thread in Rust"},{"content":"Selection Sort 以升序为例，选择排序的思想是遍历未排序元素，选择其中最小的元素，将其移动到未排序元素开始位置。\n性质 最好时间复杂度：$O(n^2)$ 最坏时间复杂度：$O(n^2)$ 平均时间复杂度：$O(n^2)$ 稳定性：不稳定 演示 // 原数组，所有元素均位于未排序部分 [3, 4, 1, 9, 5, 8, 0] // 第一轮，遍历未排序部分，选择最小的元素（0），移动到未排序部分开始位置 // 有序部分位于数组头部 [0, 4, 3, 9, 5, 8, 1] // 第二轮，遍历未排序部分，选择最小的元素（1），移动到未排序部分开始位置 [0, 1, 4, 9, 5, 8, 3] // 第三轮，遍历未排序部分，选择最小的元素（3），移动到未排序部分开始位置 [0, 1, 3, 9, 5, 8, 4] // ... 示例代码 void selection_sort(int *arr, int len) { for (int i = 0; i \u0026lt; len - 1; ++i) { int min_idx = i; int j = i + 1; for (; j \u0026lt; len; ++j) { if (arr[min_idx] \u0026gt; arr[j]) { min_idx = j; // 记录索引位置 } } if (min_idx != i) { swap(\u0026amp;arr[i], \u0026amp;arr[min_idx]); } } } Bubble Sort 以升序为例，在未排序元素中依次比较相邻两个元素，若乱序则交换两个元素，这样一来较大的元素就会被慢慢移动到末尾有序排列。通常在冒泡排序中设置一个 flag，当没有发生交换操作时，说明数组已经有序，停止遍历。\n性质 最优时间复杂度：$O(n)$（正序） 最坏时间复杂度：$O(n^2)$（逆序） 平均时间复杂度：$O(n^2)$ 稳定性：稳定 演示 假设有数组 3, 4, 1, 9, 5, 8, 0。\n以升序为例，比较索引为 0 的元素和索引为 1 的元素，若前者大于后者，交换二者位置。接着比较索引为 1 的元素和索引为 2 的元素，若前者大于后者，交换二者位置。依次类推，直至最后一组相邻元素。然后再从头开始比较相邻的两个元素，此次不包括最后一个元素。\n// 原数组 [3, 4, 1, 9, 5, 8, 0] // 第一轮，3\u0026lt;4，不交换 [3, 4, 1, 9, 5, 8, 0] // 第一轮，1\u0026lt;4，交换 [3, 1, 4, 9, 5, 8, 0] // 第一轮，4\u0026lt;9，不交换 [3, 1, 4, 9, 5, 8, 0] // 第一轮，5\u0026lt;9，交换 [3, 1, 4, 5, 9, 8, 0] // 第一轮，9\u0026gt;8，交换 [3, 1, 4, 5, 8, 9, 0] // 第一轮，9\u0026gt;0，交换 [3, 1, 4, 5, 8, 0, 9] // 第一轮结束，最大值 9 被交换到数组尾部 [3, 1, 4, 5, 8, 0, 9] // 第二轮，不包括尾部有序部分 [1, 3, 4, 5, 0, 8, 9] // 第三轮，不包括尾部有序部分 [1, 3, 4, 0, 5, 8, 9] // ... 示例代码 fn main() { let mut arr = [1, 2, 6, 3, 7, 3, 9, 4, 0]; let mut flag = true; while flag { flag = false; for j in 0..arr.len() - 1 { if arr[j] \u0026gt; arr[j + 1] { flag = true; arr.swap(j, j + 1) } } } println!(\u0026#34;{:#?}\u0026#34;, arr) } 上面的实现每次都要比较到数组的最后，而每次遍历之后尾部的元素都是有序的，并不需要再进行比较，因此可以记录上次交换操作的位置，下一轮循环就可以在该位置结束，因为后面的元素已经是有序的了。\nfn main() { let mut arr = [1, 2, 6, 3, 7, 3, 9, 4, 0]; let mut unsorted = arr.len() - 1; while unsorted != 0 { let mut u = 0; for j in 0..unsorted { if arr[j] \u0026gt; arr[j + 1] { arr.swap(j, j + 1); u = j; // 记录上次比较操作的位置 } } unsorted = u; } println!(\u0026#34;{:#?}\u0026#34;, arr) } Insertion Sort 以升序为例，插入排序将数组分成未排序和已排序两部分，每次从未排序部分按顺序选择一个元素与已排序部分比较，将其插入到合适位置。\n性质 最优时间复杂度：$O(n)$（正序） 最坏时间复杂度：$O(n^2)$（逆序）， 平均时间复杂度：$O(n^2)$ 稳定性：稳定 演示 // 原数组，视索引为 `0` 的元素为已排序部分，剩下元素为未排序部分。 [3, 1, 4, 9, 5, 8, 0] // 第一轮，选择未排序部分第一个元素，将其插入到已排序部分合适位置 [1, 3, 4, 9, 5, 8, 0] // 第一轮，选择未排序部分第一个元素，将其插入到已排序部分合适位置 [1, 3, 4, 9, 5, 8, 0] 示例代码 void insertion_sort(int a[], int len) { for (auto i = 1; i \u0026lt; len; ++i) { int key = a[i]; int j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt; key) { a[j + 1] = a[j]; --j; } a[j + 1] = key; } } 优化 在将元素插入到已排序部分的操作中，可以使用二分查找法优化，但不会改变时间复杂度。\nTODO: 折半插入排序\nShell Sort 希尔排序，又叫缩小增量排序，是插入排序的一种改良版本。希尔排序充分利用了插入排序的两个优点：\n插入排序在数组几乎有序时效率极高 插入排序在元素数量较少时效率极高 希尔排序依据间距将数组分为若干子序列，并对子序列进行插入排序，然后缩小间距，产生新的子序列，再对新的子序列进行插入排序，如此往复，直至间距为 1，此时再进行插入排序就是对整个数组进行插入排序。\n性质 希尔排序的时间复杂度与间距的选择有关，通常情况下：\n最好时间复杂度：$O(nlog^2n)$ 最坏时间复杂度：$O(n^2)$ 平均时间复杂度：$O(nlog^2n)$ 稳定性：不稳定 演示 // 待排序数组 [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] // 假设间距为 4，可得以下子序列 [3, 23, 9] -\u0026gt; [3, 9, 23] [54, 11, 12] -\u0026gt; [11, 12, 54] [35, 74, 45] -\u0026gt; [35, 45, 74] [87, 2, 53] -\u0026gt; [2, 53, 87] // 对子序列进行插入排序 [3, 11, 35, 9, 2, 12, 45, 53, 23, 54, 74, 87] // 取间距为 1，即插入排序 [2, 3, 9, 11, 12, 23, 35, 45, 53, 54, 74, 87] 示例代码 void shell_sort(int *arr, int len) { int d = 1; while (d \u0026lt; len / 3) { d = d * 3 + 1; } // 直接使用插入排序 while (d \u0026gt;= 1) { // 每个间距一次循环 for (int i = 0; i \u0026lt; d; ++i) { // 间距划分出的子序列数量 for (int j = i + d; j \u0026lt; len; j += d) { // 每个子序列进行插入排序 int key = arr[j]; int k = j - d; while (k \u0026gt;= 0 \u0026amp;\u0026amp; arr[k] \u0026gt; key) { arr[k + d] = arr[k]; k -= d; } arr[k + d] = key; } } d /= 3; } } 如果直接使用类似前文的插入排序算法，需要用到四层循环。而下面的插入排序只需要三层循环，这种形式的插入排序并不会一次性将子序列排序，而是每次只排序一个子序列的一个元素。\nvoid shell_sort(int *arr, int len) { int d = 1; while (d \u0026lt; len / 3) { d = d * 3 + 1; } while (d \u0026gt;= 1) { // i 从间距 d 开始，将前面的排序视为每个子序列已排序部分，每次自增 1， // 每次只排序一个子序列的一个元素，i 每自增 d 次就表示所有子序列都排序 // 了一个元素 for (int i = d; i \u0026lt; len; ++i) { int key = arr[i]; int j = i - d; for (; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key; j -= d) { arr[j + d] = arr[j]; } arr[j + d] = key; } d /= 3; } } Quick Sort 快速排序是一种递归的排序算法，它将数组以某个元素为基准，划分为小于基准和大于基准的两部分，再分别在这两个部分中执行相同操作直至不能再划分。\n性质 最优时间复杂度：$O(n\\log n)$ 最坏时间复杂度：$O(n^2)$ 平均时间复杂度：$O(n\\log n)$ 空间复杂度：$O(\\log n)$（递归调用栈） 稳定性：不稳定 演示 [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] // 以 53 为基准，与 l 比较，小于或等于则 l+1，并继续比较 l， // 大于则将 l 移动到 r，且 r+1，并比较 r，如此往复。 [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] ^l ^r [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 53] ^l ^r [3, 54, 35, 87, 23, 11, 74, 2, 9, 12, 45, 54] ^l ^r [3, 45, 35, 87, 23, 11, 74, 2, 9, 12, 45, 54] ^l ^r [3, 45, 35, 87, 23, 11, 74, 2, 9, 12, 45, 54] ^l ^r [3, 45, 35, 87, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 12, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 74, 2, 9, 74, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 9, 2, 9, 74, 87, 54] ^l ^r [3, 45, 35, 12, 23, 11, 9, 2, 9, 74, 87, 54] ^lr [3, 45, 35, 12, 23, 11, 9, 2, 53, 74, 87, 54] ^lr 示例代码 static int partition(int *arr, int low, int high) { int pivot = arr[low]; while (low \u0026lt; high) { while (low \u0026lt; high \u0026amp;\u0026amp; pivot \u0026lt;= arr[high]) { --high; } arr[low] = arr[high]; while (low \u0026lt; high \u0026amp;\u0026amp; pivot \u0026gt;= arr[low]) { ++low; } arr[high] = arr[low]; } arr[low] = pivot; return low; } static void quick_sort_helper(int *arr, int lhs, int rhs) { if (lhs \u0026lt; rhs) { int pivot = partition(arr, lhs, rhs); quick_sort_helper(arr, lhs, pivot - 1); quick_sort_helper(arr, pivot + 1, rhs); } } void quick_sort(int *arr, const int len) { quick_sort_helper(arr, 0, len - 1); } Merge Sort 归并排序基于分治思想将数组分段排序后合并。分段操作，当只有一个元素时，数组有序，不再分段，当元素大于 1 时，数组被递归地分成有序的两部分；合并操作，借助额外的数组，有序地将两部分数组中最小的元素放入额外数组，再用额外数组覆盖原数组。\n最优时间复杂度：$O(n \\log n)$ 最坏时间复杂度：$O(n \\log n)$ 平均时间复杂度：$O(n \\log n)$ 空间复杂度：$O(n)$ static void merge(int *arr, int l, int r, int len) { int *tmp = (int *)malloc(sizeof(int) * len); if (tmp == NULL) { printf(\u0026#34;Can not allocate memory!\\n\u0026#34;); exit(1); } int mid = (l + r) \u0026gt;\u0026gt; 1; int i = l, j = mid, k = l; // index variable // 合并两个子序列 while (i \u0026lt; mid \u0026amp;\u0026amp; j \u0026lt; r) { if (arr[i] \u0026lt;= arr[j]) { tmp[k++] = arr[i++]; } else { tmp[k++] = arr[j++]; } } // 未结束的子序列 if (j == r) { while (i \u0026lt; mid) { tmp[k++] = arr[i++]; } } else { while (j \u0026lt; r) { tmp[k++] = arr[j++]; } } // 有序序列覆盖原序列 for (k = l; k \u0026lt; r; ++k) { arr[k] = tmp[k]; } free(tmp); } static void merge_sort_helper(int *arr, int l, int r, int len) { if (r - l \u0026lt;= 1) { return; } int mid = (r + l) \u0026gt;\u0026gt; 1; merge_sort_helper(arr, l, mid, len); merge_sort_helper(arr, mid, r, len); merge(arr, l, r, len); } void merge_sort(int *arr, const int len) { merge_sort_helper(arr, 0, len, len); } 归并排序求逆序对数量 逆序对是 i \u0026lt; j 且 $a_i \u0026gt; a_j$ 的有序数对 (i, j)。\n在归并排序进行合并操作时，若出现左子序列元素 a 大于右子序列元素 b，则说明左子序列元素 a 及左子序列剩余元素都大于右子序列元素 b。\n设全局变量 cnt = 0 以记录逆序对个数。在合并操作中添加 cnt += mid - i 即可记录逆序对个数。\nwhile (i \u0026lt; mid \u0026amp;\u0026amp; j \u0026lt; r) { if (arr[i] \u0026lt;= arr[j]) { tmp[k++] = arr[i++]; } else { tmp[k++] = arr[j++]; cnt += mid - i; // 记录逆序对个数 } } Heap Sort 堆排序是一种基于二叉堆的排序算法。二叉堆是一棵完全二叉树。大根堆是指二叉堆的每棵子树的父结点的值都大于其子结点，小根堆则相反。\n堆排序首先要建堆，在建堆过程中会把数组中最大的元素移动到根结点，将根结点与数组最后一个元素交换即可完成一次排序。之后继续将剩余元素建堆、交换，直至完成排序。\n采用向下调整的方法建堆，即选择一个非叶子结点，与其最大子结点交换，若交换后该结点仍为非叶子结点，则继续与其最大子结点交换，直至该结点为叶子结点。\n性质 最优时间复杂度：$O(n\\log n)$ 最坏时间复杂度：$O(n\\log n)$ 平均时间复杂度：$O(n\\log n)$ 稳定性：不稳定 示例代码 void heapify(int *arr, int parent, int len) { int child = (parent \u0026lt;\u0026lt; 1) + 1; // 左子结点索引 while (child \u0026lt; len) { // 判断是否为非叶子结点 // 最大子结点 if (arr[child + 1] \u0026gt; arr[child]) { ++child; } if (arr[parent] \u0026gt;= arr[child]) { break; } else { // 与最大子结点交换 swap(\u0026amp;arr[parent], \u0026amp;arr[child]); // 继续向下调整 parent = child; child = (parent \u0026lt;\u0026lt; 1) + 1; } } } void heap_sort(int *arr, const int len) { // 首次建堆，从最后一个非叶子结点开始向前遍历 for (int i = (len - 1 - 1) \u0026gt;\u0026gt; 2; i \u0026gt;= 0; --i) { heapify(arr, i, len); } for (int i = len - 1; i \u0026gt; 0; --i) { // 交换完成一次排序 swap(\u0026amp;arr[0], \u0026amp;arr[i]); heapify(arr, 0, i - 1); } } 计数排序 计数排序使用一个额外数组记录待排序数组中元素的个数，然后根据该数组将待排序数组的元素排到正确位置。\n最好时间复杂度：$O(n+w)$ 最坏时间复杂度：$O(n+w)$ 平均时间复杂度：$O(n+w)$ 空间复杂度：$O(w)$，其中 w 代表待排序数据的值域大小 稳定性：稳定 示例代码 void counting_sort(int *arr, const int len) { int max = arr[0]; int *aux = (int *)malloc(len * sizeof(int)); // 拷贝数组 for (int i = 0; i \u0026lt; len; ++i) { if (max \u0026lt; arr[i]) { max = arr[i]; // 找到序列最大值 } aux[i] = arr[i]; } int *cnt = (int *)malloc((max + 1) * sizeof(int)); for (int i = 0; i \u0026lt; len; ++i) { // 计数 cnt[arr[i]]++; } // 计算前缀和，使计数数组表示有多少个元素小于或等于（包括自己）其所代表的元素 for (int i = 1; i \u0026lt; max + 1; ++i) { cnt[i] += cnt[i - 1]; } // 排序 for (int i = len - 1; i \u0026gt;= 0; --i) { arr[--cnt[aux[i]]] = aux[i]; } free(cnt); free(aux); } ","permalink":"https://tpcad.github.io/posts/sort_algorithm/","summary":"\u003ch2 id=\"selection-sort\"\u003eSelection Sort\u003c/h2\u003e\n\u003cp\u003e以升序为例，选择排序的思想是遍历未排序元素，选择其中最小的元素，将其移动到未排序元素开始位置。\u003c/p\u003e\n\u003ch3 id=\"性质\"\u003e性质\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e最好时间复杂度：$O(n^2)$\u003c/li\u003e\n\u003cli\u003e最坏时间复杂度：$O(n^2)$\u003c/li\u003e\n\u003cli\u003e平均时间复杂度：$O(n^2)$\u003c/li\u003e\n\u003cli\u003e稳定性：不稳定\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"演示\"\u003e演示\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 原数组，所有元素均位于未排序部分\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 第一轮，遍历未排序部分，选择最小的元素（0），移动到未排序部分开始位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 有序部分位于数组头部\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 第二轮，遍历未排序部分，选择最小的元素（1），移动到未排序部分开始位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 第三轮，遍历未排序部分，选择最小的元素（3），移动到未排序部分开始位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e9\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// ...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"示例代码\"\u003e示例代码\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eselection_sort\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003earr, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e len) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e len \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e min_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e i;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (; j \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e len; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ej) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (arr[min_idx] \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e arr[j]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                min_idx \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e j; \u003cspan style=\"color:#75715e\"\u003e// 记录索引位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (min_idx \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e i) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eswap\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003earr[i], \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003earr[min_idx]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"bubble-sort\"\u003eBubble Sort\u003c/h2\u003e\n\u003cp\u003e以升序为例，在未排序元素中依次比较相邻两个元素，若乱序则交换两个元素，这样一来较大的元素就会被慢慢移动到末尾有序排列。通常在冒泡排序中设置一个 \u003ccode\u003eflag\u003c/code\u003e，当没有发生交换操作时，说明数组已经有序，停止遍历。\u003c/p\u003e","title":"Classic Sort Algorithm"},{"content":"Box\u0026lt;T\u0026gt; Box 是最简单的智能指针，它允许你将一个值放在堆上而不是栈上。\nfn main() { let f1 = foo { bar: 32 }; let f2 = Box::new(foo { bar: 11 }); println!(\u0026#34;address on stack: {:p}\u0026#34;, \u0026amp;f1); println!(\u0026#34;address on heap: {:p}\u0026#34;, f2); println!(\u0026#34;address of box(on stack): {:p}\u0026#34;, \u0026amp;f2); } struct foo { bar: i32, } // address on stack: 0x7ffd34540f0c // address on heap: 0x57d39e669ba0 // address of box(on stack): 0x7ffd34540f10 Box 只提供了间接存储和堆分配，除此之外没有其他特殊功能。\n// 利用 Box 实现递归类型 enum List { Cons(i32, Box\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); } Deref Trait 实现 Deref trait 可以重载解引用运算符 *。\nuse std::ops::Deref; fn main() { let a = 4; let b = MyBox::new(a); println!(\u0026#34;{:?}\u0026#34;, *b); assert_eq!(4, *b); } #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } // 为结构体实现 Deref Trait impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target { \u0026amp;self.0 } } 在执行 *y 时，Rust 会将其替换为 *(y.deref())。\nDeref 强制转换 Deref 强制转换（Deref coercions） 将实现了 Deref trait 的类型的引用转换为另一种类型的引用。比如将 \u0026amp;String 转换为 \u0026amp;str。\nDeref 强制转换发生在编译时，因此并没有运行时损耗。\nDeref trait 用于重载不可变引用的解引用运算符，而 DerefMut trait 用于重载可变引用的解引用运算符。\nRust 在发现类型和 trait 满足三种情况时会进行 Deref 强制转换：\n当 T: Deref\u0026lt;Target=U\u0026gt; 时从 \u0026amp;T 到 \u0026amp;U。 当 T: DerefMut\u0026lt;Target=U\u0026gt; 时从 \u0026amp;mut T 到 \u0026amp;mut U。 当 T: Deref\u0026lt;Target=U\u0026gt; 时从 \u0026amp;mut T 到 \u0026amp;U。 Drop Trait Drop trait 允许我们在值要离开作用域时执行一些代码。\nuse std::ops::Deref; fn main() { let a = 4; let b = MyBox::new(a); assert_eq!(4, *b); } #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } // 为结构体实现 Deref Trait impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target { \u0026amp;self.0 } } // 为结构体实现 Drop trait impl\u0026lt;T\u0026gt; Drop for MyBox\u0026lt;T\u0026gt; { fn drop(\u0026amp;mut self) { println!(\u0026#34;Drop MyBox\u0026#34;); } } Rust 不允许直接调用 Drop trait 的 drop 方法。因为 Rust 仍然会在值离开作用域时自动调用，这会导致二次释放的错误。\n若要强制提前清理值，可以使用 std::mem::drop 函数。\nlet b = MyBox::new(24); // std::mem::drop 位于 prelude 中 drop(b); Rc\u0026lt;T\u0026gt; 有时候一个值会有多个所有者。比如图的节点会被多条边连接。\nRc\u0026lt;T\u0026gt; 允许我们在堆上分配一些可以被程序的多个部分读取的内存。Rc\u0026lt;T\u0026gt; 只用于不可变引用且只能用于单线程场景。\nuse std::rc::Rc; #[derive(Debug)] enum List { // 使用 Rc\u0026lt;T\u0026gt; 存储 List Cons(i32, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let a = Rc::new(Cons(24, Rc::new(Cons(25, Rc::new(Nil))))); println!(\u0026#34;{:p}\u0026#34;, a); // Rc 重载了 Deref trait，返回 T if let Cons(_, i) = \u0026amp;*a { println!(\u0026#34;{:p}\u0026#34;, i); if let Cons(_, k) = \u0026amp;**i { println!(\u0026#34;{:p}\u0026#34;, k) } } // 通过 Rc::strong_count(\u0026amp;a) 查看引用计数 println!(\u0026#34;{}\u0026#34;, Rc::strong_count(\u0026amp;a)); // Rc::clone() 增加引用计数，Rc 的 clone 方法的效果与 Rc::clone 相同 let b = Rc::clone(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, Rc::strong_count(\u0026amp;b)); let c = Rc::clone(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, Rc::strong_count(\u0026amp;c)); // 普通的不可变引用，在栈上配分内存 let d = \u0026amp;a; println!(\u0026#34;{:p}\u0026#34;, d); } RefCell\u0026lt;T\u0026gt; **内部可变性（Interior mutability）**是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。\n#[derive(Debug)] enum List { Cons(Rc\u0026lt;RefCell\u0026lt;i32\u0026gt;\u0026gt;, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; use std::cell::RefCell; use std::rc::Rc; fn main() { let value = Rc::new(RefCell::new(5)); let a = Rc::new(Cons(Rc::clone(\u0026amp;value), Rc::new(Nil))); let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(\u0026amp;a)); let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(\u0026amp;a)); // value 本身不可变，但可以通过 RefCell\u0026lt;T\u0026gt; 的 borrow_mut 方法修改其内部的值 // borrow_mut 返回 RefMut\u0026lt;T\u0026gt;，类似 \u0026amp;mut *value.borrow_mut() += 10; println!(\u0026#34;a after = {a:?}\u0026#34;); println!(\u0026#34;b after = {b:?}\u0026#34;); println!(\u0026#34;c after = {c:?}\u0026#34;); if let Cons(i, k) = b { println!(\u0026#34;{:#?}\u0026#34;, i); *i.borrow_mut() += 10; println!(\u0026#34;{:#?}\u0026#34;, i); if let Cons(x, _) = \u0026amp;*k { println!(\u0026#34;{:#?}\u0026#34;, x); *x.borrow_mut() += 10; println!(\u0026#34;{:#?}\u0026#34;, x); } } } Weak\u0026lt;T\u0026gt; use std::cell::RefCell; use std::rc::{Rc, Weak}; #[derive(Debug)] struct Node { value: i32, parent: RefCell\u0026lt;Weak\u0026lt;Node\u0026gt;\u0026gt;, children: RefCell\u0026lt;Vec\u0026lt;Rc\u0026lt;Node\u0026gt;\u0026gt;\u0026gt;, } fn main() { let leaf = Rc::new(Node { value: 3, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![]), }); println!( \u0026#34;leaf strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;leaf), // 查看实例的弱引用计数 Rc::weak_count(\u0026amp;leaf), ); { let branch = Rc::new(Node { value: 5, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![Rc::clone(\u0026amp;leaf)]), }); // 创建弱引用 *leaf.parent.borrow_mut() = Rc::downgrade(\u0026amp;branch); println!( \u0026#34;branch strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;branch), Rc::weak_count(\u0026amp;branch), ); println!( \u0026#34;leaf strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;leaf), Rc::weak_count(\u0026amp;leaf), ); } // upgrade() 方法检查所引用的实例是否还存在，返回 Option println!(\u0026#34;leaf parent = {:?}\u0026#34;, leaf.parent.borrow().upgrade()); println!( \u0026#34;leaf strong = {}, weak = {}\u0026#34;, Rc::strong_count(\u0026amp;leaf), Rc::weak_count(\u0026amp;leaf), ); } ","permalink":"https://tpcad.github.io/posts/rust_smart_pointer/","summary":"\u003ch2 id=\"boxt\"\u003e\u003ccode\u003eBox\u0026lt;T\u0026gt;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eBox 是最简单的智能指针，它允许你将一个值放在堆上而不是栈上。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e f1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e foo { bar: \u003cspan style=\"color:#ae81ff\"\u003e32\u003c/span\u003e };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e f2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Box::new(foo { bar: \u003cspan style=\"color:#ae81ff\"\u003e11\u003c/span\u003e });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;address on stack: \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{:p}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ef1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;address on heap: \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{:p}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, f2);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    println!(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;address of box(on stack): \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{:p}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ef2);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    bar: \u003cspan style=\"color:#66d9ef\"\u003ei32\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// address on stack: 0x7ffd34540f0c\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// address on heap: 0x57d39e669ba0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// address of box(on stack): 0x7ffd34540f10\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBox 只提供了间接存储和堆分配，除此之外没有其他特殊功能。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 利用 Box 实现递归类型\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eList\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Cons(\u003cspan style=\"color:#66d9ef\"\u003ei32\u003c/span\u003e, Box\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eList\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Nil,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003euse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ecrate\u003c/span\u003e::List::{Cons, Nil};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e list \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Cons(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, Box::new(Cons(\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, Box::new(Cons(\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, Box::new(Nil))))));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"deref-trait\"\u003eDeref Trait\u003c/h2\u003e\n\u003cp\u003e实现 \u003ccode\u003eDeref\u003c/code\u003e trait 可以重载解引用运算符 \u003ccode\u003e*\u003c/code\u003e。\u003c/p\u003e","title":"Rust Smart Pointer"},{"content":"创建 Github 仓库 创建博客源仓库 博客源仓库用于对 Hugo 的配置文件以及 Markdown 源文件进行备份和管理，并配合 Github Action 自动将生成的静态网页推送到 Github Pages 仓库。\n创建 Github Pages 仓库 以 username.github.io 形式命名的特殊仓库，使用 Github Pages 实现部署网站。\n创建博客 hugo new site Blog Hugo 生成的目录结构。\nBlog ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── i18n ├── layouts ├── static └── themes 关联博客源仓库 cd Blog git init git remote add origin git@github.com:TPCAD/tpcad-blog.git 配置 Hugo 主题 为了方便对主题进行自定义和版本控制，我们将 Hugo 主题 fork 到自己的 Github 账户，并以 submodule 的方式将主题添加到我们的博客源仓库。\ngit submodule add https://github.com/TPCAD/hugo-PaperMod.git themes/hugo-PaperMod 关于 PaperMod 主题的配置，见官方文档。\n如果需要同步主题仓库的最新修改，运行如下命令：\ngit submodule update --remote 关联 Github Pages 仓库 Hugo 默认会将生成的静态网页存放在 public 目录。我们可以将 Github Pages 仓库以子模块的方式添加到博客源仓库。\n# 生成静态网页 hugo cd public # 在 public 目录下建立 git 仓库，并关联远程仓库 git init git remote add git@github.com:TPCAD/tpcad.github.io.git # 进行一次 push，因为无法添加空的远程仓库作为子模块 git add . git commit -m \u0026#34;init\u0026#34; git push -u origin master # 回到根目录添加子模块 cd .. git submodule add git@github.com:TPCAD/tpcad.github.io.git public 现在已经可以通过 `username.tpcad.io\u0026rsquo; 访问访问博客了。\n自动发布 借助 Github Action，可以实现在博客源仓库提交后，自动生成静态网页并推送到 Github Pages 仓库。\n访问 Token 因为需要推送到外部仓库，我们要先获取一个访问 Token。\n进入 Github，在 Settings -\u0026gt; Developer Setttings -\u0026gt; Personal access tokens -\u0026gt; Generate new token(classic 创建一个 Token。\nSocpes 选择 repo 和 workfolw 。\n复制该 Token（Token 只会出现一次）到博客源仓库的 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; Repository secrets 创建一个 Repository secrets。\n创建 Github Action 在博客源仓库目录下创建 .github/workflows/deploy.yml。\n配置如下。将 EXTERNAL_REPOSITORY 替换为自己的 Github Pages 仓库。\nname: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: TPCAD/tpcad.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 同步修改后，以后只需要在博客源仓库进行 push 就会自动将内容推送到 Github Pages 仓库中。\n常见问题 Github Pages 仓库没有启用 Github Action 在仓库的 Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Branch 中选择需要分支并保存，即可启用 Github Pages。\n参考资料 Hugo + GitHub Action，搭建你的博客自动发布系统 如何用 GitHub Pages + Hugo 搭建个人博客 ","permalink":"https://tpcad.github.io/posts/build_blog_with_hugo_and_github_action/","summary":"\u003ch2 id=\"创建-github-仓库\"\u003e创建 Github 仓库\u003c/h2\u003e\n\u003ch3 id=\"创建博客源仓库\"\u003e创建博客源仓库\u003c/h3\u003e\n\u003cp\u003e博客源仓库用于对 Hugo 的配置文件以及 Markdown 源文件进行备份和管理，并配合 Github Action 自动将生成的静态网页推送到 Github Pages 仓库。\u003c/p\u003e\n\u003ch3 id=\"创建-github-pages-仓库\"\u003e创建 Github Pages 仓库\u003c/h3\u003e\n\u003cp\u003e以 \u003ccode\u003eusername.github.io\u003c/code\u003e 形式命名的特殊仓库，使用 Github Pages 实现部署网站。\u003c/p\u003e\n\u003ch2 id=\"创建博客\"\u003e创建博客\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehugo new site Blog\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHugo 生成的目录结构。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-language\" data-lang=\"language\"\u003eBlog\n├── archetypes\n│   └── default.md\n├── assets\n├── content\n├── data\n├── hugo.toml\n├── i18n\n├── layouts\n├── static\n└── themes\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"关联博客源仓库\"\u003e关联博客源仓库\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecd Blog\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit init\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit remote add origin git@github.com:TPCAD/tpcad-blog.git\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"配置-hugo-主题\"\u003e配置 Hugo 主题\u003c/h3\u003e\n\u003cp\u003e为了方便对主题进行自定义和版本控制，我们将 Hugo 主题 fork 到自己的 Github 账户，并以 submodule 的方式将主题添加到我们的博客源仓库。\u003c/p\u003e","title":"Hugo + Github Action，搭建个人博客"}]